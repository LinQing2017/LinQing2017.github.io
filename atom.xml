<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LQing的博客</title>
  
  <subtitle>“做程序员太辛苦了, 我想换行，我该怎么办?” “敲一下回车。”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LinQing2017.github.io/"/>
  <updated>2019-10-29T07:33:55.974Z</updated>
  <id>https://LinQing2017.github.io/</id>
  
  <author>
    <name>LQing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/24/Greenplum-%E5%88%86%E5%8C%BA%E8%A1%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://LinQing2017.github.io/2019/10/24/Greenplum-分区表介绍/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.974Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>Greenplum 支持分区表，但是<strong>分区</strong>的概念需要和<strong>分布式</strong>区别开，Greenplum中所有表都是分布式的（分布在不同Segment上），但是并非所有表都是分区表。</p><p>分区是进行<strong>逻辑划分</strong>，而分布是表的<strong>物理划分</strong>，前者减少查询的数据扫描量，后者提供并行查询能力。</p><p><img src="https://greenplum.cn/gp6/graphics/partitions.jpg" alt=""></p><ul><li>分区操作会创建一个顶层（父）表以及一层或者多层子表；</li><li>这些父表和子表都可以独立查询，子表看上去和普通表无异；</li><li>使用pg_relation_size函数查询父表的存储空间时，大小为0；</li><li>父表和子表之间存在继承关系（即表结构、NOT NULL，DEFAULT，CHECK三种约束），修改父表的表结构子表会同步修改；</li><li>创建分区后可以用带有PARTITION子句的ALTER TABLE修改父表；</li><li>可以在父表插入语句，或者直接插入到子表。直接插入子表时会触发check检查，如果检查失败会返回一个错误；</li><li>删除父表时，子表会一并删除</li><li>复制表复制表不能进行分区；</li><li>多级分区可以基于同一个分区键，如可以基于年、月、日进行三级分区；</li><li>已有表不能改为分区表，用户需要创建新的表将原有表的数据导入；</li><li>分区表最多能有32,767个分区；</li><li>分区表上的主键或者唯一约束必须包含所有的分区列；</li></ul><p>分区策略：<strong>除非查询优化器能基于查询谓词排除一些分区，否则分区技术不能改进查询性能。</strong></p><p>对外部表进行分区时会产生一些限制：参考<a href="https://greenplum.cn/gp6/ddl/ddl-partition.html#topic80" target="_blank" rel="noopener">分区表的限制</a></p><h2 id="分区操作"><a href="#分区操作" class="headerlink" title="分区操作"></a>分区操作</h2><h3 id="默认分区"><a href="#默认分区" class="headerlink" title="默认分区"></a>默认分区</h3><ul><li>默认分区用来装载其他分区CHECK约束失败的行；</li><li>优化器在扫描时总会扫描默认分区（因此默认分区会影响分区表性能；</li><li>多级分区，一旦存在默认分区，那么每一级都需要保存默认分区；</li><li>含有默认分区时，用户可以从默认分区中分裂出新的分区；</li></ul><h3 id="pg-partitions视图"><a href="#pg-partitions视图" class="headerlink" title="pg_partitions视图"></a>pg_partitions视图</h3><ul><li>pg_partition：跟踪分区表以及它们的继承层次关系。</li><li>pg_partition_templates：展示使用一个子分区模板创建的子分区。</li><li>pg_partition_columns：显示在一个分区设计中用到的分区键列。</li></ul><h3 id="分区表操作"><a href="#分区表操作" class="headerlink" title="分区表操作"></a>分区表操作</h3><p>增加分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设原有分区范围为“2016-01-01 - 2017-02-01”，下面的语句将分区范围拓宽</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> </span><br><span class="line">    <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2017-02-01'</span>) INCLUSIVE </span><br><span class="line">    <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-03-01'</span>) EXCLUSIVE;、</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> </span><br><span class="line">            <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2017-02-01'</span>) INCLUSIVE </span><br><span class="line">            <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-03-01'</span>) EXCLUSIVE</span><br><span class="line">      ( <span class="keyword">SUBPARTITION</span> usa <span class="keyword">VALUES</span> (<span class="string">'usa'</span>), </span><br><span class="line">        <span class="keyword">SUBPARTITION</span> asia <span class="keyword">VALUES</span> (<span class="string">'asia'</span>), </span><br><span class="line">        <span class="keyword">SUBPARTITION</span> europe <span class="keyword">VALUES</span> (<span class="string">'europe'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为sales表的第12分区，添加一个2级分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ALTER</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="keyword">RANK</span>(<span class="number">12</span>))</span><br><span class="line">      <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> africa <span class="keyword">VALUES</span> (<span class="string">'africa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加默认分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> other;</span><br></pre></td></tr></table></figure><p>重命名分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 分区表使用下列命名习惯：&lt;parentname&gt;_&lt;level&gt;_prt_&lt;partition_name&gt;</span></span><br><span class="line"><span class="comment">-- 重命名父表，子表会跟着修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">RENAME</span> <span class="keyword">TO</span> globalsales;</span><br><span class="line"><span class="comment">-- 修改表的分区名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">RENAME</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="string">'2016-01-01'</span>) <span class="keyword">TO</span> jan16;</span><br></pre></td></tr></table></figure><p>删除分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="keyword">RANK</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">-- trancate分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">TRUNCATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="keyword">RANK</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>交换分区(参考<a href="https://greenplum.cn/gp6/ddl/ddl-partition.html#topic80" target="_blank" rel="noopener">用外部表交换叶子子分区</a>)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将分区sales_1_prt_1和jan12表交换，此后jan12表成为sales的分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> jan12 (<span class="keyword">LIKE</span> sales) <span class="keyword">WITH</span> (appendoptimized=<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> jan12 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_1_prt_1 ;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">EXCHANGE</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="built_in">DATE</span> <span class="string">'2012-01-01'</span>) </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">TABLE</span> jan12;</span><br></pre></td></tr></table></figure><p>分裂分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分裂普通分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">SPLIT</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="string">'2017-01-01'</span>) <span class="keyword">AT</span> (<span class="string">'2017-01-16'</span>)</span><br><span class="line"><span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> jan171to15, <span class="keyword">PARTITION</span> jan1716to31);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分裂默认分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">SPLIT</span> <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> </span><br><span class="line"><span class="keyword">START</span> (<span class="string">'2017-01-01'</span>) INCLUSIVE </span><br><span class="line"><span class="keyword">END</span> (<span class="string">'2017-02-01'</span>) EXCLUSIVE </span><br><span class="line"><span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> jan17, <span class="keyword">default</span> <span class="keyword">partition</span>);</span><br></pre></td></tr></table></figure><p>修改分区模板：修改后原有的分区不发生变化，参考<a href="https://greenplum.cn/gp6/ddl/ddl-partition.html#topic80" target="_blank" rel="noopener">修改子分区模板</a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>日期范围分区：使用单个date或者timestamp列作为分区键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在[START,END)范围内进行分区，每个分区的长度是‘1 day’，因此产生365个分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="built_in">date</span> <span class="built_in">date</span>, amt <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="built_in">date</span>)</span><br><span class="line">( <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-01-01'</span>) INCLUSIVE  </span><br><span class="line">   <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-01-01'</span>) EXCLUSIVE</span><br><span class="line">   EVERY (<span class="built_in">INTERVAL</span> <span class="string">'1 day'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定生成按月的分区，显示指定分区范围</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="built_in">date</span> <span class="built_in">date</span>, amt <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="built_in">date</span>)</span><br><span class="line">( <span class="keyword">PARTITION</span> Jan16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-01-01'</span>) INCLUSIVE , </span><br><span class="line">  <span class="keyword">PARTITION</span> Feb16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-02-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Mar16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-03-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Apr16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-04-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> May16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-05-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Jun16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-06-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Jul16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-07-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Aug16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-08-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Sep16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-09-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Oct16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-10-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Nov16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-11-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Dec16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-12-01'</span>) INCLUSIVE </span><br><span class="line">                  <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-01-01'</span>) EXCLUSIVE );</span><br></pre></td></tr></table></figure><p>按数字范围分区：表使用单个数字数据类型列作为分区键列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面的建表语句会创建11个分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">rank</span> (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">rank</span> <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, gender </span><br><span class="line"><span class="built_in">char</span>(<span class="number">1</span>), <span class="keyword">count</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">year</span>)</span><br><span class="line">( <span class="keyword">START</span> (<span class="number">2006</span>) <span class="keyword">END</span> (<span class="number">2016</span>) EVERY (<span class="number">1</span>), </span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> extra );</span><br></pre></td></tr></table></figure><p>定义列表分区表：使用任意允许等值比较的数据类型列作为它的分区键列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建rank_1_prt_boys、rank_1_prt_girls、rank_1_prt_other三个分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">rank</span> (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">rank</span> <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, gender </span><br><span class="line"><span class="built_in">char</span>(<span class="number">1</span>), <span class="keyword">count</span> <span class="built_in">int</span> ) </span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span> (gender)</span><br><span class="line">( <span class="keyword">PARTITION</span> girls <span class="keyword">VALUES</span> (<span class="string">'F'</span>), </span><br><span class="line">  <span class="keyword">PARTITION</span> boys <span class="keyword">VALUES</span> (<span class="string">'M'</span>), </span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> other );</span><br></pre></td></tr></table></figure><p>多级分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于时间和值的多级分区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    trans_id <span class="built_in">int</span>, </span><br><span class="line">    <span class="built_in">date</span> <span class="built_in">date</span>, </span><br><span class="line">    amount <span class="built_in">decimal</span>(<span class="number">9</span>,<span class="number">2</span>), </span><br><span class="line">    region <span class="built_in">text</span></span><br><span class="line">) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (trans_id)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="built_in">date</span>) </span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span> (region)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">TEMPLATE</span> ( </span><br><span class="line">    <span class="keyword">SUBPARTITION</span> usa <span class="keyword">VALUES</span> (<span class="string">'usa'</span>), </span><br><span class="line">    <span class="keyword">SUBPARTITION</span> asia <span class="keyword">VALUES</span> (<span class="string">'asia'</span>), </span><br><span class="line">    <span class="keyword">SUBPARTITION</span> europe <span class="keyword">VALUES</span> (<span class="string">'europe'</span>), </span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">SUBPARTITION</span> other_regions</span><br><span class="line">)(</span><br><span class="line">    <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2011-01-01'</span>) INCLUSIVE</span><br><span class="line">    <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2012-01-01'</span>) EXCLUSIVE</span><br><span class="line">    EVERY (<span class="built_in">INTERVAL</span> <span class="string">'1 month'</span>), </span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> outlying_dates </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 三级分区表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> p3_sales (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, <span class="keyword">month</span> <span class="built_in">int</span>, <span class="keyword">day</span> <span class="built_in">int</span>, region <span class="built_in">text</span>)</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">year</span>)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">month</span>)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">TEMPLATE</span> (</span><br><span class="line">    <span class="keyword">START</span> (<span class="number">1</span>)  <span class="keyword">END</span> (<span class="number">13</span>)  EVERY (<span class="number">1</span>),  <span class="keyword">DEFAULT</span> <span class="keyword">SUBPARTITION</span> other_months </span><br><span class="line">)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span> (region)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">TEMPLATE</span> (</span><br><span class="line">    <span class="keyword">SUBPARTITION</span> usa <span class="keyword">VALUES</span> (<span class="string">'usa'</span>),</span><br><span class="line">    <span class="keyword">SUBPARTITION</span> europe <span class="keyword">VALUES</span> (<span class="string">'europe'</span>),</span><br><span class="line">    <span class="keyword">SUBPARTITION</span> asia <span class="keyword">VALUES</span> (<span class="string">'asia'</span>),</span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">SUBPARTITION</span> other_regions </span><br><span class="line">)( </span><br><span class="line">    <span class="keyword">START</span> (<span class="number">2002</span>) <span class="keyword">END</span> (<span class="number">2012</span>) EVERY (<span class="number">1</span>), </span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> outlying_years </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://greenplum.cn/gp6/ddl/ddl-partition.html" target="_blank" rel="noopener">参考文档</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/16/Greenplum-%E8%B5%84%E6%BA%90%E9%98%9F%E5%88%97/"/>
    <id>https://LinQing2017.github.io/2019/10/16/Greenplum-资源队列/</id>
    <published>2019-10-16T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.974Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="资源队列"><a href="#资源队列" class="headerlink" title="资源队列"></a>资源队列</h1><p><strong>资源队列</strong>是Greenplum的<strong>默认资源管理方式</strong>，包括以下特点：</p><ul><li>可以定义多个不同的资源队列，pg_default是默认队列；</li><li>Role需要和一个队列绑定，不明确绑定时和pg_default绑定；</li><li>队列定义了并发数、内存、CPU等资源，ROLE的SQL消耗队列中的资源；</li><li>拥有SUPERUSER属性的角色将会不受资源队列的限制，查询立即执行（经过测试：发现并发数限制对SUPERUSER不起作用）；</li><li>resource_select_only=on时，INSERT、UPDATE、DELETE不会受到资源队列影响；</li><li>在执行EXPLAIN ANALYZE命令期间的SQL不受资源队列影响；</li></ul><p>资源队列包含以下特性：</p><ul><li>MEMORY_LIMIT：每个Segment中所有查询所使用的的内存的量；</li><li>ACTIVE_STATEMENTS：该队列的并发查询限制；</li><li>PRIORITY：队列的CPU优先级，包括LOW、MEDIUM、HIGH、MAX级别，默认为MEDIUM，级别越高CPU使用越优先；</li><li>MAX_COST：优化器评估上限，当优化器对SQL的消耗评估大于这个值时，SQL被队列拒绝。</li></ul><p><strong>默认队列pg_default</strong>的配置为：ACTIVE_STATEMENTS=20、PRIORITY=MEDIUM、没有MEMORY_LIMIT和MAX_COST。</p><p>内存管理相关注意：</p><ul><li><p>MEMORY_LIMIT不设定时，一个资源队列的可用内存大小是statement_mem*ACTIVE_STATEMENTS（statement_mem指定当前会话分配到内存）</p></li><li><p>设定MEMORY_LIMIT时，并行度受到当前使用的内存影响；</p></li><li><p>设定MEMORY_LIMIT时，每个会话分配的内存为MEMORY_LIMIT/ACTIVE_STATEMENTS（不指定statement_mem时）；</p></li><li><p>statement_mem可以覆盖会话的内存分配，取值范围是min(MEMORY_LIMIT, max_statement_mem)，命令为为set statement_mem=’128MB’；</p></li><li><p>配置文件级别也有statement_mem配置，值为125MB（是否生效？？）；</p></li><li><p>队列一旦分配出内存，直到查询结束才回收这一部分配额；</p></li><li><p><strong>gp_vmem_protect_limit</strong>决定了，单个Segment中所有队列的可用总内存；</p></li></ul><p>PRIORITY管理相关注意：</p><ul><li>SQL按照其资源队列的优先权共享可用的CPU资源;</li><li>SQL的复杂度不影响CPU的分配;</li><li>有新的SQL开始运行时，CPU份额将会被重新计算；</li></ul><h2 id="配置资源队列"><a href="#配置资源队列" class="headerlink" title="配置资源队列"></a>配置资源队列</h2><p>相关配置参数，包括以下：</p><ul><li><p>用于资源队列的一般配置：</p><ul><li>max_resource_queues </li><li>max_resource_portals_per_transaction </li><li>resource_select_only </li><li>resource_cleanup_gangs_on_wait </li><li>stats_queue_level </li></ul></li><li><p>内存利用有关配置：</p><ul><li>gp_resqueue_memory_policy </li><li>statement_mem</li><li>max_statement_mem </li><li>gp_vmem_protect_limit </li><li>gp_vmem_idle_resource_timeout（大并发时调整）</li><li>gp_vmem_protect_segworker_cache_limit （大并发时调整）</li><li>shared_buffers: 共享内存缓冲区大小，至少为128MB并且至少为16MB以max_connections。</li></ul></li><li><p>CPU优先级配置：</p><ul><li>gp_resqueue_memory_policy </li><li>gp_resqueue_priority_sweeper_interval </li><li>gp_resqueue_priority_cpucores_per_segment：每个Segment实例分配的CPU核数。Master和Segment的默认值是4，一般需要将HOST的所有CPU都利用上。</li></ul></li></ul><h2 id="SQL命令"><a href="#SQL命令" class="headerlink" title="SQL命令"></a>SQL命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建资源队列</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">RESOURCE</span> QUEUE adhoc <span class="keyword">WITH</span> (ACTIVE_STATEMENTS=<span class="number">3</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">RESOURCE</span> QUEUE myqueue <span class="keyword">WITH</span> (ACTIVE_STATEMENTS=<span class="number">20</span>, </span><br><span class="line">MEMORY_LIMIT=<span class="string">'2000MB'</span>);</span><br><span class="line"><span class="comment">-- 设定优先级</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">RESOURCE</span> QUEUE adhoc <span class="keyword">WITH</span> (<span class="keyword">PRIORITY</span>=<span class="keyword">LOW</span>);</span><br><span class="line"><span class="comment">-- 设定并发数</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">RESOURCE</span> QUEUE reporting <span class="keyword">WITH</span> (ACTIVE_STATEMENTS=<span class="number">20</span>);</span><br><span class="line"><span class="comment">-- 关联队列和role</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLE</span> <span class="keyword">name</span> <span class="keyword">RESOURCE</span> QUEUE queue_name;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="keyword">name</span> <span class="keyword">WITH</span> LOGIN <span class="keyword">RESOURCE</span> QUEUE queue_name;</span><br><span class="line"><span class="comment">-- 移除资源队列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLE</span> role_name <span class="keyword">RESOURCE</span> QUEUE <span class="keyword">none</span>;</span><br><span class="line"><span class="comment">-- 删除资源队列</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">RESOURCE</span> QUEUE <span class="keyword">name</span>;</span><br><span class="line"><span class="comment">-- 查看ROLE绑定的资源队列</span></span><br><span class="line"><span class="keyword">SELECT</span> rolname, rsqname <span class="keyword">FROM</span> pg_roles, </span><br><span class="line">          gp_toolkit.gp_resqueue_status </span><br><span class="line">   <span class="keyword">WHERE</span> pg_roles.rolresqueue=gp_toolkit.gp_resqueue_status.queueid;</span><br></pre></td></tr></table></figure><h2 id="查看队列中的语句和资源队列状态"><a href="#查看队列中的语句和资源队列状态" class="headerlink" title="查看队列中的语句和资源队列状态"></a>查看队列中的语句和资源队列状态</h2><ul><li><p>gp_toolkit.gp_resqueue_status可以查看队列资源的使用情况；</p></li><li><p>stats_queue_level = on可以收集统计信息和性能，通过pg_stat_resqueues可以查看收集到的信息；</p></li><li><p>gp_toolkit.gp_locks_on_resqueue可以查看等待的SQL；</p></li><li><p>参看当前活跃或者等待的SQL，如果需要结束这些SQL执行pg_cancel_backend(31905)；</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_stat_activity.pid,rolname, rsqname,granted, datname,<span class="keyword">query</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">   pg_roles, gp_toolkit.gp_resqueue_status, pg_locks, pg_stat_activity </span><br><span class="line"><span class="keyword">WHERE</span> pg_roles.rolresqueue=pg_locks.objid </span><br><span class="line">   <span class="keyword">AND</span> pg_locks.objid=gp_toolkit.gp_resqueue_status.queueid</span><br><span class="line">   <span class="keyword">AND</span> pg_stat_activity.pid=pg_locks.pid</span><br><span class="line">   <span class="keyword">AND</span> pg_stat_activity.usename=pg_roles.rolname;</span><br></pre></td></tr></table></figure><ul><li>gp_toolkit.gp_resq_priority_statement可以查看SQL优先级，超级用户可以修改某个SQL的优先级（gp_adjust_priority函数）</li></ul><h2 id="内存配置对资源队列影响："><a href="#内存配置对资源队列影响：" class="headerlink" title="内存配置对资源队列影响："></a>内存配置对资源队列影响：</h2><p>主要关注：vm.overcommit_ratio、gp_vmem_protect_limit、shared_buffers</p><ul><li>主机内存，Segment主机的可用内存，主要由<strong>vm.overcommit_ratio</strong>配置控制（此处讨论的情况是Segment主机单独部署的情形）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通常配置95即可，若果是资源组模式可以配置50</span></span><br><span class="line">vm.overcommit_ratio = 95</span><br></pre></td></tr></table></figure><ul><li>Segment实例内存，每个Segment的可用内存由<strong>gp_vmem_protect_limit</strong>控制：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gp_vmem_rq是GP使用的内存，计算公式为（0.95*RAM - 7.5GB）/1.7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mirror不计入活跃内存</span></span><br><span class="line">gp_vmem_protect_limit = gp_vmem_rq / 最大活跃Segment数目</span><br></pre></td></tr></table></figure><ul><li>shared_buffers: 共享内存缓冲区大小，至少为128MB并且至少为16MB以max_connections。</li></ul><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="1-基线硬件性能"><a href="#1-基线硬件性能" class="headerlink" title="1. 基线硬件性能"></a>1. 基线硬件性能</h2><p>gpcheckperf 可以进行：</p><ul><li>磁盘I/O测试（dd测试）：默认情况下，在会在磁盘目录下读写2倍内存大小的文件</li><li>内存带宽测试（流) ：使用STREAM基准程序来测量可持续的内存带宽（以MB/s为单位），该测试不涉及CPU计算性能。</li><li>网络性能测试（gpnetbench*）：当前主机发送5秒钟的数据流到测试中包含的每台远程主机。数据被并行传输到每台远程主机，支持串行（一台一台通信）、并行、全矩阵测试。</li></ul><p>测试命令：<a href="https://gp-docs-cn.github.io/docs/utility_guide/admin_utilities/gpcheckperf.html" target="_blank" rel="noopener">参考</a></p><h2 id="2-CPU带宽与内存带宽的计算"><a href="#2-CPU带宽与内存带宽的计算" class="headerlink" title="2. CPU带宽与内存带宽的计算"></a>2. CPU带宽与内存带宽的计算</h2><p>内存带宽：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存带宽=内存（等效）频率（内存工作频率X倍频，DDR内存为2，DDR2内存为4，DDR3内存为8）X位宽/8。</span><br></pre></td></tr></table></figure><p>CPU的工作频率涉及<strong>主频、外频、倍频</strong>三个概念</p><pre><code>- 主频：CPU自身的工作频率- 外频：电脑主板提供的系统总线频率，外频是其他组件和CPU通信的基准（lscpu |grep &quot;CPU MHz&quot;，外频可能因为一些其他原因不断变化）- 倍频：主频/外频</code></pre><p>CPU的带宽一般指：CPU与北桥数据交换的速度，也叫作<strong>前端总线FSB</strong>。早期，FSB和外频一致的，使用QDR技术后，前端总线的频率成为外频的两倍或者是四倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intel处理器前端总线（FSB）= 处理器前端总线频率（MHz，处理器外频X4）X位宽（Bit）/8</span><br></pre></td></tr></table></figure><p>参考:<a href="https://www.cnblogs.com/l1pe1/archive/2012/02/02/2335557.html" target="_blank" rel="noopener">PC总线带宽与内存带宽的计算</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>Yarn磁盘管理</title>
    <link href="https://LinQing2017.github.io/2019/10/16/Yarn%E7%9A%84%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>https://LinQing2017.github.io/2019/10/16/Yarn的磁盘管理/</id>
    <published>2019-10-16T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.975Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Yarn磁盘管理"><a href="#Yarn磁盘管理" class="headerlink" title="Yarn磁盘管理"></a>Yarn磁盘管理</h1><p>Yarn中NodeManager使用的最重要的两个本地目录：</p><ul><li><p>yarn.nodemanager.local-dirs：Container的缓存目录</p></li><li><p>yarn.nodemanager.log-dirs：保存容器日志的本地目录，每个nodemanager都会有这样一个目录，目录格式为：application_${appid}/container_{$contid}，其中包含：</p><ul><li>stderr</li><li>stdout</li><li>prelaunch.err</li><li>prelaunch.out</li><li>container-localizer-syslog</li></ul></li></ul><p>通常情况下，Yarn会自动清理这两个目录的日志，涉及到下面的二个参数，日志保留时间为二个参数的时间之和：</p><ul><li>yarn.nodemanager.delete.debug-delay-sec：App完成后DeletionService会在指定时间后删除本地日志。默认值为0</li><li>yarn.nodemanager.log.retain-seconds：保留日志时间，只有当日志聚合关闭时有效。默认值为3小时</li></ul><p>Yarn支持HDFS上的日志聚合功能，逻辑为：Application任务运行时日志写在log-dirs，运行完成以后 DeletionService 服务，把日志移动到HDFS上，然后删除本地日志。</p><p>日志聚合涉及的配置包括：</p><ul><li>yarn.log-aggregation-enable：是否开启日志聚合</li><li>yarn.nodemanager.remote-app-log-dir：聚合根目录</li><li>yarn.nodemanager.remote-app-log-dir-suffix：聚合目录，hdfs上日志保存位置为{yarn.nodemanager.remote-app-log-dir}/${user}/{yarn.nodemanager.remote-app-log-dir-suffix}</li><li>yarn.log-aggregation.retain-seconds：聚合日志保留时间</li><li>yarn.log-aggregation.retain-check-interval-seconds：清理任务运行时间间隔</li></ul><p>Yarn支持对local-dirs和log-dirs进行健康检查，相关配置为yarn.nodemanager.disk-health-checker.XXXXXX：</p><ul><li>min-healthy-disks：log-dir/local-dirs健康目录的最小值，如果低于这个值，nn会被剔除</li><li>max-disk-utilization-per-disk-percentage：监控log-dir和local-dirs的使用空间阈值，高于这个值磁盘被标记成不健康。</li><li>disk-utilization-watermark-low-per-disk-percentage：bad状态目录恢复为可用的空间水线</li><li>min-free-space-per-disk-mb：健康目录的最小剩余空间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Yarn磁盘管理&quot;&gt;&lt;a href=&quot;#Yarn磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;Yarn磁盘管理&quot;&gt;&lt;/a&gt;Yarn磁盘管理&lt;/h1&gt;&lt;p&gt;Yarn中NodeManager使用的最重要的两个本地目
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://LinQing2017.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Yarn" scheme="https://LinQing2017.github.io/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/10/Greenplum-%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>https://LinQing2017.github.io/2019/10/10/Greenplum-导入导出/</id>
    <published>2019-10-10T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.974Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="数据装载"><a href="#数据装载" class="headerlink" title="数据装载"></a>数据装载</h1><h2 id="1-INSERT语句"><a href="#1-INSERT语句" class="headerlink" title="1. INSERT语句"></a>1. INSERT语句</h2><p>INSERT语句只适合在小规模的堆表场景中使用，并且有以下特点：</p><ul><li>单个INSERT命令中插入多行，如：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (product_no, <span class="keyword">name</span>, price) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'Cheese'</span>, <span class="number">9.99</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'Bread'</span>, <span class="number">1.99</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'Milk'</span>, <span class="number">2.99</span>);</span><br></pre></td></tr></table></figure></li><li>对于追加优化表， Greenplum数据库支持最多127个并发INSERT 事务插入到一个追加优化表。</li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>通过pgbench和sysbench进行基于INSERT、UPDATE等简单SQL的性能测试，有以下发现：</p><ul><li>测试环境（32核CPU）中插入性能的瓶颈是CPU，50个线程时，单表TPS为15000~16000，单表单线程TPS为500。PS：单块SSD似乎最先到达瓶颈，但是对Greenplum进行扩容性能没有明显提升。</li><li><strong>关闭optimizer配置能够极大提升简单SQL的性能，测试中optimizer配置开启时性能只有原来20%，并且巨量消耗Master的CPU资源。PS：这个配置默认开启！</strong></li><li>Master节点上每个Client连接会产生多个Postgres进程（似乎和Segment数量有关）</li><li>测试中一条INSERT插入多行数据对TPS影响不大</li><li>gp_enable_global_deadlock_detector = on 时可以极大的提升UPDATE操作的性能（10倍以上）</li></ul><p>关于OLTP的性能测试，Greenplum官方给出了基于Greenplum 6的测试教程，测试在48核的 Master上得到了单表18000 TPS以上的性能。测试结果和实际基本符合。</p><p>参考：<a href="https://greenplum.org/oltp-workload-performance-improvement-in-greenplum-6/" target="_blank" rel="noopener">官方文档</a>、<a href="https://greenplum.cn/2019/05/14/greenplum-6-oltp-60x/" target="_blank" rel="noopener">中文社区翻译</a></p><h2 id="2-COPY语句"><a href="#2-COPY语句" class="headerlink" title="2. COPY语句"></a>2. COPY语句</h2><p> COPY命令是非并行操作，数据流需要通过Master实例。</p><ul><li>COPY只能用于表，不能用于视图。</li><li>，支持常用的文件格式，如：txt、sql、csv、压缩文件、二进制格式等</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- COPY 语句只能在master节点上运行</span></span><br><span class="line">COPY table_name FROM '/path/to/filename' <span class="keyword">WITH</span> (<span class="keyword">FORMAT</span> csv);</span><br><span class="line"><span class="comment">-- \copy 语句可以在client节点上运行，其基于COPY FROM STDIN语句从STDIN读取输入并发送给Master</span></span><br><span class="line">\copy table_name FROM '/path/to/filename';</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用COPY命令导出数据</span></span><br><span class="line">COPY (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pgbench_accounts <span class="keyword">limit</span> <span class="number">10</span>) <span class="keyword">TO</span> <span class="string">'/home/gpadmin/pgbench_accounts.csv'</span> <span class="keyword">WITH</span> csv;</span><br></pre></td></tr></table></figure><p>默认情况下，COPY会在第一个错误处停止操作：如果数据包含一个错误，该操作失败并且没有数据被装载(即没有一条数据被导入)。</p><p>用户可以使用单行错误隔离模式，Greenplum会跳过包含格式错误的行并且装载正确格式化的行。需要注意的是：这里的错误指数据格式的错误，不包含约束错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用单行错误隔离模式，每个segment容许10行错误</span></span><br><span class="line">COPY country FROM '/data/gpdb/country_data' </span><br><span class="line">   <span class="keyword">WITH</span> DELIMITER <span class="string">'|'</span> <span class="keyword">LOG</span> <span class="keyword">ERRORS</span></span><br><span class="line">   <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="number">10</span> <span class="keyword">ROWS</span>;</span><br></pre></td></tr></table></figure><h3 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h3><p>使用COPY命令<strong>单线程</strong>，导入<strong>1亿</strong>条数据，数据原始大小9.7GB，用时136692.713 ms，平均<strong>731567条/s</strong>。</p><p>测试过程中，磁盘性能优先达到瓶颈。</p><p>调优建议：</p><ul><li>在装载数据到新表中时，最后创建索引。</li><li>装载完成后执行VACUUM ANALYZE来为查询优化器更新表统计信息</li><li>在装载错误后运行VACUUM，清理缓存表。<h2 id="3-外部表并行读写"><a href="#3-外部表并行读写" class="headerlink" title="3. 外部表并行读写"></a>3. 外部表并行读写</h2></li></ul><p>通过外部表，可以使向Greenplum导入导出数据并行化，使Greenplum真正具备并行读写的能力。</p><p>导入数据：</p><pre><code>- 准备数据文件- 创建外部表（初次导入时还要创建数据表）- INSERT INTO tablename  SELECT * from tablename_ext_temp;- 删除外部表、外部数据文件</code></pre><h3 id="外部表"><a href="#外部表" class="headerlink" title="外部表"></a>外部表</h3><p>根据外部表允许的操作，包括：</p><ul><li>可读外部表：仅允许SELECT操作。</li><li>可写外部表：仅允许INSERT操作</li></ul><p>根据外部表数据源的状态，包括：</p><ul><li><p>普通（基于文件的）：访问静态平面文件</p></li><li><p>Web（基于Web的）：访问动态数据源</p><ul><li><p>基于命令的web表：建表时将table关联到可执行脚本，每次查询时基于脚本的返回结果，因此该表对应的返回值是动态的，用户可以指定master或者特定segments运行这个脚本。</p></li><li><p>基于URL的web表：定义表时LOCATION里定义基于http://协议的web服务文件路径，指定的http地址数目取决于GP集群中的Segment数目。</p></li></ul></li></ul><p>当前支持的外部表协议：</p><table><thead><tr><th>协议类型</th><th>表类型</th><th>数据存放位置</th><th>说明</th></tr></thead><tbody><tr><td>file</td><td>只能是可读表</td><td>Segment主机</td><td>每个Segment只能处理一个外部文件，所以单个Seg-Host上的文件数目，取决于运行Segment实例数目</td></tr><tr><td>gpfdist/gpfdists</td><td>可读/写表</td><td>gpfdist服务器（一个或者多个）</td><td>跨主机协议、支持数据压缩和数据转换</td></tr><tr><td>pxf、S3</td><td>自定义接口</td><td>Hadoop系统、对象存储等</td><td></td></tr></tbody></table><p>定义外部表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file 外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> ext_expenses (</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">text</span>, <span class="built_in">date</span> <span class="built_in">date</span>, amount float4, <span class="keyword">category</span> <span class="built_in">text</span>, desc1 <span class="built_in">text</span> ) </span><br><span class="line">LOCATION (<span class="string">'file://host1:5432/data/expense/*.csv'</span>, </span><br><span class="line">          <span class="string">'file://host2:5432/data/expense/*.csv'</span>, </span><br><span class="line">          <span class="string">'file://host3:5432/data/expense/*.csv'</span>) </span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'CSV'</span> (HEADER); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于命令的web外部表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> log_output </span><br><span class="line">    (linenum <span class="built_in">int</span>, message <span class="built_in">text</span>) </span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'/var/load_scripts/get_log_data.sh'</span> <span class="keyword">ON</span> HOST</span><br><span class="line">    <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">'|'</span>);</span><br></pre></td></tr></table></figure><h3 id="gpfdist"><a href="#gpfdist" class="headerlink" title="gpfdist"></a>gpfdist</h3><p>通常情况下，gpfdist作为一个第三方服务运行在Greenplum集群之外的服务器上（一般是ETL服务器）。Greenplum和gpfdist服务之间通过HTTP/HTTPS协议通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动gpfdist服务，配置数据目录和日志目（建议先安装Greenplum，否则启动可能缺依赖）</span></span><br><span class="line">gpfdist -d /data/data_ssd/gpfdist_files -p 18081 -l /var/log/gpfdist/gpfdist.log &amp;</span><br></pre></td></tr></table></figure><p>gpfdist的优势：</p><ul><li>外部文件支持压缩、CSV等格式</li><li>支持将外部XML（json）文件读入Greenplum数据库（通过配置YAML格式的文件）</li><li>外部表可以连接一个或多个gpfdist实例（无论一个还是多个，Segment连接外部表时均是并行的）</li><li>一台ETL服务器上可以运行多个gpfdist实例（不同的数据目录，以及端口）</li></ul><p>性能控制：</p><ul><li>gp_external_max_segs：数控制能同时访问单一gpfdist实例的Segment实例数量，默认64个；</li></ul><h3 id="gpload"><a href="#gpload" class="headerlink" title="gpload"></a>gpload</h3><p>gpload是Greenplum提供的并行导入工具，工作原理基于gpfdist，用户通过定义YAML文件来控制gpload导入的表结构。</p><ul><li>支持多种表导入模式<ul><li>INSERT</li><li>UPDATE</li><li>MERGE</li></ul></li><li>gpload会在外部文件上重新拉起gpfdist进程，知道导入完成</li><li>gpload会创建一张临时外部表，因此执行用户要有建外部表权限，以及写入数据权限</li></ul><p>gpload的导入命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpload -f insert.yaml -l gpload.log</span><br></pre></td></tr></table></figure><p>gpload使用的控制文件如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">VERSION:</span> <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">DATABASE:</span> <span class="string">pgbench</span></span><br><span class="line"><span class="attr">USER:</span> <span class="string">benchtest</span></span><br><span class="line"><span class="attr">HOST:</span> <span class="number">172.24</span><span class="number">.9</span><span class="number">.12</span></span><br><span class="line"><span class="attr">PORT:</span> <span class="number">5432</span></span><br><span class="line"><span class="attr">GPLOAD:</span></span><br><span class="line"><span class="attr">   INPUT:</span></span><br><span class="line"><span class="attr">    - SOURCE:</span></span><br><span class="line"><span class="attr">         LOCAL_HOSTNAME:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="number">172.24</span><span class="number">.33</span><span class="number">.35</span></span><br><span class="line"><span class="attr">         PORT:</span> <span class="number">19090</span></span><br><span class="line"><span class="attr">         FILE:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">/data/data_ssd/gpfdist_files/pgbench/pgbench_accounts/*</span></span><br><span class="line"><span class="attr">    - COLUMNS:</span></span><br><span class="line"><span class="attr">               - aid:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">               - bid:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">               - abalance:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">               - filler:</span> <span class="string">character(84)</span></span><br><span class="line"><span class="attr">    - FORMAT:</span> <span class="string">csv</span></span><br><span class="line"><span class="attr">    - DELIMITER:</span> <span class="string">','</span></span><br><span class="line"><span class="attr">    - QUOTE:</span> <span class="string">'"'</span></span><br><span class="line"><span class="attr">    - HEADER:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">   OUTPUT:</span></span><br><span class="line"><span class="attr">    - TABLE:</span> <span class="string">public.pgbench_accounts_gpload_ins</span></span><br><span class="line"><span class="attr">    - MODE:</span> <span class="string">INSERT</span></span><br></pre></td></tr></table></figure><p>详细参数说明参考<a href="https://gp-docs-cn.github.io/docs/utility_guide/admin_utilities/gpload.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="性能测试-2"><a href="#性能测试-2" class="headerlink" title="性能测试"></a>性能测试</h3><p>使用<strong>单点gpfdist服务</strong>将外部表导入为GP的系统，导入<strong>1亿</strong>条数据，数据原始大小9.7GB，用时35962.171 ms，平均<strong>2780699条/s</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建内部堆表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pgbench_accounts (</span><br><span class="line">    aid <span class="built_in">integer</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    bid <span class="built_in">integer</span>,</span><br><span class="line">    abalance <span class="built_in">integer</span>,</span><br><span class="line">    filler <span class="built_in">character</span>(<span class="number">84</span>)</span><br><span class="line">) <span class="keyword">WITH</span> (fillfactor=<span class="string">'100'</span>) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (aid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  创建外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> pgbench_accounts_ext_tmp ( </span><br><span class="line">    aid <span class="built_in">integer</span>, </span><br><span class="line">    bid <span class="built_in">integer</span>, </span><br><span class="line">    abalance <span class="built_in">integer</span>, </span><br><span class="line">    filler <span class="built_in">character</span>(<span class="number">84</span>) </span><br><span class="line">) LOCATION (<span class="string">'gpfdist://172.24.33.35:18081/pgbench/pgbench_accounts/*'</span>) <span class="keyword">FORMAT</span> <span class="string">'csv'</span>;</span><br><span class="line"><span class="comment">-- 导入堆表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pgbench_accounts  <span class="keyword">SELECT</span> * <span class="keyword">from</span> pgbench_accounts_ext_tmp;</span><br></pre></td></tr></table></figure><h1 id="使用gpfdist和gpload转换外部数据"><a href="#使用gpfdist和gpload转换外部数据" class="headerlink" title="使用gpfdist和gpload转换外部数据"></a>使用gpfdist和gpload转换外部数据</h1><p>Greenplum支持将任意格式的数据导入到数据中，或者将数据库中表以任意格式导出，以下说明导入XML到Greenplum的表中。</p><p>XML文件内容（文件名为pricerecord.xml）如下，包含：itemnumber和price两个字段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prices</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemnumber</span>&gt;</span>708421<span class="tag">&lt;/<span class="name">itemnumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>19.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemnumber</span>&gt;</span>708466<span class="tag">&lt;/<span class="name">itemnumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>59.25<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemnumber</span>&gt;</span>711121<span class="tag">&lt;/<span class="name">itemnumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>24.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pricerecord</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">prices</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的表结构为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prices (</span><br><span class="line">itemnumber <span class="built_in">integer</span>,       </span><br><span class="line">price      <span class="built_in">decimal</span>        </span><br><span class="line">) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (itemnumber);</span><br></pre></td></tr></table></figure><p>进行导入前，用户需要准备一个脚本工具解析XML文档，该工具不限格式，应当有如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要注意的是：工具输出中不能带空行</span></span><br><span class="line">708421|19.99</span><br><span class="line">708466|59.25</span><br><span class="line">711121|24.99</span><br></pre></td></tr></table></figure><p>用户可以定义config.xml文件，将声明脚本解析工具，该文件中的参数<a href="https://greenplum.cn/gp6/load/topics/transforming-xml-data.html" target="_blank" rel="noopener">配置文件格式</a>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">VERSION:</span> <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">TRANSFORMATIONS:</span></span><br><span class="line"><span class="attr">    transformation_name1:</span>              <span class="comment"># 转换名称</span></span><br><span class="line"><span class="attr">        TYPE:</span>     <span class="string">input</span>               <span class="comment"># 转换类型，input或者output</span></span><br><span class="line"><span class="attr">        COMMAND:</span>  <span class="string">/bin/sh</span> <span class="string">trans_script.sh</span> <span class="string">%filename%</span>     <span class="comment"># 转换命令</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    transformation_name2:</span>         </span><br><span class="line"><span class="attr">        TYPE:</span>     <span class="string">output</span>              </span><br><span class="line"><span class="attr">        COMMAND:</span>  <span class="string">/bin/sh</span> <span class="string">trans_script.sh</span> <span class="string">%filename%</span> </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-</span> <span class="string">COMMAND中的</span> <span class="string">%filename%</span> <span class="string">在执行是被gpload配置文件中的定义替换</span></span><br></pre></td></tr></table></figure><p>创建gpload配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">VERSION:</span> <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">DATABASE:</span> <span class="string">pgbench</span></span><br><span class="line"><span class="attr">USER:</span> <span class="string">benchtest</span></span><br><span class="line"><span class="attr">HOST:</span> <span class="number">172.24</span><span class="number">.9</span><span class="number">.12</span></span><br><span class="line"><span class="attr">PORT:</span> <span class="number">5432</span></span><br><span class="line"><span class="attr">GPLOAD:</span></span><br><span class="line"><span class="attr">   INPUT:</span></span><br><span class="line"><span class="attr">     - TRANSFORM_CONFIG:</span> <span class="string">config.yaml</span>   <span class="comment"># 定义转换配置</span></span><br><span class="line"><span class="attr">     - TRANSFORM:</span> <span class="string">prices_input</span>         <span class="comment"># 定义要使用的转换</span></span><br><span class="line"><span class="attr">     - SOURCE:</span></span><br><span class="line"><span class="attr">         LOCAL_HOSTNAME:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="number">172.24</span><span class="number">.9</span><span class="number">.12</span></span><br><span class="line"><span class="attr">         PORT:</span> <span class="number">19090</span></span><br><span class="line"><span class="attr">         FILE:</span> </span><br><span class="line"><span class="bullet">           -</span> <span class="string">pricerecord.xml</span>           <span class="comment"># 待导入的xml文件（替换%filename% ）</span></span><br><span class="line"><span class="attr">     - COLUMNS:</span></span><br><span class="line"><span class="attr">         - itemnumber:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">         - price:</span> <span class="string">decimal</span></span><br><span class="line"><span class="attr">     - FORMAT:</span> <span class="string">TEXT</span></span><br><span class="line"><span class="attr">     - DELIMITER:</span> <span class="string">'|'</span></span><br><span class="line"><span class="attr">     - QUOTE:</span> <span class="string">'"'</span></span><br><span class="line"><span class="attr">     - HEADER:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">   OUTPUT:</span></span><br><span class="line"><span class="attr">     - TABLE:</span> <span class="string">public.prices</span></span><br><span class="line"><span class="attr">     - MODE:</span> <span class="string">INSERT</span></span><br></pre></td></tr></table></figure><p><strong>PS：用户也可以执行 gpfdist -c config.yaml 将装换加载到gpfdist中，创建外表直接读取xml文档</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> READABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> prices_readable (<span class="keyword">LIKE</span> prices)</span><br><span class="line">   LOCATION (<span class="string">'gpfdist://hostname:8080/prices.xml#transform=prices_input'</span>)</span><br><span class="line">   <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">'|'</span>)</span><br><span class="line">   <span class="keyword">LOG</span> <span class="keyword">ERRORS</span> <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h1><p>使用<strong>CREATE WRITABLE EXTERNAL TABLE</strong>命令定义外部表时，可以将数据导出到本地。</p><ul><li>Segment把数据发送到gpfdist，后者会把数据写到指定的文件中；</li><li>外部表定义中定义多个gpfdist URI时，输出数据划分到多个文件之间；</li><li>可写的外部Web表把输出行发送到一个脚本（或者应用）作为输入。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写入到gpfdist的外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> unload_expenses  ( <span class="keyword">LIKE</span> expenses ) </span><br><span class="line">   LOCATION (<span class="string">'gpfdist://etlhost-1:8081/expenses1.out'</span>, </span><br><span class="line">             <span class="string">'gpfdist://etlhost-2:8081/expenses2.out'</span>)</span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">','</span>) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (exp_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写入到HDFS的外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> unload_expenses  ( <span class="keyword">LIKE</span> expenses ) </span><br><span class="line">   LOCATION (<span class="string">'pxf://dir/path?PROFILE=hdfs:text'</span>) </span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">','</span>) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (exp_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可写外部web表，EXECUTE程序处理insert到这个表的每一行</span></span><br><span class="line"><span class="comment">-- 参考https://greenplum.cn/gp6/load/topics/g-defining-a-command-based-writable-external-web-table.html</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> <span class="keyword">output</span> (<span class="keyword">output</span> <span class="built_in">text</span>) </span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'export PATH=$PATH:/home/gpadmin/programs; myprogram.sh'</span> </span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> <span class="keyword">DISTRIBUTED</span> RANDOMLY</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向外部表写入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> writable_ext_table <span class="keyword">TO</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> writable_ext_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> regular_table;</span><br></pre></td></tr></table></figure><p>直接用COPY命令也可以导出，但是此时性能瓶颈受限于Master服务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> country <span class="keyword">WHERE</span> country_name <span class="keyword">LIKE</span> <span class="string">'A%'</span>) </span><br><span class="line"><span class="keyword">TO</span> <span class="string">'/home/gpadmin/a_list_countries.out'</span>;</span><br></pre></td></tr></table></figure><h1 id="PGBench测试工具"><a href="#PGBench测试工具" class="headerlink" title="PGBench测试工具"></a>PGBench测试工具</h1><p>pgbench是 PostgreSQL 上自带一个基准测试工具，能够让用户并发执行多次SQL语句，并且统计测试的TPS。</p><p>默认情况下，如果用户不提供自定义的测试SQL，那么测试时使用TPC-B方式进行OLTP测试，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 初始化测试数据库，比例因子-s（系数是10万），执行后pgbench中包括以下几张表：</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  table                   # of rows</span></span><br><span class="line"><span class="comment">--  ---------------------------------</span></span><br><span class="line"><span class="comment">--  pgbench_branches        1 * 1000</span></span><br><span class="line"><span class="comment">--  pgbench_tellers         10 * 1000</span></span><br><span class="line"><span class="comment">--  pgbench_accounts        100000 * 1000</span></span><br><span class="line"><span class="comment">--  pgbench_history         0 * 1000</span></span><br><span class="line"></span><br><span class="line">pgbench -i -s 1000 pgbench</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重要的测试选项包括-c（客户端数量）、 -t（事务数量）、-T（时间限制）以及-f（指定一个自定义脚本文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- pgbench 默认有三个内建脚本，分别是：tpcb-like、simple-update、select-only</span></span><br><span class="line">pgbench -c 100 -j 100 -r -T 60 -P 1 -s 1000 -b tpcb-like pgbench</span><br><span class="line">pgbench -c 100 -j 100 -r -T 60 -P 1 -s 1000 -b simple-<span class="keyword">update</span> pgbench</span><br><span class="line">pgbench -c <span class="number">100</span> -j <span class="number">100</span> -r -T <span class="number">60</span> -P <span class="number">1</span> -s <span class="number">1000</span> -b <span class="keyword">select</span>-<span class="keyword">only</span> pgbench</span><br></pre></td></tr></table></figure><p>以下是自定义测试脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\set scale 10000</span><br><span class="line">\set nbranches 1 * :scale</span><br><span class="line">\set ntellers 10 * :scale</span><br><span class="line">\set naccounts 100000 * :scale</span><br><span class="line">\set aid random(1,:naccounts)</span><br><span class="line">\set bid random(1,:nbranches)</span><br><span class="line">\set tid random(1,:ntellers)</span><br><span class="line">\set delta random(-5000,5000)</span><br><span class="line"></span><br><span class="line">INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="附：测试环境"><a href="#附：测试环境" class="headerlink" title="附：测试环境"></a>附：测试环境</h2><p>服务器：6 * 3 Segment（Master和Segment混合部署，并且共用一块SSD，并且配置mirror）<br>CPU：Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz 32核<br>内存：  125G<br>网络：10GB光纤</p><h2 id="附：创建外部表"><a href="#附：创建外部表" class="headerlink" title="附：创建外部表"></a>附：创建外部表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通可读外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> [READABLE] <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> table_name    </span><br><span class="line">    ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">      LOCATION (<span class="string">'file://seghost[:port]/path/file'</span> [, ...])</span><br><span class="line">        | (<span class="string">'gpfdist://filehost[:port]/file_pattern[#transform]'</span></span><br><span class="line">        | (<span class="string">'gpfdists://filehost[:port]/file_pattern[#transform]'</span></span><br><span class="line">            [, ...])</span><br><span class="line">        | (<span class="string">'gphdfs://hdfs_host[:port]/path/file'</span>)</span><br><span class="line">      <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'CSV'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">column</span> [, ...]]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'AVRO'</span></span><br><span class="line">           | <span class="string">'PARQUET'</span></span><br><span class="line"> </span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">     [ <span class="keyword">ENCODING</span> <span class="string">'encoding'</span> ]</span><br><span class="line">     [ [<span class="keyword">LOG</span> <span class="keyword">ERRORS</span> [<span class="keyword">INTO</span> error_table]] <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="keyword">count</span></span><br><span class="line">       [<span class="keyword">ROWS</span> | <span class="keyword">PERCENT</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- web可读外部表，每次读的数据动态变化</span></span><br><span class="line"><span class="keyword">CREATE</span> [READABLE] <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> table_name    </span><br><span class="line">   ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">      LOCATION (<span class="string">'http://webhost[:port]/path/file'</span> [, ...])</span><br><span class="line">    | <span class="keyword">EXECUTE</span> <span class="string">'command'</span> [<span class="keyword">ON</span> <span class="keyword">ALL</span></span><br><span class="line">                          | <span class="keyword">MASTER</span></span><br><span class="line">                          | number_of_segments</span><br><span class="line">                          | HOST [<span class="string">'segment_hostname'</span>]</span><br><span class="line">                          | <span class="keyword">SEGMENT</span> segment_id ]</span><br><span class="line">      <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'CSV'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">column</span> [, ...]]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">     [ <span class="keyword">ENCODING</span> <span class="string">'encoding'</span> ]</span><br><span class="line">     [ [<span class="keyword">LOG</span> <span class="keyword">ERRORS</span> [<span class="keyword">INTO</span> error_table]] <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="keyword">count</span></span><br><span class="line">       [<span class="keyword">ROWS</span> | <span class="keyword">PERCENT</span>] ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 普通可写外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">    ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">     LOCATION(<span class="string">'gpfdist://outputhost[:port]/filename[#transform]'</span></span><br><span class="line">      | (<span class="string">'gpfdists://outputhost[:port]/file_pattern[#transform]'</span></span><br><span class="line">          [, ...])</span><br><span class="line">      | (<span class="string">'gphdfs://hdfs_host[:port]/path'</span>)</span><br><span class="line">      <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">               [( [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>] )]</span><br><span class="line">          | <span class="string">'CSV'</span></span><br><span class="line">               [([QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> QUOTE <span class="keyword">column</span> [, ...]] ]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>] )]</span><br><span class="line">           | <span class="string">'AVRO'</span></span><br><span class="line">           | <span class="string">'PARQUET'</span></span><br><span class="line"> </span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">    [ <span class="keyword">ENCODING</span> <span class="string">'write_encoding'</span> ]</span><br><span class="line">    [ <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">column</span>, [ ... ] ) | <span class="keyword">DISTRIBUTED</span> RANDOMLY ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- web可写外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> table_name</span><br><span class="line">    ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'command'</span> [<span class="keyword">ON</span> <span class="keyword">ALL</span>]</span><br><span class="line">    <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">               [( [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>] )]</span><br><span class="line">          | <span class="string">'CSV'</span></span><br><span class="line">               [([QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> QUOTE <span class="keyword">column</span> [, ...]] ]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>] )]</span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">    [ <span class="keyword">ENCODING</span> <span class="string">'write_encoding'</span> ]</span><br><span class="line">    [ <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">column</span>, [ ... ] ) | <span class="keyword">DISTRIBUTED</span> RANDOMLY ]</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cloud.tencent.com/developer/article/1447227" target="_blank" rel="noopener">GP系统配置参数</a></p><p><a href="https://greenplum.cn/gp6/load/topics/transforming-xml-data.html" target="_blank" rel="noopener">XML转换示例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/07/Greenplum-%E4%BB%8B%E7%BB%8D&amp;%E9%83%A8%E7%BD%B2/"/>
    <id>https://LinQing2017.github.io/2019/10/07/Greenplum-介绍&amp;部署/</id>
    <published>2019-10-07T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.974Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>GreenPlum中文社区的<a href="https://greenplum.cn/intro/" target="_blank" rel="noopener">介绍</a>中，将Greenplum定位成<strong>开源大数据平台</strong>，而不仅仅是一个MPP数据查询引擎。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gp.stage.vonbros.com/wp-content/themes/twentyseventeen/assets/images/architecture.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Greenplum的优势：</p><ul><li>处理和分析各种数据源的数据的平台：包括hadoop、Hive、HBase、S3等等，支持结构化、半结构化、非结构化数据</li><li>数据水平分布、并行查询执行、专业优化器、线性扩展能力、多态存储、资源管理、高可用、高速数据加载</li><li>接口可扩展，支持SQL、JDBC和ODBC等行业标准</li><li>集成数据分析平台：MADlib (Github 245个Star，半死不活)</li><li>在金融、保险、证券等领域有众多应用案例，具备较为完善的生态</li><li>采用 ** Apache 2 协议 **</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://greenplum.cn/gp6/graphics/highlevel_arch.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Greenplum基本架构包括：Master、SegmentHost。</p><ul><li>Master：Greenplum数据系统的入口，Client连接Master提供SQL。Master管理了全局系统目录，包含了有关Greenplum数据库本身的元数据（系统表）。Master的主备基于WAL预写式日志来实现主/备镜像。</li><li>SegmentHosts：基于Postgresql 8.3的定制数据库，负责存储和处理用户数据。 一台Segment主机通常运行2至8个Greenplum的Segment。</li><li>Interconect：Interconect是Greenplum数据库架构中的网络层，默认协议UDPIFC，如果使用TCP协议，那么Greenplum限制1000个Segment。</li></ul><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><p>Greenplum支持事务控制，当并发更新时Greenplum通过MVCC模型来保证事务数据一致性。</p><p><strong>MVCC模型</strong>基于<strong>快照</strong>机制是Postgresql中的一个特性，能够管理数据行的多个版本。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>数据库ACID特性的描述：</p><ul><li><p>Atomicity：事务的操作结果要么全部执行要么全部不执行</p></li><li><p>Consistency：总是从一个一致的状态转换到另一个一致的状态</p></li><li><p>Durability：事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p></li><li><p>Isolation：事务的修改结果在什么时间能够被其他事务看到（SQL1992规范），隔离级别包括以下四个：</p><ul><li>未提交读：事务能够看到其他事务没有提交的修改，当另一个事务又回滚了修改后导致读取到脏数据，这种情况又称为 <strong>脏读</strong></li><li>已提交读：事务能够看到其他事务提交后的修改，这时会出现<strong>一个事务内两次读取数据</strong>不一致，这种模式下事务是<strong>不可重复读</strong>的。</li><li>可重复读:在两次读取时读取到的同一行数据是一致的，但是两次查询可能查到行数不一致（其他事务出现新的插入），这种情况称为<strong>幻读</strong>。</li><li>序列化级别：不允许出现幻读、脏读、不可重复读。</li></ul></li></ul><p><strong>Greenplum中未提交读、已提交读隔离模式的效果和标准SQL一致；可重复读模式避免了不可重复读和幻读；Greenplum数据库并不完全支持可串行化模式（该模式时自动退化到可重复读模式），并且数据操作并非真正串行化的。</strong></p><p>上述特性中，Isolation是关键，不同数据库实现了不同级别的隔离性，并且通常情况下使用<strong>锁</strong>来解决这些问题。<br>传统方案采用<strong>读写锁</strong>（读锁和读锁之间不互斥，写锁互斥其他所有锁），MVCC是一种完全使读写操作并发的方案（完全抛弃锁）。</p><p>用户执行事务时可以在SQL中指定，事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>MVCC的实现：</p><ul><li><p>在PostgreSQL中，每一个事务(包括单条SQL)都会得到一个被称作为 XID 的事务ID。Session请求事务操作时，PostgreSQL递增XID并赋给这个事务。</p></li><li><p>每一行记录都存储了事务相关信息，这些信息用于判断当前事务是否可见。</p><ul><li>xmin：在创建记录时，记录此时的事务id，后面每次update也会更新。</li><li>xmax：在更新或删除或lock时，记录此时的事务id；如果记录没有被删除，那么此时为0。</li><li>cmin：多语句事务存储创建这个元组的Command ID</li><li>cmax：多语句事务删除这个元组的Command ID</li></ul></li><li><p>一个事务会看到 xid &lt; xmin 的行（这些行已经commit），并且这些行 xid &gt; xmax （这些行已经被删除）。</p></li><li><p>cmin/cmax：用于多语句事务中，只在事务期间有意义，事务开始时该序列被重置为0。</p></li><li><p>每一个Segment数据库都有其自己的XID序列，Master会使用一个分布式事务ID，称为gp_session_id，Segment会会维护一个分布式事务ID到其本地XID的映射。</p></li><li><p>当一个Segment上的事务失败，会回滚所有Segment的修改。</p></li><li><p>一行支持二十亿个事务，这之后这一行将成为一个新行，通过一次VACUUM操作可以避免这样的情况。可以配置xid_warn_limit和 xid_stop_limit控制事务上限告警。</p></li></ul><p>MVCC的实现存储了多个数据版本，非常容易造成<strong>表膨胀</strong>。VACUUM命令会标记过期行所使用的空间可以被重用。通常可以使用以下策略运行VACUUM命令：</p><ul><li>重度更新的表，可能每天需要运行几次VACUUM。</li><li>运行了一个更新或者删除大量行的事务之后运行VACUUM。</li><li>VACUUM FULL命令会把表重写为没有过期行，并且将表减小到其最小尺寸，同时该操作会锁表。</li><li>运行<strong>VACUUM VERBOSE tablename</strong>来得到一份Segment上已移除的死亡行数量、受影响页面数以及有可用空闲空间页面数的报告。</li></ul><p>用户可以使用<strong>LOCK LOCK</strong>命令显示加锁（[参考]（<a href="https://gp-docs-cn.github.io/docs/ref_guide/sql_commands/LOCK.html））。" target="_blank" rel="noopener">https://gp-docs-cn.github.io/docs/ref_guide/sql_commands/LOCK.html））。</a></p><h2 id="数据冗余和故障切换"><a href="#数据冗余和故障切换" class="headerlink" title="数据冗余和故障切换"></a>数据冗余和故障切换</h2><p>部署Greenplum数据库系统时，Segment可以配置Mirror实例，当Primary节点宕机时，Mirror节点提供服务，如果系统中存在Segment没有配置Mirror，那么Segment会成为整个系统的单点故障。</p><p>Greenplum数据库中Segment镜像拓扑：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://greenplum.cn/gp6/graphics/spread-mirroring.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>用户可以选择一台不同于Master节点的主机上部署一个Master实例的备份或者镜像。 </p><p>后备Master利用事务日志复制进程保持与主Master同步，复制进程运行在后备Master上并且负责在主备Master主机之间同步数据。如果主Master失效，日志复制进程会停止，并且后备Master会被激活以替代它的位置。<strong>Master失效时，主备切换不会自动发生，需要外部激励触发。</strong></p><h1 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2. 安装部署"></a>2. 安装部署</h1><p>官方Github上提供了从源码编译gpdb和gporca的完整步骤，同时也提供了预编译好的RPM和DEB包，以下安装不步骤参考网络上的一些文档，并非官方推荐的安装步骤（我没找到！！）。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>所有节点配置NTP服务</p></li><li><p>更新以下系统配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c &apos;cat &gt;&gt; /etc/sysctl.conf &lt;&lt;-EOF</span><br><span class="line">kernel.shmmax = 500000000</span><br><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.shmall = 4000000000</span><br><span class="line">kernel.sem = 500 1024000 200 4096</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.msgmni = 2048</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line">net.ipv4.conf.all.arp_filter = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1025 65535</span><br><span class="line">net.core.netdev_max_backlog = 10000</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.core.wmem_max = 2097152</span><br><span class="line">vm.overcommit_memory = 2</span><br><span class="line"></span><br><span class="line">EOF&apos;</span><br><span class="line"></span><br><span class="line">sudo bash -c &apos;cat &gt;&gt; /etc/security/limits.conf &lt;&lt;-EOF</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br><span class="line"></span><br><span class="line">EOF&apos;</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><p>在每个节点中创建gpadmin用户用于管理Greenplum，并且打通该节点的集群免密</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 530 gpadmin</span><br><span class="line">useradd -g 530 -u 530 -m -d /home/gpadmin -s /bin/bash gpadmin</span><br><span class="line">echo "ruijie" | passwd --stdin gpadmin</span><br><span class="line"></span><br><span class="line">su - gpadmin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只需要打通第一个节点到其他节点的ssh，之后执行 gpssh-exkeys -f hostlists 打通所有节点之间的互信</span></span><br><span class="line">ssh-copy-id gpadmin@node11 &amp;&amp; ssh-copy-id gpadmin@node12 &amp;&amp; ssh-copy-id gpadmin@node13</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装Greenplum-DB"><a href="#安装Greenplum-DB" class="headerlink" title="安装Greenplum DB"></a>安装Greenplum DB</h2><p>下载RPM包，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall -y greenplum-db-6.0.0-rhel7-x86_64.rpm</span><br></pre></td></tr></table></figure><p>安装完成后，安装目录为/usr/local/greenplum-db，同时还要将greenplum-db中的lib添加到ld.so.conf中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c 'cat &gt;&gt; /etc/ld.so.conf.d/greenplum.conf &lt;&lt;-EOF</span><br><span class="line">/usr/local/greenplum-db/lib</span><br><span class="line">EOF'</span><br><span class="line"></span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p>在/home/gpadmin目录下配置环境变量、修改目录权限、创建配置目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># /usr/local/greenplum-db/greenplum_path.sh 添加以下内容</span></span></span><br><span class="line"></span><br><span class="line">source /usr/local/greenplum-db/greenplum_path.sh</span><br><span class="line">export MASTER_DATA_DIRECTORY=/data/data_ssd/greenplum/data/master/gpseg-1</span><br><span class="line">export PGPORT=5432</span><br><span class="line">export PGDATABASE=gp_sydb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改bin文件和数据目录权限：</span></span><br><span class="line">chown -R  gpadmin:gpadmin  /usr/local/greenplum-db/</span><br><span class="line">mkdir -p /data/data_ssd/greenplum # 数据目录</span><br><span class="line">chown -R gpadmin:gpadmin /data/data_ssd/greenplum</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建配置目录</span></span><br><span class="line">su - gpadmin</span><br><span class="line">mkdir -p /home/gpadmin/conf</span><br><span class="line">touch /home/gpadmin/conf/all_hosts #集群all_hosts文件,包含所有节点</span><br><span class="line">touch /home/gpadmin/conf/seg_hosts #集群seg_hosts文件,包含所有segment节点</span><br></pre></td></tr></table></figure><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>登录master的gpadmin用户，验证免密是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 验证免密是否可用</span></span><br><span class="line">gpssh-exkeys -f /home/gpadmin/conf/all_hosts </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gpssh命令提供类似ansible的公众</span></span><br><span class="line">gpssh -f /home/gpadmin/conf/all_hosts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有节点创建数据目录</span></span><br><span class="line">mkdir -p /data/data_ssd/greenplum/data/master </span><br><span class="line">mkdir -p /data/data_ssd/greenplum/data/primary</span><br><span class="line">mkdir -p /data/data_ssd/greenplum/data/mirror</span><br></pre></td></tr></table></figure><p>配置文件模板位于/usr/local/greenplum-db/docs/cli_help/gpconfigs目录中，参考gpinitsystem_config创建配置文件/home/gpadmin/conf/gpinitsystem_config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RRAY_NAME=&quot;Greenplum Data Platform&quot;</span><br><span class="line">SEG_PREFIX=gpseg</span><br><span class="line">PORT_BASE=6000</span><br><span class="line">declare -a DATA_DIRECTORY=(/data/data_ssd/greenplum/data/primary /data/data_ssd/greenplum/data/primary /data/data_ssd/greenplum/data/primary)</span><br><span class="line">MASTER_HOSTNAME=node11</span><br><span class="line">MASTER_DIRECTORY=/data/data_ssd/greenplum/data/master </span><br><span class="line">MASTER_PORT=5432</span><br><span class="line">TRUSTED_SHELL=ssh</span><br><span class="line">CHECK_POINT_SEGMENTS=8</span><br><span class="line">ENCODING=UNICODE</span><br><span class="line">DATABASE_NAME=gp_sydb</span><br><span class="line">MACHINE_LIST_FILE=/home/gpadmin/conf/seg_hosts</span><br><span class="line"></span><br><span class="line"># 需要配置冗余时</span><br><span class="line"># MIRROR_PORT_BASE=7000</span><br><span class="line"># declare -a MIRROR_DATA_DIRECTORY=(/data/data_ssd/greenplum/data/mirror /data/data_ssd/greenplum/data/mirror /data/data_ssd/greenplum/data/mirror)</span><br></pre></td></tr></table></figure><p>执行gpinitsystem -c /home/gpadmin/conf/gpinitsystem_config 初始化数据库。</p><p>如果需要使用冗余配置，则执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpinitsystem -c gpinitsystem_config  -h hostfile_exkeys -s &#123;master备份节点&#125; -S &#123;master备份目录&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>初始化完成后，master节点的 <strong>MASTER_DIRECTORY</strong> 目录下会自动生成<strong>gpseg-1</strong>目录，该目录中的文件类似pg的配置文件，包含：postgresql.conf、pg_hba.conf等内容。</p><p>初始化成功后，Greenplum会自动创建管理员用户（默认情况下为执行初始化化程序的用户）。</p><p>初次启动时，用户需要使用管理员用户登录，并创建Client使用的账号以及修改账号登录方式（pg_hba.conf）。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面的所有操作在Master节点上运行，且使用gpadmin用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">gpstart -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭，-M fast表示关闭所有事务，并且回滚</span></span><br><span class="line">gpstop -M fast</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">gpstop -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载 pg_hba.conf 和 postgresql.conf，部分参数需要通过完全重启才能生效</span></span><br><span class="line">gpstop -u</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 部分情况下，客户端进程会出现卡死，gp集群无法关闭，此时需要具有SUPERUSER权限的Greenplum用户登录postgres，杀死客户端进程。操作过程，参考：https://greenplum.cn/gp6/managing/startstop.html</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SELECT usename, pid, waiting, query, datname FROM pg_stat_activity;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的sql可以查出当前GP的活跃client，使用pg_cancel_backend(pid)、pg_terminate_backend(pid)可以强制退出这些线程。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务的状态</span></span><br><span class="line">gpstate -s</span><br></pre></td></tr></table></figure><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>Greenplum集群中包括：master参数和本地参数，这些参数存储每个实例的postgresql.conf、pg_hba.conf文件中。</p><ul><li><p>master参数：</p><ul><li>系统范围参数：编辑$MASTER_DATA_DIRECTORY/postgresql.conf文件</li><li>数据库级别参数：使用<strong>ALTER DATABASE xxx SET xxx TO xxx</strong>修改</li><li>Role级别参数：使用<strong>ALTER ROLE xxx SET xxx TO xxx;</strong>修改</li><li>会话基本参数：在会话中使用<strong>SET XXX TO XXX</strong>修改</li></ul></li><li><p>本地参数：本地参数保存在每一个postgresql.conf文件（包括：primary和mirror）中，要更新参数，可以使用 gpconfig 命令（如，<strong>gpconfig -c xxx -v xxx</strong>），也可以使用这个命令查看Seg的参数（如，<strong>gpconfig –show xxx</strong>）。</p></li></ul><p>关于参数配置说明，可以参考<a href="https://gp-docs-cn.github.io/docs/ref_guide/config_params/guc_config.html" target="_blank" rel="noopener">服务器配置参数</a>。</p><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>以下方式可以查看GP集群的日志文件：</p><ul><li>每个Master和Segment实例都在其数据目录的 pg_log中有它们自己的日志文件。</li><li>Master的日志文件包含了大部分信息，应该总是首先检查它。</li><li>gplogfilter工具可以用来检查Greenplum数据库日志文件。 如果要检查segment日志文件，使用gpssh在segment主机上执行gplogfilter工具。默认查找$MASTER_DATA_DIRECTORY 目录下的日志文件，用户也可以手工指定。</li></ul><h1 id="3-高可用"><a href="#3-高可用" class="headerlink" title="3. 高可用"></a>3. 高可用</h1><h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><ul><li>硬件级别RAID：在磁盘级别实现数据冗余</li><li>数据存储总和校验：该机制是默认开启的，数据被写入磁盘时会计算校验和，下一次读取时检查校验和，从而达到防止磁盘上数据损坏的目的（涉及的配置项包括：<strong>ignore_checksum_failure</strong>和<strong>HEAP_CHECKSUM</strong>）。</li><li>Segment镜像</li><li>Master镜像</li><li>双集群：双ETL方案、”备份/恢复”方案</li><li>备份和恢复：gpbackup/gprestore工具备份/恢复Greenplum数据库，<a href="https://greenplum.cn/gp6/managing/backup-gpbackup.html" target="_blank" rel="noopener">参考</a></li></ul><h3 id="配置Segment镜像"><a href="#配置Segment镜像" class="headerlink" title="配置Segment镜像"></a>配置Segment镜像</h3><p>默认情况下，在GP集群运行时执行gpaddmirrors -p 10000，就能在本集群内创建Segment镜像，执行期间会提示输入mirror数据的存储位置。10000表示mirror服务的端口号在原primary基础上加上10000。</p><p>上述命令，以group方式创建mirror，如果用户需要mirror分散部分或者分布在另外的HOST上，那么需要定义文件指定mirror到primary的映射（<a href="https://gp-docs-cn.github.io/docs/admin_guide/highavail/topics/g-enabling-segment-mirroring.html" target="_blank" rel="noopener">参考</a>）。</p><p><strong>gp_segment_configuration</strong>表记录了所有primary和mirror的状态，以及连接信息，这张表常用用于判断mirror的状态。这张表中mode字段描述了Seg的三种状态：</p><ul><li>Change Tracking Mode ：没有找到mirror实例</li><li>resync：重新同步</li><li>in-sync：同步完成</li></ul><p>当mirror因为一些原因同步失败时，可以使用 <strong>gprecoverseg</strong> 进行一次增量同步，或者使用 <strong>gprecoverseg -F</strong> 进行全量同步。</p><p><strong>gp_segment_configuration</strong>表的role和preferred_role表示 Segment 表示当前的状态，以及偏好状态。当它们不匹配时，就可能有每台硬件主机上活动主Segment数量造成的倾斜。为了重新平衡该集群并且让所有的Segment回到它们的首选角色，可以用-r选项运行gprecoverseg命令。</p><p>当Segment故障时，有以下恢复手段：</p><ul><li>在Master节点执行<strong>gprecoverseg</strong>，将下线Segment重新上线。gprecoverseg会恢复数据文件，此时数据库的写活动被禁止。</li><li>当所有Segment状态为<strong>Synchronized</strong>时，可以运行<strong>gprecoverseg -r</strong>使Segment回到它们的首选角色。</li><li><strong>gprecoverseg -F</strong>是全量恢复手段：从活动segment实例（当前主实例）复制数据前， 删除离线segment实例的数据目录。</li><li><strong>gprecoverseg -i recover_config_file</strong>将失效Segment恢复到其他主机，<a href="https://greenplum.cn/gp6/highavail/topics/g-when-a-segment-host-is-not-recoverable.html" target="_blank" rel="noopener">参考</a></li></ul><h3 id="配置Master镜像"><a href="#配置Master镜像" class="headerlink" title="配置Master镜像"></a>配置Master镜像</h3><p>当GP集群正在运行时，通过<strong>gpinitstandby -s {standby_host}</strong>能够快速启动一个Master的镜像。</p><p>通过<strong>gpstate -f</strong>，可以检查Master Mirror的运行状态，正常情况下：standby master的状态应该是passive，WAL sender状态应该是streaming。</p><p><strong>需要注意：StandbyMaster不能提供任何服务！</strong></p><p>主master故障时，需要手工执行<strong>gpactivatestandby</strong>（如，gpactivatestandby -d /data/master/gpseg-1）来激活后备Master。激活Master主机后，可以执行<strong>psql dbname -c ‘ANALYZE;’</strong>。</p><p>关于Master恢复的一些问题：</p><ul><li><p>激活后备Master后，官方建议一直将该Master作为主Master使用，并且初始化一个新的后备Master</p></li><li><p>要恢复原来的主Master遵循下面的步骤（下面将原Master主机成为MHost，当前Master主机称为SMHost）：</p><ul><li>备份 MHost 上的gpseg-1</li><li>在 SMHost 上运行：gpinitstandby -s MHost</li><li>检查 MHost 上后备Master的状态：gpstate -f（standby master 状态应该是passive，WAL sender状态应该是streaming）</li><li>停止 SMHost 上的Master：gpstop -m （即把当前的主master停掉）</li><li>在MHost上运行：gpactivatestandby -d $MASTER_DATA_DIRECTORY（即将当前备升级为主Master）</li><li>移除 SMHost 上的gpinitstandby，并在MHost上执行：gpinitstandby -s SMHOST</li></ul></li></ul><h1 id="4-数据备份和恢复"><a href="#4-数据备份和恢复" class="headerlink" title="4. 数据备份和恢复"></a>4. 数据备份和恢复</h1><p>数据备份和恢复有以下两种方式：</p><ul><li>并行：每台Segment主机都同时把其数据写入到本地的磁盘存储上</li><li>非并行：数据必须通过网络从Segment被发送到Master，后者把所有的数据写入它的存储中。 </li></ul><p>推荐使用并行方式，非并行方式时间上是将GP集群当做一个pg来执行任务。</p><h2 id="gpbackup和gprestore"><a href="#gpbackup和gprestore" class="headerlink" title="gpbackup和gprestore"></a>gpbackup和gprestore</h2><p>gpbackup和gprestore在github上是一个<a href="https://github.com/greenplum-db/gpbackup/releases" target="_blank" rel="noopener">独立项目</a>，不属于gpdb工程，其release是两个可执行文件，下载后放到gpadmin用户目录下就可以使用。</p><p>gpbackup 和 gprestore 支持以下功能：</p><ul><li>并行备份恢复</li><li>全量备份、增量备份</li><li>备份整个数据库，或者 数据库特定scheme和表</li><li>gpbackup将元数据和数据分开成不同文件可读文件，这些文件放在各个节点上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基本备份操作</span></span><br><span class="line">./gpbackup --dbname  benchtest --backup-dir /home/gpadmin/backups</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基本恢复操作</span></span><br><span class="line">./gprestore  --backup-dir /home/gpadmin/backups/ --timestamp 20191010111727 --create-db --jobs 8</span><br></pre></td></tr></table></figure><p>其他关于GP集群备份的内容：</p><ul><li><a href="https://greenplum.cn/gp6/managing/backup-gpbackup-incremental.html" target="_blank" rel="noopener">增量备份</a></li><li><a href="https://greenplum.cn/gp6/managing/backup-boostfs.html" target="_blank" rel="noopener">在特定存储设备上备份</a></li><li><a href="https://greenplum.cn/gp6/managing/backup-plugin-api.html" target="_blank" rel="noopener">自定义存储插件</a></li></ul><h1 id="5-扩容"><a href="#5-扩容" class="headerlink" title="5. 扩容"></a>5. 扩容</h1><p>对GP集群进行扩容需要注意的几点：</p><ul><li><p>当Segment使用Mirror时，一次扩容最少需要两台机器（如果不使用Mirror则没有这种要求）；</p></li><li><p>括容之后Segment需要对表进行重平衡：</p><ul><li>重平操作是一次数据重写，会极大消耗磁盘IO，以及占用磁盘空间</li><li><strong>表在重平衡期间不可用</strong></li><li>用户可以控制表的重平衡顺序</li><li>重平衡不影响新创建的表</li></ul></li><li><p>扩容之前的数据备份文件不可用，需要重新备份</p></li></ul><p>扩容步骤：</p><ul><li><p>准备节点：</p><ul><li>配置系统变量，必要时候进行性能测试</li><li>安装Greenplum软件</li><li>创建gpadmin用户</li><li>配置SSH免密</li></ul></li><li><p>初始化新节点：这个步骤将新的节点添加到GP集群中</p><ul><li>创建扩容文件，这个文件可以手工编辑，也可以通过 <strong>gpexpand</strong> 命令生成（如何生成该文件<a href="https://greenplum.cn/gp6/expand/expand-initialize.html" target="_blank" rel="noopener">参考</a>）。</li><li>运行<strong>gpexpand -i input_file</strong>，将扩容实例上线，如果上述过程失败可以执行<strong>gpexpand –rollback</strong>回滚。</li></ul></li><li><p>重分布表：此步骤一旦开始，那么需要重平衡的表变得不再可读写</p><ul><li>执行<strong>gpexpand -d 60:00:00</strong>可以开始表扩容操作，-d表示重分布的最大时间限制</li><li>进行重分布时，通过gpexpand.status、gpexpand.expansion_progress、gpexpand.status_detail表可以查看重分布表的状态，调整gpexpand.status_detail的rank值还可以控制重分布表的顺序。</li></ul></li><li><p>移除扩容操作</p><ul><li>gpexpand -c</li></ul></li></ul><h1 id="6-数据对象"><a href="#6-数据对象" class="headerlink" title="6.数据对象"></a>6.数据对象</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Greenplum中数据库有<strong>模板</strong>的概念，用户可以从模板创建数据库，新的数据库会拥有模板的所有表和数据。</p><ul><li>默认模板包括：template1所有新建库的默认模板、template0系统数据库（如postgres）的模板</li><li>从模板克隆数据库：<strong>CREATE DATABASE new_dbname TEMPLATE old_dbname;</strong></li><li>本质上模板和数据库等价，任何数据库都能当做模板</li><li>查看当前数据库：<strong>\l</strong>、<strong>查看pg_database表</strong></li></ul><h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>表空间用于<strong>将数据库中的对象(如表、索引等)到不同的存储介质上</strong>，不同表空间的区别在于<strong>存储介质不同</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个表空间，其存放目录要事先创建，并且所有Seg都能访问</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> fastspace LOCATION <span class="string">'/fastdisk/gpdb'</span>;</span><br><span class="line"><span class="comment">-- 为Role赋权，使他能够在表空间上创建对象</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">ON</span> <span class="keyword">TABLESPACE</span> fastspace <span class="keyword">TO</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="comment">-- 创建表时指定表空间</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> foo(i <span class="built_in">int</span>) <span class="keyword">TABLESPACE</span> fastspace;</span><br><span class="line"><span class="comment">-- 指定默认表空间</span></span><br><span class="line"><span class="keyword">SET</span> default_tablespace = fastspace;</span><br></pre></td></tr></table></figure><p>查询<strong>pg_tablespace</strong>可以得到当前环境的所有表空间，Greenplum创建之后包含默认表空间：</p><ul><li>pg_default ：默认表空间。由template1和template0数据库使用，存储位置为$PADATA/base/。</li><li>pg_global  ：用于共享系统的catalogs，存储位置为$PADATA/global/。</li></ul><p>Greenplum中的表空间和PG是一致的，可以参考这个<a href="https://www.cnblogs.com/lottu/p/9239535.html" target="_blank" rel="noopener">文章</a>。</p><h2 id="SCHEMA"><a href="#SCHEMA" class="headerlink" title="SCHEMA"></a>SCHEMA</h2><p>Schema从<strong>逻辑上组织一个数据库中的对象和数据</strong>。 Schema<strong>允许用户在同一个数据库中拥有多于一个对象（例如表）具有相同的名称而不发生冲突</strong>，只要把它们放在不同的Schema中就好，<strong>Public</strong>是默认SCHEMA。</p><p>用户可以设置search_path配置参数来指定在其中搜索对象的可用schema的顺序。 在该搜索路径中第一个列出的方案会成为默认schema。 如果没有指定方案，对象会被创建在默认schema中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 指定查找特定schema下的表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myschema.mytable;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设定数据库的搜索顺序</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> mydatabase <span class="keyword">SET</span> search_path <span class="keyword">TO</span> myschema, </span><br><span class="line"><span class="keyword">public</span>, pg_catalog;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看搜索路径、以及schema</span></span><br><span class="line"><span class="keyword">SHOW</span> search_path;</span><br><span class="line"><span class="keyword">SELECT</span> current_schema();</span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="表分布策略"><a href="#表分布策略" class="headerlink" title="表分布策略"></a>表分布策略</h3><p>支持三种分布策略：</p><ul><li>DISTRIBUTED BY（哈希分布）</li><li>DISTRIBUTED RANDOMLY（随机分布）</li><li>DISTRIBUTED REPLICATED（全分布）</li></ul><p>关于分布策略有以下几点需要注意：</p><ul><li><p>不显示指定分布策略时，表如何分布取决于<a href="https://gp-docs-cn.github.io/docs/ref_guide/config_params/guc-list.html#gp_create_table_random_default_distribution" target="_blank" rel="noopener">gp_create_table_random_default_distribution</a></p></li><li><p>使用随机分布时，不能在表中指定PRIMARY KEY 或者 UNIQUE 列</p></li><li><p>对于DISTRIBUTED BY可以自定义操作符</p></li></ul><h3 id="表存储模型"><a href="#表存储模型" class="headerlink" title="表存储模型"></a>表存储模型</h3><ul><li><p>堆存储：</p><ul><li>默认配置，模型和PostgreSQL相同</li><li>堆表存储在OLTP类型负载下表现最好，适合频繁修改的的小表</li><li>行级存储方式</li></ul></li><li><p>追加优化存储：指定appendoptimized=true</p><ul><li>成批地被载入并且被只读查询访问的事实表；</li><li>不推荐单行的INSERT语句</li><li>更新表时有功能限制（如事务中不支持UPDATE和DELETE等）</li></ul></li><li><p>选择面向行或者面向列的存储：列表(appendoptimized=true, orientation=column)</p><ul><li>支持行，列或两者的组合</li><li>面向列的表存储只能用于追加优化表</li><li>频繁的插入时，行表优于列表</li></ul></li><li><p>压缩表： 指定(appendoptimized=true, compresstype=zlib, compresslevel=5);</p><ul><li>只适用于追加优化表</li><li>可以进行整个表的压缩、或者指定列的压缩</li></ul></li></ul><p>参考介绍：<a href="https://greenplum.cn/gp6/ddl/ddl-storage.html" target="_blank" rel="noopener">选择表存储模型</a></p><h2 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h2><ul><li>序列：Greenplum数据库序列对象是一个特殊的单行表，用作数字生成器。 <a href="https://greenplum.cn/gp6/ddl/ddl-sequence.html" target="_blank" rel="noopener">参考</a></li><li>索引：<a href="https://greenplum.cn/gp6/ddl/ddl-index.html" target="_blank" rel="noopener">参考</a></li><li>视图:<a href="https://greenplum.cn/gp6/ddl/ddl-view.html" target="_blank" rel="noopener">参考</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://greenplum.cn/" target="_blank" rel="noopener">GreenPlum中文社区</a></p><p><a href="http://mysql.taobao.org/monthly/2017/10/01/" target="_blank" rel="noopener">PGSQL MVCC机制</a></p><p><a href="https://greenplum.cn/gp6/intro/about_statistics.html" target="_blank" rel="noopener">Greenplum 表统计信息</a></p><p><a href="https://greenplum.cn/gp6/access_db/topics/pgbouncer.html" target="_blank" rel="noopener">PgBouncer客户端配置</a></p><p><a href="https://gp-docs-cn.github.io/docs/ref_guide/ref_guide.html" target="_blank" rel="noopener">Greenplum数据库参考指南</a></p><p><a href="https://gpdb.docs.pivotal.io/6-0/ref_guide/system_catalogs/gp_segment_configuration.html" target="_blank" rel="noopener">Greenplum系统表表结构</a></p><p><a href="https://greenplum.cn/gp6/managing/backup-gpbackup.html" target="_blank" rel="noopener">gprestore和gpbackup介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- Sysbench</title>
    <link href="https://LinQing2017.github.io/2019/09/29/sysbench/"/>
    <id>https://LinQing2017.github.io/2019/09/29/sysbench/</id>
    <published>2019-09-29T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>Sysbench 性能测试工具</p><a id="more"></a><h1 id="Sysbench"><a href="#Sysbench" class="headerlink" title="Sysbench"></a>Sysbench</h1><p>Sysbench是基于LuaJIT的可编写脚本的多线程基准测试工具，提供系统软硬件层面的性能基准测试，包括;</p><ul><li>数据库基准测试</li><li>文件系统基准测试</li><li>CPU性能基准测试</li><li>内存性能基准测试</li><li>线程调度基准测试</li><li>POSIX信号量基准测试</li></ul><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash</span><br><span class="line">sudo yum -y install sysbench</span><br></pre></td></tr></table></figure><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><h2 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h2><p>测试命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sysbench oltp_insert.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=10000000 --db-driver=pgsql --tables=20 prepare</span><br><span class="line"></span><br><span class="line">sysbench oltp_insert.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=6000000 --db-driver=pgsql --tables=20 run</span><br><span class="line"></span><br><span class="line">sysbench oltp_read_only.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=6000000 --db-driver=pgsql --tables=20 run</span><br><span class="line"></span><br><span class="line">sysbench oltp_read_write.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=100000 --db-driver=pgsql --tables=20 run</span><br><span class="line"></span><br><span class="line">sysbench oltp_insert.lua --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20  --db-driver=pgsql --tables=20 cleanup</span><br></pre></td></tr></table></figure><p>硬件配置： 128GB + 32CPU + SSD + 万兆网络</p><p>pg配置： shared_buffers = 32GB（huge_pages = on ），其他默认</p><p>测试条件：</p><pre><code>- 预写20张表，每张1000w记录</code></pre><table><thead><tr><th>Case</th><th>insert</th><th>read</th><th>混合</th><th>配置</th></tr></thead><tbody><tr><td>1</td><td>20线程：24885</br>32线程：36893</br>64线程：58137</br>96线程：66747</td><td>20线程：105781</br>96线程：230311</td><td>20线程：54485</br>96线程：58404</td><td>单机PG</td></tr><tr><td>2</td><td>20线程：7249</br>32线程：8752</br>64线程：9991</br>96线程：10545</td><td>20线程：35531</br>96线程：72351</td><td>略：</td><td>2PG+pgpool</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/akopytov/sysbench" target="_blank" rel="noopener">官方GitHub</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sysbench 性能测试工具&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Sysbench - 数据库" scheme="https://LinQing2017.github.io/tags/Sysbench-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- PostgreSQL</title>
    <link href="https://LinQing2017.github.io/2019/09/23/Postgresql-%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D/"/>
    <id>https://LinQing2017.github.io/2019/09/23/Postgresql-安装介绍/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 调研笔记</p><a id="more"></a><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick-Start"></a>Quick-Start</h1><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line">yum -y install postgresql11 postgresql11-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装完成后，安装目录为/usr/pgsql-11，postgresql-11-setup脚本用来进行环境初始化和升级操作。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要注意的是：安装完RPM包后，如果想要修改默认的数据目录（/var/lib/pgsql/11/data），需要修改/usr/lib/systemd/system/postgresql-11.service中的环境变量PGDATA，并执行systemctl daemon-reload。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> postgresql-11-setup会创建postgres和postgres，并且设定用户的home目录为/var/lib/pgsql</span></span><br><span class="line"></span><br><span class="line">/usr/pgsql-11/bin/postgresql-11-setup initdb</span><br><span class="line">systemctl enable postgresql-11</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 pg_hba.conf文件，放开用户远程登录权限，注意同时要放开listen_addresses配置为*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> host    all             root            all                     md5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> host    all             postgres        172.24.9.1/24           md5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">systemctl start postgresql-11</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改postgres用户登录密码，创建root用户</span></span><br><span class="line">sudo -u postgres psql -d postgres -c "ALTER USER postgres WITH PASSWORD 'rjbigdata_admin';"</span><br><span class="line">sudo -u postgres psql -d postgres -c "CREATE ROLE root LOGIN REPLICATION CREATEDB PASSWORD 'rjbigdata'"</span><br></pre></td></tr></table></figure><p>关于系统配置的最佳实践：</p><ul><li><p>建议将硬盘挂载点的Owner设置为PostgreSQL用户，数据目录直接放置在该目录之下（有利于避免升级、clean时的权限问题）。</p></li><li><p>使用NAS文件系统时可以会导致数据损坏（官方建议 synchronously 方式挂载，并且关闭caching），参考<a href="https://www.postgresql.org/docs/11/creating-cluster.html" target="_blank" rel="noopener">NFS的可能的问题</a>。</p></li><li><p>关于型号量和共享内存的配置（<a href="http://www.postgres.cn/docs/10/kernel-resources.html" target="_blank" rel="noopener">参考</a>）,Linux涉及到的配置需要关注的有kernel.shmmax（最大段尺寸）和kernel.shmall（最大共享内存页面）</p></li><li><p>使用systemd必须注意IPC资源（共享内存和信号量） 不会被操作系统过早删除，默认情况下要避免这种情况需要将启动pg的用户设定为系统用户（id小于1000）以及修改/etc/systemd/logind.conf 中RemoveIPC=no。（参考<a href="https://www.postgresql.org/docs/11/kernel-resources.html" target="_blank" rel="noopener">18.4.2. systemd RemoveIPC</a>）</p></li><li><p>资源限制：maxproc、openfiles、datasize</p></li><li><p>防止PG在内存过渡调拨时Killer</p><ul><li>设定systemd文件中的PG_OOM_ADJUST_VALUE=-1000，这样保证子进程不被Killer ；</li><li>设定systemd文件中的PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj 的值为-1000（echo -1000 &gt; /proc/self/oom_score_adj），保证postmaster不被kill</li><li>降低PG内存相关配置，如shared_buffers 和work_mem）</li></ul></li><li><p>shared_buffers配置较大时，可以开启大页配置。评估页面数vm.nr_hugepages，可以参考 postmaster VmPeak / Hugepagesize </p></li><li><p>关闭数据库时，发送不同的信号量，PG关闭的方式不同（kill -INT <code>head -1 /usr/local/pgsql/data/postmaster.pid</code>），<strong>不要用-9关闭PG，危！！</strong></p><ul><li>SIGTERM：智能关闭模式，不在接收新连接、会让现有的会话正常结束它们的工作。仅当所有的会话终止后它才关闭。 </li><li>SIGINT：服务器不再允许新的连接，并向所有现有服务器进程发送SIGTERM，让它们中断当前事务并立刻退出。然后服务器等待所有服务器进程退出并最终关闭。 如果服务处于在线备份模式，备份模式将被终止并致使备份无用。</li><li>SIGQUIT：服务器将给所有子进程发送 SIGQUIT并且等待它们终止。如果有任何进程没有在 5 秒内终止，它们将被发送 SIGKILL。主服务器进程将在所有子进程退出之后立刻退出，而无需做普通的数据库关闭处理。这将导致在下一次启动时（通过重放 WAL 日志）恢复。</li></ul></li></ul><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><ul><li>PostgreSQL 基于 roles 对数据库用户进行权限管理。</li><li>根据roles的创建方式不同，可以指特定用户或者某一组用户，即包含user和groups两个概念）。</li><li>Roles 基于可以和数据库的Objects绑定，或者将名下objects的权限赋予其他roles。</li><li>Roles 与操作系统的用户是完全分开的，不会相互影响。</li><li>系统预创建的超级用户为 postgres ，可以 su - postgres 切换到该用户后登录pg。</li><li>用户也可以在执行psql命令时，使用-U指定登录的用户。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="keyword">name</span>;<span class="comment">-- 创建ROLE，等价于使用createuser name</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">ROLE</span> <span class="keyword">name</span>;<span class="comment">-- 删除ROLE，等价于使用dropuser  name</span></span><br><span class="line"><span class="keyword">SELECT</span> rolname <span class="keyword">FROM</span> pg_roles; <span class="comment">-- 查询已有roles</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="keyword">name</span>;<span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLE</span> XXX <span class="comment">-- 修改用户权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> root LOGIN <span class="keyword">REPLICATION</span> CREATEDB CREATEEXTTABLE <span class="keyword">PASSWORD</span> <span class="string">'rjbigdata'</span>    <span class="comment">-- 创建一个roles，并赋予各种权限</span></span><br><span class="line"><span class="keyword">GRANT</span> group_role <span class="keyword">TO</span> role1, ... ;<span class="comment">-- role赋权</span></span><br><span class="line"><span class="keyword">REVOKE</span> group_role <span class="keyword">FROM</span> role1, ... ;<span class="comment">-- role回收权限</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">ROLE</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="comment">-- 关于Roles权限继承的实例，其中joe被设计成user，admin、wheel被设计成Role Group：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> joe LOGIN INHERIT;<span class="comment">-- joe可以重其他roles中继承权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="keyword">admin</span> NOINHERIT;<span class="comment">-- 不允许从其他roles中继承权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> wheel NOINHERIT;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">admin</span> <span class="keyword">TO</span> joe;</span><br><span class="line"><span class="keyword">GRANT</span> wheel <span class="keyword">TO</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">ROLE</span> <span class="keyword">admin</span> / <span class="keyword">SET</span> <span class="keyword">ROLE</span> wheel; <span class="comment">-- 获取admin和wheel的权限</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">ROLE</span> joe / <span class="keyword">SET</span> <span class="keyword">ROLE</span> <span class="keyword">NONE</span> / <span class="keyword">RESET</span> <span class="keyword">ROLE</span>;  <span class="comment">-- 恢复权限</span></span><br></pre></td></tr></table></figure><h3 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h3><p>PostgreSQL中的权限（pg_roles中有roles的权限明细）：</p><ul><li>login privilege：roles有该权限时，可以作为一个普通用户登录</li><li>superuser status：除了login privilege以外所有权限</li><li>database creation</li><li>role creation</li><li>initiating replication：流复制的角色权限？？ 用来副本同步？</li><li>password</li><li>INHERIT：具有INHERIT属性的成员角色会自动使用其所属成员角色的特权，通常用来在pg中区别roles和users</li></ul><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><p>删除账号时有以下注意点：</p><ul><li>需要将roles名下所有objects收回（ALTER TABLE bobs_table OWNER TO alice;）</li><li>REASSIGN OWNED 可以将一个role名下所有object转义给另一个object</li><li>DROP OWNED 删除role名下所有的object</li></ul><h3 id="默认Roles"><a href="#默认Roles" class="headerlink" title="默认Roles"></a>默认Roles</h3><p>PG提供的一些默认Role，<a href="https://www.postgresql.org/docs/11/default-roles.html" target="_blank" rel="noopener">参考</a>，这些Role名下关联了许多系统表。</p><h2 id="Client-认证"><a href="#Client-认证" class="headerlink" title="Client 认证"></a>Client 认证</h2><ul><li>用户认证相关的配置文件为：pg_hba.conf，如何配置可以<a href="https://www.postgresql.org/docs/11/auth-pg-hba-conf.html" target="_blank" rel="noopener">参考</a></li><li>PG支持password、ldap、gss等方式的认证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 配置pg允许远程连接，pg_hba.conf中追加下面一行</span><br><span class="line">host    all             root            all                     md5</span><br></pre></td></tr></table></figure><h2 id="SQL-Language"><a href="#SQL-Language" class="headerlink" title="SQL Language"></a>SQL Language</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 建表,支持的类型包括：int，smallint，实数，双精度，char（N），varchar（N），date, time, timestamp, interval，以及自定义类型</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> weather (</span><br><span class="line">    city            <span class="built_in">varchar</span>(<span class="number">80</span>),</span><br><span class="line">    temp_lo         <span class="built_in">int</span>,           <span class="comment">-- low temperature</span></span><br><span class="line">    temp_hi         <span class="built_in">int</span>,           <span class="comment">-- high temperature</span></span><br><span class="line">    prcp            <span class="built_in">real</span>,          <span class="comment">-- precipitation</span></span><br><span class="line">    <span class="built_in">date</span>            <span class="built_in">date</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> weather <span class="keyword">VALUES</span> (<span class="string">'San Francisco'</span>, <span class="number">46</span>, <span class="number">50</span>, <span class="number">0.25</span>, <span class="string">'1994-11-27'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> weather (<span class="built_in">date</span>, city, temp_hi, temp_lo) <span class="keyword">VALUES</span> (<span class="string">'1994-11-29'</span>, <span class="string">'Hayward'</span>, <span class="number">54</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 文件批量导入，后端进程直接导入</span></span><br><span class="line">COPY weather FROM '/home/user/weather.txt';</span><br></pre></td></tr></table></figure><h2 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h2><ul><li><p>postgresql.conf文件可以通过pg_ctl reload命令，或者 pg_reload_conf() 函数重载（部分配置可能要重启生效）</p><ul><li>postgresql.conf文件可以包含 include ‘filename’ 配置、include_dir ‘directory’配置</li><li></li></ul></li><li><p>postgresql.auto.conf不应该手工编辑，这个文件保存了通过ALTER SYSTEM命令提供的设置，并且会覆盖postgresql.conf中的配置</p></li><li><p>通过SQL进行配置：ALTER SYSTEM（全局配置，等效于配置文件）、ALTER DATABASE、ALTER ROLE</p></li><li><p>show/set 命令可以查看当前会话的配置，以及针对会话更新配置。</p></li><li><p>服务端启动时可以使用-c 指定配置，这些配置覆盖ALTER SYSTEM和配置文件配置</p></li><li><p>启动Client时可以使用环境变量指定，如（env PGOPTIONS=”-c geqo=off -c statement_timeout=5min” psql）</p></li></ul><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><ul><li><p>文件位置：<a href="http://www.postgres.cn/docs/10/runtime-config-file-locations.html" target="_blank" rel="noopener">参考</a></p></li><li><p>连接和认证：<a href="http://www.postgres.cn/docs/10/runtime-config-connection.html" target="_blank" rel="noopener">参考</a></p><ul><li>max_connections：最大连接数配置，默认是100，实际user的最大连接数为max_connections - superuser_reserved_connections </li></ul></li><li><p>资源消耗：<a href="http://www.postgres.cn/docs/10/runtime-config-resource.html" target="_blank" rel="noopener">参考</a></p><ul><li>内存配置：<ul><li>shared_buffers : 一个合理的shared_buffers开始值是系统内存的 25%。默认是128mb</li><li>work_mem ：内部排序操作和哈希表使用的内存量，默认4mb。一个查询可能有好几个排序或者hash操作，每个操作会使用work_mem大小的内存。</li><li>maintenance_work_mem ：维护性操作（例如VACUUM、CREATE INDEX和ALTER TABLE ADD FOREIGN KEY）中使用的 最大的内存量，默认64mb。</li><li>autovacuum_work_mem : 指定每个自动清理工作者进程能使用的最大内存量。</li><li>temp_buffers ：每个数据库会话使用的临时缓冲区的最大数目，是会话的本地缓冲区，只用于访问临时表，默认是 8 兆字节（8MB）。</li></ul></li><li>工作线程配置：max_worker_processes 、 max_parallel_workers 、max_parallel_workers_per_gather （<a href="http://www.postgres.cn/docs/10/runtime-config-resource.html" target="_blank" rel="noopener">并行查询参考</a>）</li><li>强制刷盘配置：backend_flush_after（默认不强制刷盘）</li></ul></li><li><p>日志相关配置，<a href="http://www.postgres.cn/docs/10/runtime-config-wal.html" target="_blank" rel="noopener">参考</a></p></li><li><p>流复制配置,<a href="http://www.postgres.cn/docs/10/runtime-config-replication.html" target="_blank" rel="noopener">参考</a></p></li><li><p>其他配置，<a href="http://www.postgres.cn/docs/10/runtime-config.html" target="_blank" rel="noopener">参考</a></p></li></ul><h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><p>各种方案<a href="http://www.postgres.cn/docs/10/different-replication-solutions.html#HIGH-AVAILABILITY-MATRIX" target="_blank" rel="noopener">一览表</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.postgresql.org/download/" target="_blank" rel="noopener">安装部署</a></p><p><a href="https://www.pgpool.net/mediawiki/index.php/Main_Page" target="_blank" rel="noopener">Pgpool-II</a></p><p><a href="https://www.postgresql.org/docs/11/biblio.html" target="_blank" rel="noopener">官方参考资料 &amp; 论文集</a></p><p><a href="https://www.postgresql.org/docs/11/charset.html" target="_blank" rel="noopener">PG的编码集配置</a></p><p><a href="http://www.postgres.cn/docs/10/" target="_blank" rel="noopener">PostgreSQL 10.1 手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PostgreSQL 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="https://LinQing2017.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 学习笔记</title>
    <link href="https://LinQing2017.github.io/2019/09/03/0-OpenCV-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://LinQing2017.github.io/2019/09/03/0-OpenCV-学习/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.972Z</updated>
    
    <content type="html"><![CDATA[<p>关于<a href="https://docs.opencv.org/4.1.1/d6/d00/tutorial_py_root.html" target="_blank" rel="noopener">OpenCV-Python Tutorials</a>、ROS By Example的学习笔记</p><a id="more"></a><h1 id="ROS和OpenCV"><a href="#ROS和OpenCV" class="headerlink" title="ROS和OpenCV"></a>ROS和OpenCV</h1><p>在ROS中使用OpenCV进行图像处理是开发ROS程序的常见需要，以下是在Ros中使用OpenCV开发的一些随笔。</p><h2 id="摄像头的驱动"><a href="#摄像头的驱动" class="headerlink" title="摄像头的驱动"></a>摄像头的驱动</h2><p>ROS中使用摄像机包括下面的情景：</p><h3 id="1-Kinect"><a href="#1-Kinect" class="headerlink" title="1.Kinect"></a>1.Kinect</h3><p>在ROS上安装Kinect驱动有以下几种方案：</p><ul><li><p>freenect_stack：底层基于libfreenect，需要额外安装<a href="https://github.com/OpenKinect/libfreenect" target="_blank" rel="noopener">libfreenect</a>或者<a href="https://github.com/OpenKinect/libfreenect2" target="_blank" rel="noopener">libfreenect2</a></p></li><li><p>openni_camera：同样基于openni需要分别安装依赖OpenNI和SensorKinect，安装过程可以参考<a href="https://www.20papercups.net/programming/kinect-on-ubuntu-with-openni/" target="_blank" rel="noopener">博客</a></p></li><li><p>openni_kinect：基于openni是PrimeSense官方负责维护项目，包含：openni_camera、openni_launch、openni_tracker等多个模块。<strong>但是PrimeSense被收购之后，该项目的源码已经无法访问。</strong></p></li><li><p>kinect_aux: Kinect上accelerometer/tilt/led相关功能的独立驱动。</p></li></ul><h3 id="2-IntelRealSense-Xtion"><a href="#2-IntelRealSense-Xtion" class="headerlink" title="2. IntelRealSense/Xtion"></a>2. IntelRealSense/Xtion</h3><p>IntelRealSense官方提供了ROS上的相关驱动，官方<a href="https://github.com/IntelRealSense/realsense-ros" target="_blank" rel="noopener">github</a>。</p><p>Xtion使用<a href="http://wiki.ros.org/openni2_camera" target="_blank" rel="noopener">openni2_camera</a>驱动，使用相机是可以参考<a href="http://docs.ros.org/api/openni2_launch/html/" target="_blank" rel="noopener">openni2_launch</a>。</p><h3 id="3-webcam"><a href="#3-webcam" class="headerlink" title="3. webcam"></a>3. webcam</h3><p> webcam是指通过USB接入的“即插即用”相机，此类相机没有专门的驱动程序，通过系统工具工作。</p><ul><li><a href="http://wiki.ros.org/libuvc_camera" target="_blank" rel="noopener">libuvc_camera</a></li><li><a href="https://wiki.ros.org/usb_cam" target="_blank" rel="noopener">usb_cam</a></li><li><a href="http://wiki.ros.org/gscam" target="_blank" rel="noopener">gscam</a></li></ul><h2 id="ROS处理图像"><a href="#ROS处理图像" class="headerlink" title="ROS处理图像"></a>ROS处理图像</h2><p>ROS中相机信息通过Topic进行发布，其中关键Topic包括：</p><ul><li>image_raw：摄像头拍摄的原始数据，格式为<a href="http://docs.ros.org/api/sensor_msgs/html/msg/Image.html" target="_blank" rel="noopener"><strong>sensor_msgs/Image.msg</strong></a></li><li>camera_info：摄像头元数据信息，包括内参矩阵、对准系数等等，通常这个Topic中数据需要用户进行对准之后，进行人为设定。</li></ul><p>ROS图像处理方面涉及到下面这些工具：</p><h3 id="1-cv-bridge"><a href="#1-cv-bridge" class="headerlink" title="1. cv_bridge"></a>1. <strong>cv_bridge</strong></h3><p><a href="http://wiki.ros.org/cv_bridge/Tutorials" target="_blank" rel="noopener">cv_bridge</a>用来在sensor_msgs/Image和numpy两种格式之间进行转换，使OpenCV能够处理Topic中的图像数据。</p><p>目前cv_bridge提供C++/Python/JAVA 的接口。</p><h3 id="2-image-transport"><a href="#2-image-transport" class="headerlink" title="2. image_transport"></a>2. <strong>image_transport</strong></h3><p>image_transport 可以将Image数据重新转发到新的topic中，其输入可以是Topic、图片、视频。</p><h3 id="3-image-pipeline"><a href="#3-image-pipeline" class="headerlink" title="3. image_pipeline"></a>3. <strong>image_pipeline</strong></h3><p><a href="http://wiki.ros.org/image_pipeline" target="_blank" rel="noopener">image_pipeline</a>是ROS的图像处理工具包，包括以下几个部分：</p><ul><li><a href="http://wiki.ros.org/camera_calibration" target="_blank" rel="noopener">camera_calibration</a>：摄像头标定包</li><li><a href="http://wiki.ros.org/image_proc" target="_blank" rel="noopener">image_proc</a>：图像校正包</li><li><a href="http://wiki.ros.org/stereo_image_proc" target="_blank" rel="noopener">stereo_image_proc</a>：处理双目相机</li><li><a href="http://wiki.ros.org/depth_image_proc" target="_blank" rel="noopener">depth_image_proc</a>：处理深度相机</li><li>image_view、stereo_view：可视化</li></ul><p>简单介绍一下image_pipeline的各个组件：</p><p><strong>image_proc</strong></p><p>image_proc主要用来处理rgb图片，提供node、nodelet两种运行方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node方式运行</span></span><br><span class="line">ROS_NAMESPACE=my_camera rosrun image_proc image_proc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上述node会寻找/my_camera/image_raw和/my_camera/camera_info，并根据后者的参数去校正前者中的图像。最终输出以下（未）校正图像：灰度（去）畸变、彩色（去）畸变。</span></span><br></pre></td></tr></table></figure><p>image_proc 还提供了四个nodelet：</p><ul><li>debayer：将image转换成灰度、彩色两个版本并输出</li><li>rectify：校正图像</li><li>crop_decimate：图像抽样，即将图像的像素减小</li><li>resize：调整图像大小</li></ul><p><strong>depth_image_proc</strong></p><p>depth_image_proc主要用来处理深度图像，其所有的功能通过nodelet来提供：</p><ul><li>convert_metric：量测值变换，将深度信息的单位从mm变为m</li><li>disparity：将深度图重变为disparity格式（disparity是一种视差图，可以通过双目相机生成）</li><li>point_cloud_xyz：将深度图转换成点云图像，输出格式为sensor_msgs/PointCloud2</li><li>point_cloud_xyzrgb：将深度图和RGB合成，并转换成点云图像，输出格式为sensor_msgs/PointCloud2</li><li>register：将深度相机的frame-id变换到另一个坐标系中。</li></ul><h3 id="4-nodelet"><a href="#4-nodelet" class="headerlink" title="4. nodelet"></a>4. <strong>nodelet</strong></h3><p>由于ROS使用Topic方式传输数据存在一定的延时和阻塞。在数据量小、频率低的情况下，传输耗费的时间可以忽略不计。但当传输图像流，点云等数据量较大的消息，或者执行有一定的实时性要求的任务时，因传输而耗费的时间就不得不考虑。nodelet的作用是让多个node在一个进程中用实现零拷贝通信。</p><p>用户需要manager节点，该节点管理多个nodelet节点，并为它们提供高性能数据通信。用户需要根据实际需要开发nodelet（nodelet基于pluginlib插件机制），并将nodelet加载到nodelet manager中（<a href="https://www.cnblogs.com/21207-iHome/p/8213411.html" target="_blank" rel="noopener">blog关于nodelet的介绍</a>）。</p><p>当前图像相关的包多数提供了node和nodelet两种运行模式，使用以下命令可以查看当前系统中所有可运行nodelet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun nodelet declared_nodelets</span><br></pre></td></tr></table></figure><p>以下是调用了image_proc和depth_image_proc中的nodelet实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">"camera"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find rgbd_launch)/launch/includes/manager.launch.xml"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"camera_nodelet_manager"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"debug"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span> <span class="comment">&lt;!-- Run manager in GDB? --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"num_worker_threads"</span>  <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- decimated to 160x120，将像素变为原来1/4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"nodelet"</span> <span class="attr">type</span>=<span class="string">"nodelet"</span> <span class="attr">name</span>=<span class="string">"crop_decimate"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">args</span>=<span class="string">"load image_proc/crop_decimate /camera/camera_nodelet_manager"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera/image_raw"</span> <span class="attr">to</span>=<span class="string">"rgb/image_raw"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera/camera_info"</span> <span class="attr">to</span>=<span class="string">"rgb/camera_info"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera_out"</span> <span class="attr">to</span>=<span class="string">"depth_downsample"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"decimation_x"</span> <span class="attr">value</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"decimation_y"</span> <span class="attr">value</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"queue_size"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&amp;lt;!&amp;ndash; downsampled XYZ point cloud  &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"nodelet"</span> <span class="attr">type</span>=<span class="string">"nodelet"</span> <span class="attr">name</span>=<span class="string">"points_downsample"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">args</span>=<span class="string">"load depth_image_proc/point_cloud_xyz /camera/camera_nodelet_manager"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">ns</span>=<span class="string">"depth_cloud"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"image_rect"</span> <span class="attr">to</span>=<span class="string">"/camera/depth/image_raw"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera_info"</span> <span class="attr">to</span>=<span class="string">"/camera/depth/camera_info"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ROS-By-Example的教程"><a href="#ROS-By-Example的教程" class="headerlink" title="ROS By Example的教程"></a>ROS By Example的教程</h1><p>ROS By Example第十章介绍了以下内容：</p><ol><li>如何ROS中安装摄像头驱动。</li><li>在ROS框架之中使用Python-OpenCV，并通过Topic实现数据交互。</li><li>基于普通相机，使用OpenCV实现一个人脸追踪程序。</li><li>基于OpenNI的Skeleton Tracking程序。</li><li>PCL库的介绍</li></ol><p>上述内容的源码在Github的<a href="https://github.com/pirobot/rbx1/tree/indigo-devel/rbx1_vision" target="_blank" rel="noopener">pirobot/rbx1</a>项目中，使用官网这份代码有以下几点值得注意：</p><ol><li><p>rbx1中不少例子基于OpenCV1编写，由于OpenCV2以上版本和OpenCV1接口并非完全兼容，因此需要修改后才能正常使用。</p><ul><li>OpenCV2中完全整合numpy，如cv.CreateImage、cv.GetSize等接口已经完全取消，使用numpy的接口替代。</li><li>cv2中不少常量的名称也和cv中不同</li></ul></li><li><p><a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/nodes/video2ros.py" target="_blank" rel="noopener">video2ros.py</a>能够将avi格式的视频输出到ROS的指定topic中，使用这个脚本可以替代RGB摄像机，该脚本支持视频暂停、循环播放。</p></li><li><p><a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/src/rbx1_vision/ros2opencv2.py" target="_blank" rel="noopener">ros2opencv2.py</a>订阅指定Topic的图像输出，并在process_image函数中进行数据处理。编写视频处理程序时，可以继承该脚本中ROS2OpenCV2类，并复写process_image实现处理逻辑。</p></li><li><p>在catkin中如何编写python项目的makefile可以参考<a href="http://wiki.ros.org/cn/rospy_tutorials/Tutorials/Makefile" target="_blank" rel="noopener">catkin_python_setup</a></p></li></ol><h2 id="人脸追踪Demo"><a href="#人脸追踪Demo" class="headerlink" title="人脸追踪Demo"></a>人脸追踪Demo</h2><p>ROS By Example 10.8 详细介绍了如何利用一个OpenCV的现成算法实现一个人脸追踪程序，该Demo<strong>识别/最终</strong>流程如下：</p><ol><li>通过 Haar分类器，在一帧图像中识别人脸（<a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/src/rbx1_vision/face_detector.py" target="_blank" rel="noopener">face_detector.py</a>）；</li><li>通过 goodFeaturesToTrack方法在人脸区域提取KeyPoint（<a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/src/rbx1_vision/good_features.py" target="_blank" rel="noopener">good_features.py</a>）；</li><li>通过 OpenCV’s Lucas-Kanade optical flow 的实现跟踪上述KeyPoint；</li><li>验证当前追踪角点的有效性，添加新KeyPoint或移除失效KeyPoint；</li></ol><p>PS：上述方案基于灰度图像进行人脸追踪，教程中还提供了了一种基于图像色彩进行追踪的方案（基于CamShift算法）。</p><h3 id="Haar分类器"><a href="#Haar分类器" class="headerlink" title="Haar分类器"></a>Haar分类器</h3><p>在图片中识别人脸是一个分类过程，OpenCV提供基于haar特征和lbp特征的分类器。</p><p>使用Haar分类器，需要注意下面几点：</p><ul><li>需要提供训练好的xml格式的模型文件，每个模型文件可以初始化一个分类器（CascadeClassifier）</li><li>对分类器调用detectMultiScale可以返回frame中的匹配结果，可以将多个分类器并联（串联）提高识别准确率</li></ul><p>OpenCV的Haar分类器实现：Haar-like特征 + AdaBoost + 积分图（用来加速计算特征）</p><h3 id="角点检测"><a href="#角点检测" class="headerlink" title="角点检测"></a>角点检测</h3><p>OpenCV中的角点检测：</p><ul><li><p>cornerHarris：Harris角点检测，其检测原理、以及特征可以<a href="https://www.cnblogs.com/ronny/p/4009425.html" target="_blank" rel="noopener">参考blog</a></p><ul><li>参数α对角点检测的灵敏度成反比</li><li>Harris角点检测算子对<strong>亮度</strong>和<strong>对比度</strong>的变化不敏感</li><li>旋转不变性、尺度不变性、不具备仿射不变性(但是可以通过Harris-Affine实现)</li></ul></li><li><p>goodFeaturesToTrack：Shi-Tomasijiao</p></li><li><p>FAST：SUSAN算法</p></li></ul><p><a href="https://www.cnblogs.com/ronny/p/4260167.html" target="_blank" rel="noopener">参考: 图像局部特征点检测算法综述</a></p><h3 id="特征点追踪"><a href="#特征点追踪" class="headerlink" title="特征点追踪"></a>特征点追踪</h3><p>ROS by Example 中使用calcOpticalFlowPyrLK追踪，人脸上的角点运动，从而实现人脸跟踪的目的。</p><p>calcOpticalFlowPyrLK 是OpenCV提供的Lucas Kanade光流算法的实现，能够计算两帧图像之间特征点的位移。</p><p>光流定义为：空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。</p><p>个人理解，光流可以认为是素点的瞬时位移向量，是世界中可以感觉到的明显的视觉运动。</p><p>参考：<a href="https://blog.csdn.net/zouxy09/article/details/8683859" target="_blank" rel="noopener">对OpenCV中光流函数的介绍</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ROS by Example 中人脸跟踪的Demo全都是基于传统CV算法的。由于我没有摄像头，输入使用的是一个清晰度很差的视频图像，最终导致识别和追踪效果全都差强任意。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u011722133/article/details/53337818" target="_blank" rel="noopener">ROS图像相关包</a></p><p><a href="https://www.cnblogs.com/ello/archive/2012/04/28/2475419.html" target="_blank" rel="noopener">Haar分类器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;a href=&quot;https://docs.opencv.org/4.1.1/d6/d00/tutorial_py_root.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenCV-Python Tutorials&lt;/a&gt;、ROS By Example的学习笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="OpenCV" scheme="https://LinQing2017.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>摄像头标定</title>
    <link href="https://LinQing2017.github.io/2019/09/01/%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%87%E5%AE%9A/"/>
    <id>https://LinQing2017.github.io/2019/09/01/摄像头标定/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>简述张氏标定法，以及深度相机标定原理。</p><a id="more"></a><h1 id="RGB相机标定"><a href="#RGB相机标定" class="headerlink" title="RGB相机标定"></a>RGB相机标定</h1><h2 id="矩阵变换关系"><a href="#矩阵变换关系" class="headerlink" title="矩阵变换关系"></a>矩阵变换关系</h2><p>相机标定涉及到以下坐标系，其最终目的是建立<strong>世界坐标系</strong>和<strong>像素坐标系</strong>之间的关系</p><ul><li><strong>世界坐标系</strong>$$(x_w,y_w,z_w)$$：用户定义的三维世界坐标系</li><li><strong>相机坐标系</strong>$$(x_c,y_c,z_c)$$：相机坐标系z轴和光轴重合，且垂直于图像坐标系</li><li><strong>图像坐标系</strong>$$(x,y,z)$$：成像平面坐标</li><li><strong>像素坐标系</strong>$$(u,v)$$：和图像坐标系同平面，但是原点在左上角，单位为像素</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述坐标系有如下变换：</p><p><strong>1. 世界坐标系到相机坐标系</strong></p><p>将三维坐标中的点使用其次坐标表示，且刚体坐标系的变换可以通过旋转和平移得到：<br>$$<br>\left[\begin{matrix}x_c \y_c \z_c \ 1\end{matrix}\right]=<br>\left[\begin{matrix} R &amp; t \ 0 &amp; 1 \end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \z_w \ 1\end{matrix}\right]=<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; r_3 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \0 \ 1\end{matrix}\right]=<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \1\end{matrix}\right] \tag{1}<br>$$<br>上面的公式假定，物体的$$z_w=0$$，即可以认为标定时棋盘平面和$$X_wOY_w$$重合。</p><p><strong>2. 相机坐标到图像坐标系</strong></p><p>这一过程进行了从三维坐标到二维坐标的转换，即寻找相机坐标系中点（三维坐标）在图像坐标系中的成像点（二维坐标）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E7%9B%B8%E6%9C%BA%E5%9D%90%E6%A0%87%E7%B3%BB%E5%88%B0%E5%9B%BE%E5%83%8F%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>根据上述图中的变换关系，即可推到出以下公式（$$f$$为相机焦距）。</p><p>$$<br>z_c\left[\begin{matrix}x \y \ 1\end{matrix}\right]=<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix}x_c \y_c \z_c\end{matrix}\right]=<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix} 1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0 \end{matrix}\right]<br>\left[\begin{matrix}x_c \y_c \z_c \1\end{matrix}\right]<br>\tag{2}<br>$$</p><p>*<em>3. *</em>图像坐标系考虑畸变</p><p>畸变是相机内部的固有性质，主要包括：径向畸变、切向畸变、薄透镜畸变。</p><p>$$[x，y，1]^T$$如何矫正畸变转换为实际图像坐标系暂时不介绍。</p><p><strong>4. （实际）图像坐标系到像素坐标系</strong></p><p>由于定义的像素坐标系原点与图像坐标系原点不重合，假设像素坐标系原点在图像坐标系下的坐标为$$(u0，v0)$$，每个像素点在图像坐标系x轴、y轴方向的尺寸为：dx、dy（每个像素点代表的实际尺寸），且像点在实际图像坐标系下的坐标为$$(x，y)$$，于是可得到像点在像素坐标系下的坐标为：</p><p>$$u=x/d_x+u_0, v=v/d_y+v_0$$，矩阵形式为：<br>$$<br>\left[\begin{matrix}u \v \1\end{matrix}\right] =<br>\left[\begin{matrix} 1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix}x \y \1\end{matrix}\right] \tag3<br>$$</p><p>将上面的三个公式合并，得到世界坐标系——相机坐标系——图像坐标系——像素坐标系的转换公式：<br>$$<br>\left[\begin{matrix}u \v \1\end{matrix}\right] =<br>\left[\begin{matrix} 1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]1/z_c<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix} 1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0 \end{matrix}\right]<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; r_3 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \0 \ 1\end{matrix}\right]<br>$$<br>根据上面的公式化简，得到：<br>$$<br>M=\left[\begin{matrix} 1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]=<br>\left[\begin{matrix} f/d_x=f_x&amp;0&amp;u_0\0&amp;f/d_y=f_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>$$</p><p>$$<br>\left[\begin{matrix} R &amp; t \ 0 &amp; 1 \end{matrix}\right]=<br>\left[\begin{matrix} 1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0 \end{matrix}\right]<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; r_3 &amp; t\end{matrix}\right]<br>$$</p><p>上面两矩阵即是标定时的相机<strong>内参矩阵</strong>和<strong>外参矩阵</strong>，根据两者的含义可以知道：</p><ul><li><p>内参矩阵是固定不变的</p></li><li><p>外参矩阵由于相机相对于世界坐标系的位置不同，会发生变化。</p></li></ul><p>  PS：外参矩阵通常表示成棋盘格到相机坐标系的变换，相机到棋盘格有多少个视角，就有多少个外参矩阵。此处实际上是假设：<strong>棋盘平面和$$X_wOY_w$$重合，即$$Z_w=0$$</strong>。</p><p>  如果按照以下方式标定：</p><ul><li><p>将机械臂基座作为世界坐标系</p></li><li><p>相机位置固定</p></li><li><p>棋盘格固定在TCP上，通过移动TCP点获取相机到棋盘格的不同视角，然后进行标定</p><p>按上述方式，世界坐标系到相机的变换是固定的，外参实际上是机械器末端执行器的一个坐标系到相机坐标系的变换。</p></li></ul><h2 id="张氏相机标定"><a href="#张氏相机标定" class="headerlink" title="张氏相机标定"></a>张氏相机标定</h2><p>由像素坐标系到世界坐标系的成像关系如下：<br>$$<br>\left[\begin{matrix}u \ v \ 1\end{matrix}\right]=<br>s\left[\begin{matrix} f_x&amp;\gamma&amp;u_0\0&amp;f_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \ y_w \ 1\end{matrix}\right]=<br>sM\left[\begin{matrix}r_1 &amp; r_2 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \ y_w \ 1\end{matrix}\right]<br>$$<br>上面公式中s是<strong>尺度因子</strong>，$$fx、fy、u0、v0、γ$$（由于制造误差产生的两个坐标轴偏斜参数，通常很小）表示5个相机内参，$$R,t$$表示相机外参。</p><p>上述变换实际上是一个单应性变换，对应变换矩阵为<strong>单应性矩阵</strong>，它<strong>同时包含了相机内参和外参</strong>。</p><p>所以相机标定的目标即根据标定图得到单应矩阵，具体的过程如下：</p><ul><li>打印一张棋盘格标定图纸，将其贴在平面物体的表面</li><li>拍摄一组不同方向棋盘格的图片，可以通过移动相机来实现，也可以移动标定图片来实现</li><li>对于每张拍摄的棋盘图片，检测图片中所有棋盘格的特征点（角点，也就是下图中黑白棋盘交叉点）。可以定义打印的棋盘图纸位于世界坐标系Zw=0的平面上，世界坐标系的原点位于棋盘图纸的固定一角，像素坐标系原点位于图片左上角。</li><li><strong>棋盘标定图纸中所有角点的空间坐标是已知的</strong>，<strong>角点对应在拍摄的标定图片中的角点的像素坐标也是已知的</strong></li><li>使用OpenCV中的现成函数求解单应矩阵</li></ul><h1 id="深度相机标定"><a href="#深度相机标定" class="headerlink" title="深度相机标定"></a>深度相机标定</h1><p>深度相机同样需要标定相机内参和外参，并且当深度相机和RGB相机的安装位置有区别时，还需将深度相机的信息转换到RGB相机中，这个过程称为<strong>配准</strong>。</p><ul><li>深度相机标定：求解深度相机的内参和外参</li><li>深度相机配准：求解深度相机到RGB相机的变换矩阵</li></ul><p>不同于RGB相机，深度相机的标定有很多方法，这里不介绍原理。</p><h1 id="相机标定工具"><a href="#相机标定工具" class="headerlink" title="相机标定工具"></a>相机标定工具</h1><h2 id="1-GML"><a href="#1-GML" class="headerlink" title="1. GML"></a>1. GML</h2><p><a href="http://graphics.cs.msu.ru/en/node/909" target="_blank" rel="noopener">GML C++ Camera Calibration Toolbox</a>是基于OpenCV的一款开源相机标定工具，具有图形界面，能够对RGB相机进行标定，并返回相机<strong>内参矩阵</strong>、<strong>畸变函数</strong>。</p><h2 id="2-camera-calibration"><a href="#2-camera-calibration" class="headerlink" title="2. camera_calibration"></a>2. camera_calibration</h2><p><a href="http://wiki.ros.org/camera_calibration" target="_blank" rel="noopener">Camera Calibration</a>是ROS上的一个标定工具，该工具使用棋盘格的方式可以标定深度和彩色相机。</p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="1-齐次坐标"><a href="#1-齐次坐标" class="headerlink" title="1. 齐次坐标"></a>1. 齐次坐标</h2><p>齐次坐标表示是计算机图形学的重要手段之一，它既能够用来<strong>明确区分向量和点</strong>，同时也更易用于进行仿射（线性）几何变换。</p><p>基本内容：</p><ul><li><p>对于向量$$\vec v$$及其基$$( \boldsymbol a, \boldsymbol b, \boldsymbol c)$$存在一组坐标$$(v_1,v_2,v_3)$$，使得$$\vec v=v_1<em>a+v_2</em>b+v_3*c$$</p></li><li><p>对于空间中的点$$p$$则存在坐标$$(p_1,p_2,p_3)$$，使得$$p-p_0=p_1<em>a+p_2</em>b+p_3*c$$，其中$$p_0$$是坐标系的原点</p></li></ul><p>考虑以上两个公式，在三维坐标系中，统一表示向量和点可以使用四维向量$$(v_1,v_2,v_3,w)$$，当$$w=0$$时该四维向量表示三维空间的一个向量，当$$w=1$$时该四维向量表示三维空间的一个点。</p><h2 id="2-单应性变换"><a href="#2-单应性变换" class="headerlink" title="2. 单应性变换"></a>2. 单应性变换</h2><p><strong>单应性变换</strong>是一种图像变换方式，常见图像变换包括以下几种。</p><ul><li><p>线性变换：旋转、镜像、缩放、推移</p></li><li><p>仿射变换：线性变换 + <strong>平移</strong></p></li><li><p>透视变换：图片投影到一个新的视平面</p></li><li><p>单应性变换：一个平面到另外一个平面的投影映射。如，二维平面上的点映射到摄像机成像仪上的映射。</p></li></ul><p>单应性变换会涉及到<strong>单应性矩阵</strong>，有以下公式：</p><p>$$b = Ha^T$$，其中$$a=[x,y,1]^T$$，$$a=[x_1,y_1,1]^T$$为同一个点在原图像和映射图像上的坐标，$$H$$为$$3*3$$的单应性矩阵。</p><p>要求解上述公式中的H，只需获得四个点对即可，在OpenCV等视觉算法库中通常都有相应函数。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/csyisong/archive/2008/12/09/1351372.html" target="_blank" rel="noopener">齐次坐标</a></p><p><a href="https://www.cnblogs.com/ml-cv/p/5871052.html?utm_source=itdadao&utm_medium=referral" target="_blank" rel="noopener">单应性变换求解</a></p><p><a href="http://www.sohu.com/a/220313594_100007727" target="_blank" rel="noopener">张氏相机标定1</a></p><p><a href="http://www.sohu.com/a/223594989_100007727" target="_blank" rel="noopener">张氏相机标定2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简述张氏标定法，以及深度相机标定原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="OpenCV" scheme="https://LinQing2017.github.io/tags/OpenCV/"/>
    
      <category term="标定" scheme="https://LinQing2017.github.io/tags/%E6%A0%87%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（六）</title>
    <link href="https://LinQing2017.github.io/2019/08/20/6-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/20/6-ROS学习笔记/</id>
    <published>2019-08-20T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.974Z</updated>
    
    <content type="html"><![CDATA[<p>tf包的介绍，以及基本使用。</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>示例程序展示了二维平面内：通过TF实现的坐标跟随（turtle仿真中两只小乌龟相互跟随，<a href="http://wiki.ros.org/tf/Tutorials/Introduction%20to%20tf" target="_blank" rel="noopener">参考</a>）。</p><p>整个示例程序包括以下node：</p><ul><li>turtle1_tf_broadcaster：广播turtle1的绝对坐标</li><li>turtle2_tf_broadcaster: 广播turtle2的绝对坐标</li><li>turtle_tf_listener: 从/tf获取turtle2到turtle1的相对变换，并控制turtle2向turtle1移动</li><li>turtlesim_node、turtle_teleop_key：turtle套件</li></ul><h2 id="广播Node"><a href="#广播Node" class="headerlink" title="广播Node"></a>广播Node</h2><p>广播node监听/turtle/pose中的位置数据，并计算其绝对坐标系。</p><p>针对其接收到的每一条消息，调用回调函数将其广播到/tf中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_turtle_pose</span><span class="params">(msg, turtlename)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        回调函数，负责广播turtle的相对坐标系</span></span><br><span class="line"><span class="string">    :param msg:</span></span><br><span class="line"><span class="string">    :param turtlename:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    br = tf.TransformBroadcaster()</span><br><span class="line">    br.sendTransform((msg.x, msg.y, <span class="number">0</span>),</span><br><span class="line">                     tf.transformations.quaternion_from_euler(<span class="number">0</span>, <span class="number">0</span>, msg.theta), <span class="comment"># 将欧拉角，转换为四元数</span></span><br><span class="line">                     rospy.Time.now(),</span><br><span class="line">                     turtlename,</span><br><span class="line">                     <span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        turtle_tf_broadcaster节点负责发布某个turtle的绝对坐标系（即相对于World坐标系的变换）。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        进程启动后完成以下工作：</span></span><br><span class="line"><span class="string">            1. 获取传入的参数turtle；</span></span><br><span class="line"><span class="string">            2. 监听/~turtle/pose的消息，并对每个消息调用回调函数handle_turtle_pose</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    rospy.init_node(<span class="string">'turtle_tf_broadcaster'</span>)</span><br><span class="line">    turtlename = rospy.get_param(<span class="string">'~turtle'</span>)</span><br><span class="line">    rospy.Subscriber(<span class="string">'/%s/pose'</span> % turtlename,</span><br><span class="line">                     turtlesim.msg.Pose,</span><br><span class="line">                     handle_turtle_pose,        <span class="comment"># 回调函数</span></span><br><span class="line">                     turtlename)                <span class="comment"># 回调函数的参数</span></span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p><a href="http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28Python%29" target="_blank" rel="noopener">完整代码</a></p><h2 id="监听变换"><a href="#监听变换" class="headerlink" title="监听变换"></a>监听变换</h2><p>接收并缓冲系统中广播的所有坐标系，查询特定坐标系之间的变换关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    rospy.init_node(<span class="string">'turtle_tf_listener'</span>)</span><br><span class="line">    listener = tf.TransformListener()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        在turtlesim_node中在模拟出第二个turtle，并指定其初始位置和位置控制topiccmd_vel</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">    rate = rospy.Rate(<span class="number">10.0</span>) <span class="comment"># 指定以下循环的频率</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取/turtle2到/turtle1的坐标系变换，rospy.Time(0)表示最新的变换</span></span><br><span class="line">            (trans,rot) = listener.lookupTransform(<span class="string">'/turtle2'</span>, <span class="string">'/turtle1'</span>, rospy.Time(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">except</span> (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以下内容控制turtle2向turtle1移动，即将turtle2坐标系向turtle1移动</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><p><a href="http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20listener%20%28Python%29" target="_blank" rel="noopener">完整代码</a></p><h2 id="TF和时间的关系"><a href="#TF和时间的关系" class="headerlink" title="TF和时间的关系"></a>TF和时间的关系</h2><p>计算frame-A在Ta相对于frame-B在Tb的时间坐标系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    now = rospy.Time.now()</span><br><span class="line">    past = now - rospy.Duration(<span class="number">5.0</span>)</span><br><span class="line">    listener.waitForTransformFull(<span class="string">"/turtle2"</span>, now,<span class="string">"/turtle1"</span>, past,<span class="string">"/world"</span>, rospy.Duration(<span class="number">1.0</span>))</span><br><span class="line">    (trans, rot) = listener.lookupTransformFull(<span class="string">"/turtle2"</span>, now,<span class="string">"/turtle1"</span>, past,<span class="string">"/world"</span>)</span><br></pre></td></tr></table></figure><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打印当前tf的拓扑到pdf文件中</span><br><span class="line">rosrun tf view_frames</span><br><span class="line"></span><br><span class="line"># 打印tf拓扑</span><br><span class="line">rosrun rqt_tf_tree rqt_tf_tree</span><br><span class="line"></span><br><span class="line"># 打印坐标系的变换关系，输出为 Translation（原点平移关系）、Rotation（转动角度，包括：四元数和欧拉角）</span><br><span class="line">rosrun tf tf_echo [frame_id_1] [frame_id_2]</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/tf" target="_blank" rel="noopener">tf</a></p><p><a href="http://wiki.ros.org/tf/Tutorials/Debugging%20tf%20problems" target="_blank" rel="noopener">Debugging tf problems</a></p><p><a href="http://wiki.ros.org/tf2" target="_blank" rel="noopener">tf2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tf包的介绍，以及基本使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="tf" scheme="https://LinQing2017.github.io/tags/tf/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（三）</title>
    <link href="https://LinQing2017.github.io/2019/08/12/3-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/12/3-ROS学习笔记/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.973Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Moveit"><a href="#Moveit" class="headerlink" title="Moveit"></a>Moveit</h1><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><p><img src="https://moveit.ros.org/assets/images/diagrams/move_group.png" alt=""></p><p>Moveit！中最重要的模块是move_group节点，该节点起到接口整合，以及提供Action、Service的作用。</p><p>关于move_group有以下几点：</p><ol><li><p>整合C++（move_group_interface）、Python（moveit_commander）、GUI接口（Rviz），提供Action、Service功能</p></li><li><p>从ROS Param Server加载URDF、SRDF、Moveit！以及其他配置</p></li><li><p>move_group节点通过ROS的topic和actions控制robot，告知其位置信息、点云信息、以及其他传感器数据</p></li></ol><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>下面的问题是阅读<a href="https://moveit.ros.org/documentation/concepts/" target="_blank" rel="noopener">Concepts</a>后提炼出来的：</p><ol><li>URDF文件如何定义？如何展示(gazebo、Rviz)？</li><li>SRDF文件包含哪些信息？详细了解SRDF文件文件内容？movit-setup-assistant 生成了哪些文件？这些文件有啥用途？</li></ol><p><del>3. /joint_states 中的数据含义是啥？如何通过他控制机械臂动作？</del></p><p><del>4. robot_state_publisher 如何从/joint_states以及robot_description的URDF中计算TF？TF详细场景如何？</del></p><ol start="3"><li><p>ros_control 如何工作？对hardwareInterface、actuator如何理解？</p></li><li><p>如何使用control？如何定义control？control如何工作？control中涉及的数据有哪些含义？怎么生成的？</p></li><li><p>move_group 和 robot_state_publisher、joint_state_publisher如何交互？</p></li><li><p>FollowJointTrajectoryAction 是啥？如何通过他控制机器人？</p></li><li><p>PlanRequestAdapters和montion_planner如何工作？如何发送Request？Response是什么样的？规划路径时如何添加限制条件？</p></li><li><p>PlanningScene中包含哪些东西？都有什么作用？</p></li><li><p>了解正/逆运动学原理？</p></li><li><p>了解如何进行碰撞检测？如何应用ACM矩阵？</p></li></ol><h1 id="运行UR5的movit-Demo"><a href="#运行UR5的movit-Demo" class="headerlink" title="运行UR5的movit! Demo"></a>运行UR5的movit! Demo</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><pre><code>- jontromanab/ur5_barrett_description- jontromanab/ur5_barrett_bringup- jontromanab/ur5_barrett_moveit</code></pre><h2 id="仿真过程"><a href="#仿真过程" class="headerlink" title="仿真过程"></a>仿真过程</h2><p>Step 1： roslaunch ur5_barrett_bringup ur5_barrett_table_world.launch limited:=true</p><p>Step 2： roslaunch ur5_barrett_moveit ur5_barrett_moveit_planning_execution.launch limited:=true</p><p>Step 3： 运行下面的代码控制末端执行器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> PyKDL</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> moveit_commander</span><br><span class="line"><span class="keyword">import</span> moveit_msgs.msg</span><br><span class="line"><span class="keyword">import</span> geometry_msgs.msg</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="keyword">from</span> moveit_commander.conversions <span class="keyword">import</span> pose_to_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    moveit_commander.roscpp_initialize(sys.argv)</span><br><span class="line">    rospy.init_node(<span class="string">'control_ur5'</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    robot = moveit_commander.RobotCommander()</span><br><span class="line">    scene = moveit_commander.PlanningSceneInterface()</span><br><span class="line"></span><br><span class="line">    group_name = <span class="string">"manipulator"</span>  <span class="comment"># endeffector #manipulator</span></span><br><span class="line">    move_group = moveit_commander.MoveGroupCommander(group_name)</span><br><span class="line"></span><br><span class="line">    display_trajectory_publisher = rospy.Publisher(<span class="string">'/move_group/display_planned_path'</span>,</span><br><span class="line">                                                   moveit_msgs.msg.DisplayTrajectory, queue_size=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    current_pose = move_group.get_current_pose()</span><br><span class="line">    print(<span class="string">"================= Before Pos ================= "</span>)</span><br><span class="line">    print(current_pose)</span><br><span class="line"></span><br><span class="line">    pose_goal = geometry_msgs.msg.Pose()  <span class="comment"># Goal position</span></span><br><span class="line">    rot = PyKDL.Rotation.Quaternion(current_pose.pose.orientation.x, current_pose.pose.orientation.y,</span><br><span class="line">                              current_pose.pose.orientation.z, current_pose.pose.orientation.w)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set goal rot</span></span><br><span class="line">    print(rot.GetQuaternion())</span><br><span class="line">    rot.DoRotY(-pi/<span class="number">2</span>)</span><br><span class="line">    pose_goal.orientation = geometry_msgs.msg.Quaternion(*list(rot.GetQuaternion()))</span><br><span class="line">    print(rot.GetQuaternion())</span><br><span class="line">    <span class="comment"># set goal position</span></span><br><span class="line">    pose_goal.position.x = current_pose.pose.position.x</span><br><span class="line">    pose_goal.position.y = current_pose.pose.position.y</span><br><span class="line">    pose_goal.position.z = current_pose.pose.position.z</span><br><span class="line">    <span class="comment"># pose_goal.position.x = 0.7</span></span><br><span class="line">    <span class="comment"># pose_goal.position.y = 0</span></span><br><span class="line">    <span class="comment"># pose_goal.position.z = 0.4</span></span><br><span class="line"></span><br><span class="line">    move_group.set_pose_target(pose_goal)</span><br><span class="line">    move_group.go(wait=<span class="literal">True</span>)</span><br><span class="line">    move_group.stop()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"================= Current Pos ================= "</span>)</span><br><span class="line">    print(current_pose)</span><br></pre></td></tr></table></figure><p>需要注意：</p><p>手臂长度有限，臂长大概是0.8m，离地高度大概是0.36m。如果输入的目标位置，不在这个范围内将会规划失败。指定目标点时，使用的是geometry_msgs/Pose参数，包含：</p><ul><li>geometry_msgs/Point position：世界坐标系下(x,y,z)</li><li>geometry_msgs/Quaternion orientation：执行器转过的角度(绕x轴转动为手掌转动朝向不变，绕y，x轴转动为手掌不动，朝向变动)。</li></ul><p>关于Geometry_Msgs.msg.Pose参考这个<a href="https://answers.ros.org/question/265988/can-someone-explain-geometry_msgs-as-used-for-robot-arm-poses-eg/" target="_blank" rel="noopener">帖子</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ncnynl.com/archives/201610/947.html" target="_blank" rel="noopener">moveit！中文参考资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;Moveit&quot;&gt;&lt;a href=&quot;#Moveit&quot; class=&quot;headerlink&quot; title=&quot;Moveit&quot;&gt;&lt;/a&gt;Moveit&lt;/h1&gt;&lt;h2 id=&quot;系统结构&quot;&gt;&lt;a href=&quot;#系统结构&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="Moveit！" scheme="https://LinQing2017.github.io/tags/Moveit%EF%BC%81/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（五）</title>
    <link href="https://LinQing2017.github.io/2019/08/12/5-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/12/5-ROS学习笔记/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.974Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="ROS-Control"><a href="#ROS-Control" class="headerlink" title="ROS Control"></a>ROS Control</h1><p>ros_control是通用Robot控制框架，用来连接ROS中应用和实际（仿真）机器人，它包含一系列控制器接口、传动装置接口、硬件接口、控制器工具箱等等，可以帮助机器人应用快速落地，提高开发效率。</p><p>ros_control运行时，包括以下几个部分：</p><ul><li>Controller Manager：Manger管理了多个Controller，每个Controller代表一个上层ROS应用。</li><li>Controller：Controller可以完成每个joint的控制，请求下层的硬件资源，并且提供了PID控制器，读取硬件资源接口中的状态，并发布控制命令。</li><li>Hardware Rescource：抽象接口层</li><li>RobotHW：硬件抽象层和硬件直接打交道，通过write和read方法来完成硬件的操作，这一层也包含关节限位、力矩转换、状态转换等功能。</li></ul><p>下图是ros_control的数据流图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://wiki.ros.org/ros_control?action=AttachFile&do=get&target=gazebo_ros_control.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>目前，ros_control中提供了一些现成Controllers和Hardware Interface，用户可以根据需要自己定制这些插件。</p><h1 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h1><h2 id="Transmissions"><a href="#Transmissions" class="headerlink" title="Transmissions"></a>Transmissions</h2><p>Transmissions就是机器人的传动系统，机器人每个需要运动的关节都需要配置相应的Transmission。</p><p>通常情况下Transmission的内容会在<a href="http://wiki.ros.org/urdf/XML/Transmission" target="_blank" rel="noopener">URDF文件</a>中直接定义。用户定义Transmission内容时可以定义在单独的文件中，之后include到需要的URDF文件中。</p><p>目前，ROS提供的<a href="http://docs.ros.org/jade/api/transmission_interface/html/c++/group__transmission__types.html" target="_blank" rel="noopener">transmission类型</a>包括：</p><ul><li>DifferentialTransmission</li><li>FourBarLinkageTransmission</li><li>SimpleTransmission</li></ul><p>机械臂中一般只会用到SimpleTransmission。</p><p>以下是一个Joint的传动定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">"trans_name"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"joint_name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">"joint_motor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述定义中，注意以下两点：</p><ul><li>hardwareInterface：Controller和RobotHw沟通的接口，基本上和controllers的种类是对应的（参考<a href="http://docs.ros.org/api/hardware_interface/html/c++/namespacehardware__interface.html" target="_blank" rel="noopener">HardwareInterface类型</a>）。</li><li>actuator：??? 不知道用来干啥的？？？</li></ul><h2 id="Joint-Limits"><a href="#Joint-Limits" class="headerlink" title="Joint Limits"></a>Joint Limits</h2><p>Joint Limits是RobotHW中的一块，维护一个关节限位的数据结构，包含关节速度、位置、加速度、加加速度、力矩等方面的限位，还包含安全作用的位置软限位、速度边界（k_v）和位置边界（k_p）等等。</p><p>Joint Limits可以直接定义在URDF文件中，可以通过YAML文件加载到ROS parameter server中，还可以使用joint_limits_interface在代码中定义。</p><h2 id="Controller-manager"><a href="#Controller-manager" class="headerlink" title="Controller manager"></a>Controller manager</h2><p>Controller Manager可以加载、开始运行、停止运行、卸载不同的controller，并且提供了多种工具来完成这些操作。</p><p>命令行工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun controller_manager controller_manager &lt;command&gt; &lt;controller_name&gt;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ncnynl.com/archives/201708/1932.html" target="_blank" rel="noopener">ROS Control介绍</a></p><p><a href="http://gazebosim.org/tutorials?tut=ros_control" target="_blank" rel="noopener">Gazebo Ros Control</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;ROS-Control&quot;&gt;&lt;a href=&quot;#ROS-Control&quot; class=&quot;headerlink&quot; title=&quot;ROS Control&quot;&gt;&lt;/a&gt;ROS Control&lt;/h1&gt;&lt;p&gt;ros_control是通用R
      
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="Moveit" scheme="https://LinQing2017.github.io/tags/Moveit/"/>
    
      <category term="ROS Control" scheme="https://LinQing2017.github.io/tags/ROS-Control/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（四）</title>
    <link href="https://LinQing2017.github.io/2019/08/12/4-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/12/4-ROS学习笔记/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.974Z</updated>
    
    <content type="html"><![CDATA[<p>理解URDF、XACRO文件的内容</p><a id="more"></a><h1 id="URDF"><a href="#URDF" class="headerlink" title="URDF"></a>URDF</h1><p>URDF(Unified Robot Description Format), 是一种特殊的xml文件格式，绝大多数机器人应当提供xxx_description安装包，可以通过apt-get直接安装。</p><p>xacro文件是一种提供了一些更为高级编辑方式的宏文件，通过下面的命令可以将xacro解析出urdf。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成urdf，一个xacro中可能include了多个子文件，但是最终只会生成一个urdf文件</span></span><br><span class="line">rosrun xacro xacro.py /opt/ros/melodic/share/franka_description/robots/panda_arm_hand.urdf.xacro &gt; panda_arm_hand.urdf</span><br></pre></td></tr></table></figure><h2 id="URDF文件格式"><a href="#URDF文件格式" class="headerlink" title="URDF文件格式"></a>URDF文件格式</h2><p>URDF文件主要包括：</p><ul><li>link：表示Robot的一个关节<ul><li>visual：描述形状，可以是简单形状，或者一个stl格式的文件</li><li>collision：描述link的碰撞体积</li></ul></li><li>joint：表示link之间的相对位置关系，包括：<ul><li>parent</li><li>child</li><li>xyz：原点的平移向量(父链 ——&gt; 子链)，单位为米</li><li>rpy: child和parent坐标系的旋转矢量（转动顺序为：x -&gt; y -&gt; z）</li></ul></li></ul><h2 id="Joint-类型"><a href="#Joint-类型" class="headerlink" title="Joint 类型"></a>Joint 类型</h2><p>参考URDF中<a href="http://wiki.ros.org/urdf/XML/joint" target="_blank" rel="noopener">joint标签</a>的定义，Joint有六种类型：</p><ul><li>revolute ：绕固定轴旋转有角度上下限</li><li>continuous ：绕固定轴旋转没有角度限制</li><li>prismatic ：滑动接头，沿轴线滑动，并具有由上限和下限指定的有限范围</li><li>fixed ：固定连接</li><li>floating ：该关节允许所有6个自由度的运动。</li><li>planar ：该关节允许在垂直于轴的平面中运动。</li></ul><p>上述六种类型中，除fixed和floating以外，其余四种类型的运动轴均通过axis标签（默认情况下是(1,0,0)）定义。</p><p><strong><a href="http://docs.ros.org/melodic/api/sensor_msgs/html/msg/JointState.html" target="_blank" rel="noopener">sensor_msgs/JointState</a></strong>描述revolute和prismatic描述机器人的姿态，格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Header header</span><br><span class="line"></span><br><span class="line">string[] name           # 所有joint名称序列</span><br><span class="line">float64[] position      # joint的运动幅度，是角度或者位移</span><br><span class="line">float64[] velocity      # 当前的速度</span><br><span class="line">float64[] effort        # 关节上施加的力</span><br></pre></td></tr></table></figure><h2 id="XACRO"><a href="#XACRO" class="headerlink" title="XACRO"></a>XACRO</h2><p>XACRO文件和URDF实质上是等价的， 但是提供了一些更高级的方式来组织编辑机器人描述，包括：</p><ul><li>复用URDF段落</li><li>嵌入简单的计算</li><li>include多个xacro文件</li></ul><h2 id="可视化化URDF"><a href="#可视化化URDF" class="headerlink" title="可视化化URDF"></a>可视化化URDF</h2><p>查看urdf文件, 可以使用urdf_tutorial包:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">roslaunch urdf_tutorial display.launch model:=/home/ruijie/Desktop/panda_arm_hand.urdf</span><br><span class="line"></span><br><span class="line">roslaunch urdf_tutorial display.launch model:=/home/ruijie/Desktop/panda_arm_hand.urdf gui:=true</span><br><span class="line"></span><br><span class="line">roslaunch urdf_tutorial xacrodisplay.launch model:=/opt/ros/melodic/share/franka_description/robots/panda_arm_hand.urdf.xacro</span><br></pre></td></tr></table></figure><p>上述命令中display.launch包含以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 输入参数包括模型文件、是否使用GUI、rvizconfig配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"model"</span> <span class="attr">default</span>=<span class="string">"$(find urdf_tutorial)/urdf/01-myfirst.urdf"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"gui"</span> <span class="attr">default</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"rvizconfig"</span> <span class="attr">default</span>=<span class="string">"$(find urdf_tutorial)/rviz/urdf.rviz"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将urdf上传到robot_description中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro.py $(arg model)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"use_gui"</span> <span class="attr">value</span>=<span class="string">"$(arg gui)"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">type</span>=<span class="string">"joint_state_publisher"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">type</span>=<span class="string">"state_publisher"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"rviz"</span> <span class="attr">pkg</span>=<span class="string">"rviz"</span> <span class="attr">type</span>=<span class="string">"rviz"</span> <span class="attr">args</span>=<span class="string">"-d $(arg rvizconfig)"</span> <span class="attr">required</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述launch启动三个node：</p><ul><li>joint_state_publisher： 一个发布JointState数据的工具。joint_state_publisher读取robot_description参数，查找所有非固定关节并发布一个JointState消息，其中定义了所有这些关节。joint_state_publisher的输出是/<code>joint_states</code> ,输入可以是GUI、其他Topic等。</li><li>robot_state_publisher：订阅/joint_states，根据其中的JointState数据以及Robot的关节参数，更新/tf和/tf_static树中的坐标变换关系。</li><li>rviz：可视化显示</li></ul><h2 id="组合机器人"><a href="#组合机器人" class="headerlink" title="组合机器人"></a>组合机器人</h2><p>UR + Barrett：<a href="https://www.2cto.com/kf/201608/541696.html" target="_blank" rel="noopener">参考文章</a>中的xacro，没有成功。</p><p>Git上有不少UR + Barrett的例子，如<a href="https://github.com/jontromanab/ur5_barrett_moveit" target="_blank" rel="noopener">ur5_barrett_moveit</a>、<a href="https://github.com/jontromanab/ur5_barrett_description" target="_blank" rel="noopener">ur5_barrett_description</a></p><h1 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h1><p>SDF格式是一种从世界级到机器人级的所有内容的完整描述，能够描述Gazebo环境中的Robot以及其他内容。</p><p>SDF可以认为是URDF格式的扩展，提供了以下能力：</p><ul><li>在URDF基础上描述了物体的质量、惯性等更丰富的力学性质；</li><li>通过插件的方式可以描述摄像机、IMU等Gazebo支持的传感器；</li></ul><p>Gazebo提供了一些开源SDF格式的模型，用户可以在线下载或者<a href="https://bitbucket.org/osrf/gazebo_models/downloads/" target="_blank" rel="noopener">离线下载</a>后解压到.gazebo/models目录下。</p><p>Gazebo同时还支持一种.world格式的模型文件，这个文件同样支持SDF格式的语法，同SDF文件本质上没有差异。</p><p>一个空白的world文件，只定义了灯光、背景、视角等信息等信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sdf</span> <span class="attr">version</span>=<span class="string">"1.4"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- We use a custom world for the rrbot so that the camera angle is launched correctly --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">world</span> <span class="attr">name</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uri</span>&gt;</span>model://ground_plane<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Global light source --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uri</span>&gt;</span>model://sun<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Focus camera on tall pendulum --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gui</span> <span class="attr">fullscreen</span>=<span class="string">'0'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">camera</span> <span class="attr">name</span>=<span class="string">'user_camera'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pose</span>&gt;</span>4.927360 -4.376610 3.740080 0.000000 0.275643 2.356190<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view_controller</span>&gt;</span>orbit<span class="tag">&lt;/<span class="name">view_controller</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gui</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">world</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sdf</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SDF格式和URDF格式的差异"><a href="#SDF格式和URDF格式的差异" class="headerlink" title="SDF格式和URDF格式的差异"></a>SDF格式和URDF格式的差异</h2><p>SDF比URDF多出了inertial标签和gazebo标签：</p><ul><li>inertial标签：定义在link标签中，用来描述物体物理属性（如，质心位置、质量、惯性矩阵）</li><li>gazebo标签：gazebo标签可能定义在robot、link、joint等各种地方，其内容一般是Gazebo的扩展属性，通常一般使用.gazebo文件额外定义gazebo标签中的内容。</li></ul><p>通过下面的launch文件，可以将World和URDF文件加载到Gazebo中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Gazebo的启动参数，通常是paused、use_sim_time、gui、headless、debug --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 运行empty_world.launch可以加载，world_name指定的world文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find gazebo_ros)/launch/empty_world.launch"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"world_name"</span> <span class="attr">value</span>=<span class="string">"$(find rrbot_gazebo)/worlds/rrbot.world"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Gazebo的启动参数</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将URDF文件加载到robot_description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro --inorder '$(find rrbot_description)/urdf/rrbot.xacro'"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    spawn_model是gazebo_ros中提供的Python脚本可以解析URDF格式的文件，并在软件中展示。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    参考：rosrun gazebo_ros spawn_model -h 会打印该命令的详细用法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"urdf_spawner"</span> <span class="attr">pkg</span>=<span class="string">"gazebo_ros"</span> <span class="attr">type</span>=<span class="string">"spawn_model"</span> <span class="attr">respawn</span>=<span class="string">"false"</span> <span class="attr">output</span>=<span class="string">"screen"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">args</span>=<span class="string">"-urdf -model rrbot -param robot_description"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- ros_control rrbot launch file --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--include file="$(find rrbot_control)/launch/rrbot_control.launch" /--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Gazebo插件"><a href="#Gazebo插件" class="headerlink" title="Gazebo插件"></a>Gazebo插件</h2><p>Gazebo包括三种类型的插件：</p><ul><li>ModelPlugins</li><li>SensorPlugins</li><li>VisualPlugins</li></ul><p>需要注意SensorPlugins需要附加到link标签中进行定义，而不能单独定义。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... robot description ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"sensor_link"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... link description ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">"sensor_link"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">"camera"</span> <span class="attr">name</span>=<span class="string">"camera1"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 传感器参数 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">"camera_controller"</span> <span class="attr">filename</span>=<span class="string">"libgazebo_ros_camera.so"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 插件参数 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ncnynl.com/archives/201610/947.html" target="_blank" rel="noopener">moveit！中文参考资料</a></p><p><a href="http://gazebosim.org/tutorials?tut=ros_roslaunch" target="_blank" rel="noopener">Tutorial: Using roslaunch to start Gazebo, world files and URDF models</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解URDF、XACRO文件的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="URDF" scheme="https://LinQing2017.github.io/tags/URDF/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（二）</title>
    <link href="https://LinQing2017.github.io/2019/08/08/2-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/08/2-ROS学习笔记/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.973Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个ROS上运行的Hello World程序。</p><a id="more"></a><h1 id="Turtlesim"><a href="#Turtlesim" class="headerlink" title="Turtlesim"></a>Turtlesim</h1><p>Turtlesim是ROS官方提供的一个示例，用来帮助用户理解ROS中基本概念。</p><h2 id="观察node之间如何通信"><a href="#观察node之间如何通信" class="headerlink" title="观察node之间如何通信"></a>观察node之间如何通信</h2><p>参考官方<a href="http://wiki.ros.org/ROS/Tutorials/UnderstandingTopics" target="_blank" rel="noopener">Topic的概念</a>。</p><p>示例提供了一个简易的海龟绘图功能，涉及到下面几个Package：</p><table><thead><tr><th>Package</th><th>Publications</th><th>Pub</th><th>Subscriptions</th><th>备注</th></tr></thead><tbody><tr><td>turtlesim</td><td>turtlesim_node</td><td>/turtle1/color_sensor</br>/turtle1/pose</br></td><td>/turtle1/cmd_vel</td><td>—–</td></tr><tr><td>turtlesim</td><td>turtle_teleop_key</td><td>/turtle1/cmd_vel</td><td>—–</td><td>—–</td></tr></tbody></table><p>turtlesim_node是海龟的绘图界面，通过监听cmd_vel的位置信息来进行绘图。</p><p>turtle_teleop_key是基于键盘方向键的发送程序，不断的向cmd_vel中发送geometry_msgs/Twist格式的位置数据。</p><p>用户可以通过rostopic直接向cmd_vel发送数据控制海龟运动轨迹，或查看cmd_vel的数据。</p><p>使用rqt_graph可以绘制<strong>topic连接的具体拓扑信息</strong>，命令为<strong>rosrun rqt_graph rqt_graph</strong>。</p><p>使用rqt_plot可以<strong>将topic的数值信息绘制为连续曲线</strong>，命令为<strong>rosrun rqt_plot rqt_plot</strong>。</p><h2 id="调用Node服务以及修改参数"><a href="#调用Node服务以及修改参数" class="headerlink" title="调用Node服务以及修改参数"></a>调用Node服务以及修改参数</h2><p>turtlesim_node 提供了一些Services用来清空画板、复制画笔等功能，这些功能可以使用rosservice来调用（<a href="http://wiki.ros.org/ROS/Tutorials/UnderstandingServicesParams" target="_blank" rel="noopener">参考</a>）。</p><h2 id="查看node日志使用roslaunch"><a href="#查看node日志使用roslaunch" class="headerlink" title="查看node日志使用roslaunch"></a>查看node日志使用roslaunch</h2><p><a href="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch" target="_blank" rel="noopener">参考</a></p><p><a href="https://www.cnblogs.com/hiram-zhang/p/10393328.html" target="_blank" rel="noopener">参考2</a></p><h1 id="定义msg和srv"><a href="#定义msg和srv" class="headerlink" title="定义msg和srv"></a>定义msg和srv</h1><h2 id="自定义msg"><a href="#自定义msg" class="headerlink" title="自定义msg"></a>自定义msg</h2><p>假设在beginner_tutorials包中定义一个新msg包含以下内容：</p><p>Step 1：在beginner_tutorials中创建msg目录，并在该目录下创建Student.msg文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string first_name</span><br><span class="line">string last_name</span><br><span class="line">uint8 age</span><br><span class="line">uint32 score</span><br></pre></td></tr></table></figure><p>Step 2：修改package.xml文件添加message_generation依赖和message_runtime，其中编译时只用依赖message_generation，而运行时需要依赖message_runtime。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--编译时依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--运行时依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Step 3： 修改CMakeLists.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">2.8</span><span class="number">.3</span>)</span><br><span class="line">project(beginner_tutorials)</span><br><span class="line"></span><br><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation# 添加编译时需要的message_generation组件</span><br><span class="line">)</span><br><span class="line">add_message_files(</span><br><span class="line">   FILES</span><br><span class="line">   Num.msg# 指明msg定义文件的地址</span><br><span class="line"> )</span><br><span class="line">generate_messages(# message_generation组件主键的依赖，这里只依赖std_msgs</span><br><span class="line">   DEPENDENCIES</span><br><span class="line">   std_msgs</span><br><span class="line"> )</span><br><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES beginner_tutorials</span><br><span class="line">   CATKIN_DEPENDS roscpp rospy std_msgs message_runtime#CATKIN指明依赖</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br><span class="line">include_directories(</span><br><span class="line"># include</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Step 3：编译beginner_tutorials，使用rosmsg show beginner_tutorials/Student查看生成的msg</p><h2 id="srv接口定义"><a href="#srv接口定义" class="headerlink" title="srv接口定义"></a>srv接口定义</h2><p><a href="http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv" target="_blank" rel="noopener">参考</a></p><h1 id="Python实现Publisher-Subscriber"><a href="#Python实现Publisher-Subscriber" class="headerlink" title="Python实现Publisher/Subscriber"></a>Python实现Publisher/Subscriber</h1><p>python脚本放在Package的scripts目录下，可以无需编译直接运行：</p><p>talker.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># license removed for brevity</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个Topic，名称为chatter，类型为String，队列深度为10</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">'chatter'</span>, String, queue_size=<span class="number">10</span>) </span><br><span class="line">    <span class="comment"># 启动一个和roscore通信的node，名称为talker+xxxx</span></span><br><span class="line">    rospy.init_node(<span class="string">'talker'</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>) <span class="comment"># 10hz的数量发送数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        hello_str = <span class="string">"hello world %s"</span> % rospy.get_time()</span><br><span class="line">        <span class="comment"># loginfo：将信息打印到屏幕，并写入到rosout和日志文件</span></span><br><span class="line">        rospy.loginfo(hello_str)</span><br><span class="line">        pub.publish(hello_str)  <span class="comment">#发送数据</span></span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        talker()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>listener.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(data)</span>:</span></span><br><span class="line">    rospy.loginfo(rospy.get_caller_id() + <span class="string">"I heard %s"</span>, data.data)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listener</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># In ROS, nodes are uniquely named. If two nodes with the same</span></span><br><span class="line">    <span class="comment"># name are launched, the previous one is kicked off. The</span></span><br><span class="line">    <span class="comment"># anonymous=True flag means that rospy will choose a unique</span></span><br><span class="line">    <span class="comment"># name for our 'listener' node so that multiple listeners can</span></span><br><span class="line">    <span class="comment"># run simultaneously.</span></span><br><span class="line">    rospy.init_node(<span class="string">'listener'</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    rospy.Subscriber(<span class="string">"chatter"</span>, String, callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># spin() simply keeps python from exiting until this node is stopped</span></span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    listener()</span><br></pre></td></tr></table></figure><h1 id="Python实现Service和Client"><a href="#Python实现Service和Client" class="headerlink" title="Python实现Service和Client"></a>Python实现Service和Client</h1><p><a href="http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28python%29" target="_blank" rel="noopener">参考</a></p><h1 id="使用rosbag记录和回放Topic"><a href="#使用rosbag记录和回放Topic" class="headerlink" title="使用rosbag记录和回放Topic"></a>使用rosbag记录和回放Topic</h1><p><a href="http://wiki.ros.org/ROS/Tutorials/Recording%20and%20playing%20back%20data" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个ROS上运行的Hello World程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（一）</title>
    <link href="https://LinQing2017.github.io/2019/08/08/1-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/08/1-ROS学习笔记/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.973Z</updated>
    
    <content type="html"><![CDATA[<p>了解ROS的基本框架</p><a id="more"></a><h1 id="ROS概述"><a href="#ROS概述" class="headerlink" title="ROS概述"></a>ROS概述</h1><p>ROS是运行在Linux等操作系统上的一个次级操作系统，提供机器人从开发到运行的一系列工具。</p><p>ROS的核心模块包括：</p><p><strong>1. ROS通信机制</strong></p><p>ROS使用分布式架构，将机器人的功能和软件做成一个个node，然后每个node通过topic进行沟通，这些node可以部署在同一台机器上，也可以部署在不同机器上，还可以部署在互联网上。node之间通过<strong>topic发布/订阅</strong>的方式进行通信，或者基于ROS中<strong>Service机制点对点通信</strong>。</p><p><strong>2. 机器人特性功能</strong></p><p>机器人特性功能主要指机器人开发中常用的<strong>数据结构</strong>、<strong>算法</strong>、<strong>规范</strong>等内容。当基于ROS开发机器人程序时，可以直接引用相应lib。</p><ul><li>标准机器人消息</li><li>机器人几何库</li><li>机器人描述语言</li><li>抢占式远程过程调用</li><li>诊断</li><li>位置估计</li><li>定位导航</li></ul><p><strong>3. 工具集</strong></p><p>工具集只机器人开发过程使用的<strong>辅助工具</strong>，包括：</p><ul><li>常用命令工具</li><li>工程管理工具catkin</li><li>可视化工具是rqt、rviz</li><li>包管理工具</li><li>第三方工具</li></ul><h1 id="ROS系统整体架构"><a href="#ROS系统整体架构" class="headerlink" title="ROS系统整体架构"></a>ROS系统整体架构</h1><h2 id="文件系统架构"><a href="#文件系统架构" class="headerlink" title="文件系统架构"></a>文件系统架构</h2><p>文件系统架构实际上指的是ROS程序开发过程中工作空间的架构。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/ros%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ROS应用在开发过程中使用catkin进行包管理，而catkin的底层是通过CMake工作的。</p><p>catkin目录说明：</p><ul><li>src：放置各个功能包和一个用于这些功能包的CMake配置文件CMakeLists.txt。</li><li>build编译空间：放置CMake和catkin编译功能包时产生的缓存、配置、中间文件等。</li><li>devel开发空间：放置编译好的可执行程序，这些可执行程序是不需要安装就能直接运行的。</li></ul><p>功能包是ROS程序的最小结构，表示一个node。安装完成ROS后所有自带的功能包位于$ROS_PACKAGE_PATH，用户可以自行开发功能包。</p><p>功能包中通常包括下面几个文件：</p><ul><li>CMakeLists.txt：cmake配置文件。</li><li>package.xml：功能包的配置信息，如依赖、名称等。</li><li>include/<package_name>：*.h头文件放在这里。</li><li>msg：非标准消息定义目录，ROS本身已经定义了许多用于node之间通信<a href="http://wiki.ros.org/common_msgs/" target="_blank" rel="noopener">标准消息</a>已经<a href="http://wiki.ros.org/std_msgs/" target="_blank" rel="noopener">标准数据类型</a>。</li><li>srv：服务类型定义目录，ROS中node通信可以通过消息和服务两种方式，消息基于topic订阅，服务则是node之间点对点通信机制。</li><li>scripts：bash、python或其他脚本的可执行文件。</li><li>launch：存放<em>.launch文件，</em>.launch文件用于启动ROS功能包中的一个或多个节点（Ansible？？？）</li><li>src：源码目录</li></ul><h2 id="计算图级架构"><a href="#计算图级架构" class="headerlink" title="计算图级架构"></a>计算图级架构</h2><p>计算图实际上指的是多个node在ROS中构成的网络，所有计算图中的节点可以进行数据交互。</p><p>计算图中包含以下概念：</p><h3 id="1-node"><a href="#1-node" class="headerlink" title="1. node"></a>1. node</h3><p>节点是计算执行进程，功能包中创建的每个可执行程序在被启动加载到系统进程中后，该进程就是一个ROS节点。</p><p>节点都是各自独立的可执行文件，能够通过主题（topic）、服务（server）或参数服务器（parameter server）与其他节点通信。</p><p>节点如果用c++进行编写，需要用到ROS提供的库roscpp；节点如果用python进行编写，需要用到ROS提供的库rospy。</p><h3 id="2-Topic"><a href="#2-Topic" class="headerlink" title="2. Topic"></a>2. Topic</h3><p>node间沟通的方式之一是消息订阅/发布，每个消息都必须发布到相应的主题（topic），通过主题来实现在ROS计算图网络中的路由转发。</p><p>同一个主题可以有多个订阅者也可以有多个发布者。每个主题都是强类型的，不管是发布消息到主题还是从主题中订阅消息，发布者和订阅者定义的消息类型必须与主题的消息类型相匹配。</p><h3 id="3-服务"><a href="#3-服务" class="headerlink" title="3. 服务"></a>3. 服务</h3><p>在一些特殊的场合，节点间需要点对点的高效率通信并及时获取应答，这个时候就需要用服务的方式进行交互。</p><p>服务通信过程中服务的数据类型需要用户自己定义，与消息不同，节点并不提供标准服务类型。服务类型的定义文件都是以*.srv为扩展名，并且被放在功能包的srv/文件夹下。</p><h3 id="4-配置管理器"><a href="#4-配置管理器" class="headerlink" title="4. 配置管理器"></a>4. 配置管理器</h3><p>参数服务器（parameter server）能够使数据通过关键词存储在一个系统的核心位置。通过使用参数，就能够在节点运行时动态配置节点或改变节点的工作任务。参数服务器是可通过网络访问的共享的多变量字典，节点使用此服务器来存储和检索运行时的参数。</p><h3 id="5-节点管理器"><a href="#5-节点管理器" class="headerlink" title="5. 节点管理器"></a>5. 节点管理器</h3><p>节点管理器（master）用于节点的名称注册和查找等，也负责设置节点间的通信。</p><p>由于ROS本身就是一个分布式的网络系统，所以你可以在某台计算机上运行节点管理器，在这台计算机和其他台计算机上运行节点（节点管理器需不需要高可用？？）。</p><p>ROS中提供了跟节点管理器相关的命令行工具，就是roscore，roscore命令用于启动节点管理器，这个命令会加载ROS节点管理器和其他ROS核心组件。</p><p>当ROS开始工作时，用户需要首先执行<strong>roscore</strong>运行一个节点管理器，以此来保证后续启动的node可以正常通信。</p><p>执行roscore的同时，系统会默认启动一个日志node（rosout），执行rosnode可以查看该node的详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rosout启动发布了一个topic（rosout_agg），以及两个服务（get_loggers、set_logger_level）</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Node [/rosout]</span><br><span class="line">Publications: </span><br><span class="line"> * /rosout_agg [rosgraph_msgs/Log]</span><br><span class="line"></span><br><span class="line">Subscriptions: </span><br><span class="line"> * /rosout [unknown type]</span><br><span class="line"></span><br><span class="line">Services: </span><br><span class="line"> * /rosout/get_loggers</span><br><span class="line"> * /rosout/set_logger_level</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contacting node http://ruijie-virtual-machine:39349/ ...</span><br><span class="line">Pid: 31314</span><br></pre></td></tr></table></figure><h2 id="消息文件"><a href="#消息文件" class="headerlink" title="消息文件"></a>消息文件</h2><p>ROS使用消息类型描述语言，描述node之间传递的消息，并可以在不同的编程语言（如c++、python等）书写的程序中使用此消息。</p><p>不管是ROS系统提供的标准类型消息，还是用户自定义的非标准类型消息，定义文件都是以*.msg作为扩展名。</p><p>消息类型的定义分为两个主要部分：字段的数据类型和字段的名称，简单点说就是结构体中的变量类型和变量名称。</p><p>经常用到的类型包括：</p><ul><li><a href="http://wiki.ros.org/std_msgs/" target="_blank" rel="noopener">基本类型</a>：包括int、boolean等基础数据类型。</li><li><a href="http://wiki.ros.org/common_msgs" target="_blank" rel="noopener">通用类型</a>：高级数据类型，如四元数、传感器数据等。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/hiram-zhang/tag/ROS%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SLAM+语音机器人DIY系列</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解ROS的基本框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS环境安装部署</title>
    <link href="https://LinQing2017.github.io/2019/08/07/0-ROS%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>https://LinQing2017.github.io/2019/08/07/0-ROS环境安装部署/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.973Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h1><p>安装Ubuntu 18.04版本操作系统，安装完成后进行以下配置：</p><h3 id="1-配置sudo权限"><a href="#1-配置sudo权限" class="headerlink" title="1. 配置sudo权限"></a>1. 配置sudo权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line">sudo -s</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑/etc/sudoers，添加 ruijie  ALL=(ALL:ALL) ALL</span></span><br></pre></td></tr></table></figure><h3 id="2-安装SSH服务"><a href="#2-安装SSH服务" class="headerlink" title="2. 安装SSH服务"></a>2. 安装SSH服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server net-tools vim</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改sshd_config文件，添加PermitRootLogin yes，注释掉PermitRootLogin prohibit-password</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><h3 id="3-配置远程桌面"><a href="#3-配置远程桌面" class="headerlink" title="3. 配置远程桌面"></a>3. 配置远程桌面</h3><p>Ubuntu 18.04使用官方xRDP时无法正常登陆，参考Goolge上的<a href="http://c-nergy.be/blog/?p=13455" target="_blank" rel="noopener">解决方案</a>安装第三方版本的xRDP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:martinx/xrdp-hwe-18.04</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install xrdp xorg</span><br><span class="line">sudo adduser xrdp ssl-cert</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 /usr/share/polkit-1/actions/org.freedesktop.color.policy（直接删掉）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考：https://c-nergy.be/blog/?p=12073</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h1><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>当前ROS包含两个长期维护版本，分别支持不同版本操作系统。通过 rosdistro 工具，我们可以在系统中安装多个版本的ROS。</p><p>通常ROS发行版的维护周期是5年或者2年，当前仍然在维护周期内的发行版是以下两个，均为5年维护周期。</p><table><thead><tr><th>版本名称</th><th>Release</th><th>EOL</th><th>操作系统</th></tr></thead><tbody><tr><td>Melodic Morenia</td><td>May 23rd, 2018</td><td>May, 2023</td><td>Ubuntu 18.04、Debian、Win10</td></tr><tr><td>Kinetic Kame</td><td>May 23rd, 2016</td><td>April, 2021(Xenial EOL)</td><td>Ubuntu 15.10</br>Ubuntu 16.04</br>Debian 8</td></tr></tbody></table><p><strong>文本选择在Ubuntu 18.04环境中安装，ROS Melodic Morenia。</strong></p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>参考官方文档，通过以下步骤安装ROS Melodic：</p><h3 id="1-部署repositories"><a href="#1-部署repositories" class="headerlink" title="1. 部署repositories"></a>1. 部署repositories</h3><p>ROS除了提供官方仓库以外，在全球范围提供了<a href="http://wiki.ros.org/ROS/Installation/UbuntuMirrors" target="_blank" rel="noopener">镜像仓库</a>，安装过程中为了避免网络问题，同时配置两个国内的仓库地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加官方仓库</span></span><br><span class="line">sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加中科大仓库</span></span><br><span class="line">sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main" &gt;&gt; /etc/apt/sources.list.d/ros-latest.list'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加清华仓库</span></span><br><span class="line">sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main" &gt;&gt; /etc/apt/sources.list.d/ros-latest.list'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加仓库的Key</span></span><br><span class="line">sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><h3 id="2-安装DEB"><a href="#2-安装DEB" class="headerlink" title="2. 安装DEB"></a>2. 安装DEB</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure><p>Ros提供下面几种安装包，本文选择ros-melodic-desktop-full，完整安装所有工具。</p><table><thead><tr><th>DEB包</th><th>包含组件</th><th>说明</th></tr></thead><tbody><tr><td>ros-melodic-desktop-full</td><td>ROS、rqt、rviz</br>robot常用lib</br>2D/3D仿真器传感器</td><td>完整安装</td></tr><tr><td>ros-melodic-desktop</td><td>ROS、rqt、rviz</br>robot常用lib</td><td></td></tr><tr><td>ros-melodic-ros-base</td><td>不包含GUI</td><td></td></tr><tr><td>ros-melodic-PACKAGE</td><td>单个模块</td><td>PACKAGE表示模块名，如ros-melodic-slam-gmapping</td></tr></tbody></table><p>*<em>备注</em>：RViz和rqt均是ROS的可视化工具，</p><h3 id="3-初始化ROS"><a href="#3-初始化ROS" class="headerlink" title="3. 初始化ROS"></a>3. 初始化ROS</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化rosdep仓库</span></span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">echo "source /opt/ros/melodic/setup.bash" &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载依赖</span></span><br><span class="line">sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/ROS/Installation" target="_blank" rel="noopener">ROS安装</a></p><p><a href="http://wiki.ros.org/ROS/Tutorials" target="_blank" rel="noopener">ROS Tutorials</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;操作系统配置&quot;&gt;&lt;a href=&quot;#操作系统配置&quot; class=&quot;headerlink&quot; title=&quot;操作系统配置&quot;&gt;&lt;/a&gt;操作系统配置&lt;/h1&gt;&lt;p&gt;安装Ubuntu 18.04版本操作系统，安装完成后进行以下配置：&lt;/
      
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="Ubuntu" scheme="https://LinQing2017.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>深度学习读书笔记</title>
    <link href="https://LinQing2017.github.io/2019/08/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <id>https://LinQing2017.github.io/2019/08/07/深度学习入门/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>一篇关于《动手学深度学习》的读书笔记。</p><p>电子书地址：<a href="https://zh.gluon.ai/" target="_blank" rel="noopener">https://zh.gluon.ai/</a></p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>《动手学深度学习》基于Apache MXNet提供关于深度学习的Demo，并且提供了配套代码。整个项目通过conda的虚拟环境分发，并提供jupyter方式的可读文档。</p><p>安装方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装Mincode</span></span><br><span class="line">sh Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载工程文件 https://zh.d2l.ai/d2l-zh-1.0.zip ，并且解压到到d2l-zh文件夹</span></span><br><span class="line">unzip d2l-zh-1.0.zip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装d2l-zh项目的环境</span></span><br><span class="line">source ~/.bashrc &amp;&amp; conda env create -f environment.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到项目环境</span></span><br><span class="line">conda activate gluon</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开项目jupyter</span></span><br><span class="line">jupyter notebook --ip=$HOSTNAME --port=9999</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他一些命令</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换pip源</span></span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除pip源，恢复使用默认源</span></span><br><span class="line">pip config unset global.index-url</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置国内MXNet站点的数据仓库</span></span><br><span class="line">set MXNET_GLUON_REPO=https://apache-mxnet.s3.cn-north-1.amazonaws.com.cn/ jupyter notebook</span><br></pre></td></tr></table></figure><h2 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h2><p>Conda是python的软件包管理软件，它和pip的最大不同在于同时提供虚拟环境管理功能，方便用户在多个虚拟环境中切换。</p><p>Miniconda是最小的conda安装环境，其中包含了Python2和Python3的运行环境。</p><p>Anaconda 是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。</p><p>conda常用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> envname 指代你新建的环境的名称</span></span><br><span class="line">conda create --name envname</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除虚拟环境</span></span><br><span class="line">conda remove --name envname --all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定python版本</span></span><br><span class="line">conda create -n envname python=3.4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定python版本,以及多个包</span></span><br><span class="line">conda create -n envname python=3.4 scipy=0.15.0 astroib numpy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 给虚拟环境安装包</span></span><br><span class="line">conda install -n envname scipy=0.15.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从文件创建虚拟环境conda install pytorch torchvision cudatoolkit=9.0 -c pytorch</span></span><br><span class="line">conda env create -f environment.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前环境安装的包</span></span><br><span class="line">conda list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有环境conda install pytorch torchvision cudatoolkit=9.0 -c pytorch</span></span><br><span class="line">conda info --envs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 激活环境</span></span><br><span class="line">conda activate envnameconda install pytorch torchvision cudatoolkit=9.0 -c pytorch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出当前环境</span></span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><p>在MXNet中，NDArray是一个类，也是存储和变换数据的主要工具，提供GPU计算和自动求梯度等多种功能。</p><p>NDArray 和 Numpy 有点类似，但是它可以表示多维张量，通过array函数和asnumpy函数可以使数据在NDArray和NumPy格式之间相互变换。</p><h2 id="自动求梯度"><a href="#自动求梯度" class="headerlink" title="自动求梯度"></a>自动求梯度</h2><p>MXNet使用autograd模块自动求梯度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd,nd</span><br><span class="line">x = nd.arange(<span class="number">4</span>).reshape((<span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line">x.attach_grad() <span class="comment"># 调用attach_grad申请存储梯度所需要的内存</span></span><br><span class="line"><span class="keyword">with</span> autograd.record(): <span class="comment"># 调用record函数后，MXNet会记录并计算梯度。</span></span><br><span class="line">    y = <span class="number">2</span>* nd.dot(x.T,x) <span class="comment"># 目标函数是 y = x_T * x，我们要求这个函数在x = [0,1,2,3]_T时的梯度</span></span><br><span class="line">    y.backward()</span><br><span class="line">    print(x.grad) <span class="comment"># x.grad 就是对应的梯度</span></span><br></pre></td></tr></table></figure><p>参考<a href="https://mxnet.apache.org/api/python/index.html" target="_blank" rel="noopener">mxnet api 查询</a></p><h1 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h1><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>机器学习的几个概念：</p><ul><li>样本集、样本、标签</li><li>模型、模型参数、损失函数</li><li>优化算法：当模型没有解析解时，通过优化算法的有限次迭代求得一个使损失函数最小的数值解。</li><li>学习率、批量大小 ——&gt; 超参数</li><li>模型预测 ~ 推断 ~ 测试</li></ul><p>神经网络的几个概念：</p><ul><li>输入个数 ~ 特征数、特征向量维度</li><li>神经元（计算单元）</li><li>全连接层、稠密层</li></ul><p>神经网络和线性回归的联系：</p><ul><li>线性回归是一个全连接单层神经网络</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="softmax回归"><a href="#softmax回归" class="headerlink" title="softmax回归"></a>softmax回归</h2><p>解决分类问题的思路：</p><ul><li>输出是离散值的分类问题，且输出个数等于标签类别数</li><li>每个输出值是预测该类别的置信度，预测结果取最大输出值对应的类别</li></ul><p>上述思路存在问题：</p><ul><li>输出值的范围不确定，难以直观判断这些值的含义</li></ul><p>SoftMax回归的解决思路：</p><ul><li>将输出值变换成值为正且和为1的概率分布（归一化？？？实际上就是：每个输出求exp(y_i)/所有输出exp(y_i)之和）</li></ul><p>交叉熵损失函数：</p><ul><li>分类问题的label一般这样表示：[1,0,0,0]（四个类别时，分类取值为1）</li><li>分类问题的模型输出表示为：[p1,p2,p3,p4]（四个类别时，表示对应类别0~1之间的概率）</li><li>分类问题不适合使用平方损失函数，适合使用<strong>交叉熵</strong>衡量损失。</li><li>交叉熵损失函数和最大似然估计的思想一致。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E4%BA%A4%E5%8F%89%E7%86%B5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>分类的结果：</p><ul><li>准确率 = 正确预测数量 / 总预测数量</li></ul><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><ul><li><p>不引入激活函数时，<strong>全连接</strong>多层感知机的模型本质上和单层感知机等价的，依然是线性模型。本质上<strong>全连接</strong>等价于<strong>仿射变换（一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。）</strong>，多个<strong>仿射变换</strong>的叠加依然是仿射变换。</p></li><li><p>解决上述问题：隐藏变量使用按元素运算的非线性函数进行变换，这些非线性函数称谓激活函数</p><ul><li>ReLU(x)=max(x,0)</li><li>sigmoid函数：sigmoid(x)=1/(1+exp(−x))</li><li>tanh函数: tanh(x)=(1−exp(−2x))/(1+exp(−2x))</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模型选择、欠拟合、过拟合"><a href="#模型选择、欠拟合、过拟合" class="headerlink" title="模型选择、欠拟合、过拟合"></a>模型选择、欠拟合、过拟合</h2><ul><li><p>当模型在训练数据集上更准确时，它在测试数据集上却不一定更准确：</p><ul><li>训练误差（training error）：模型在训练数据集上表现出的误差</li><li>泛化误差（generalization error）：模型在任意一个测试数据样本上表现出的误差的期望，并常常通过测试数据集上的误差来近似。</li></ul></li><li><p>K折交叉验证：把原始训练数据集分割成K个不重合的子数据集，然后我们做K次模型训练和验证。每一次，我们使用一个子数据集验证模型，并使用其他K−1个子数据集来训练模型。在这K次训练和验证中，每次用来验证模型的子数据集都不同。最后，我们对这K次训练误差和验证误差分别求平均。</p></li><li><p>防止过拟合的方法：</p><ul><li>增大训练量</li><li>使用复杂度合适的模型</li><li>丢弃法：倒置丢弃法，原理是将隐藏层的输出丢弃或者拉伸。</li><li>权重衰减：为模型添加损失函数惩罚项，使学出的模型参数值较小。原因是复杂模型往往权重参数很多，比较复杂。</li></ul></li></ul><p>权重衰减使，如何定义损失函数：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E6%9D%83%E9%87%8D%E8%A1%B0%E5%87%8F%E5%8E%9F%E7%90%86.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="正向传播、反向传播和计算图"><a href="#正向传播、反向传播和计算图" class="headerlink" title="正向传播、反向传播和计算图"></a>正向传播、反向传播和计算图</h2><pre><code>知道是什么东西就好？</code></pre><h2 id="数值稳定性和模型初始化"><a href="#数值稳定性和模型初始化" class="headerlink" title="数值稳定性和模型初始化"></a>数值稳定性和模型初始化</h2><ul><li>数值稳定性：典型问题是衰减和爆炸，当神经网络层数较多时，模型的数值稳定性容易变差；</li><li>通常需要随机初始化神经网络的模型参数，如权重参数。</li></ul><h2 id="kaggle赛题"><a href="#kaggle赛题" class="headerlink" title="kaggle赛题"></a>kaggle赛题</h2><p><a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/leaderboard" target="_blank" rel="noopener">房价预测</a>，通过观摩别人的解题过程发现，大致流程如下：</p><ul><li>理解问题：理解数据的规模、指标的含义、数据有哪些确实等等。</li><li>单因素研究：关注单一变量（如，输出）作图，并分析</li><li>多因素研究：分析因变量和自变量之间的关系。</li><li>基础清洗：清洗数据集并且对缺失数据，异常值和分类数据进行一些处理。</li><li>检验假设：检查数据是否和多元分析方法的假设达到一致。</li><li>建立模型，训练，预测<h1 id="MXNet-常用API接口"><a href="#MXNet-常用API接口" class="headerlink" title="MXNet 常用API接口"></a>MXNet 常用API接口</h1></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个神经网络模型，定义若干层隐藏层，并且指定隐藏层的激活类型， Dense表示定义一个全连接层。</span></span><br><span class="line"></span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    net.add(</span><br><span class="line">        nn.Dense(<span class="number">1024</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        nn.Dense(<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    net.initialize(init.Normal(sigma=<span class="number">0.01</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> loss <span class="keyword">as</span> gloss</span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss = gloss.L2Loss()                   <span class="comment"># 均方根损失</span></span><br><span class="line">loss = gloss.SoftmaxCrossEntropyLoss()  <span class="comment"># 交叉熵损失</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, gluon, init, nd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(net, train_features, train_labels, test_features, test_labels,</span></span></span><br><span class="line"><span class="function"><span class="params">          num_epochs, learning_rate, weight_decay, batch_size)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        训练函数</span></span><br><span class="line"><span class="string">    :param net               :模型        </span></span><br><span class="line"><span class="string">    :param train_features    :训练集的特征</span></span><br><span class="line"><span class="string">    :param train_labels      :训练集的标签</span></span><br><span class="line"><span class="string">    :param test_features     :测试集的特征</span></span><br><span class="line"><span class="string">    :param test_labels       :测试集的标签</span></span><br><span class="line"><span class="string">    :param num_epochs        :在训练集上的训练次数，每次训练由多个小批量样本迭代组成</span></span><br><span class="line"><span class="string">    :param learning_rate     :每次迭代的学习率</span></span><br><span class="line"><span class="string">    :param weight_decay      :权重衰减系数，防止过拟合</span></span><br><span class="line"><span class="string">    :param batch_size        :小批量样本迭代中的样本数目</span></span><br><span class="line"><span class="string">    :return                  :输出结果，即训练误差和测试误差（验证误差）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = gdata.DataLoader(  <span class="comment"># 将训练集进行随机小批量分割</span></span><br><span class="line">        gdata.ArrayDataset(train_features, train_labels),</span><br><span class="line">        batch_size,</span><br><span class="line">        shuffle=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    trainer = gluon.Trainer(        <span class="comment"># 使用一个trainer，'adam'表示学习迭代的方法，同样还有sgd</span></span><br><span class="line">        net.collect_params(),</span><br><span class="line">        <span class="string">'adam'</span>,</span><br><span class="line">        &#123;<span class="string">'learning_rate'</span>: learning_rate, <span class="string">'wd'</span>: weight_decay&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="keyword">with</span> autograd.record():</span><br><span class="line">                l = loss(net(X), y)     <span class="comment"># 求损失函数函数</span></span><br><span class="line">            l.backward()                <span class="comment"># 对损失函数的每个变量求偏导</span></span><br><span class="line">            trainer.step(batch_size)    <span class="comment"># 进行模型计算</span></span><br><span class="line">        train_ls.append(loss(net, train_features, train_labels)) </span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(loss(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br></pre></td></tr></table></figure><h1 id="一些数据集"><a href="#一些数据集" class="headerlink" title="一些数据集"></a>一些数据集</h1><p>[MNIST]：手写数字识别数据集</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇关于《动手学深度学习》的读书笔记。&lt;/p&gt;
&lt;p&gt;电子书地址：&lt;a href=&quot;https://zh.gluon.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.gluon.ai/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://LinQing2017.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="https://LinQing2017.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus Alarm</title>
    <link href="https://LinQing2017.github.io/2019/07/30/2-Prometheus/"/>
    <id>https://LinQing2017.github.io/2019/07/30/2-Prometheus/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.973Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus 调研</p><a id="more"></a><h1 id="Prometheus告警"><a href="#Prometheus告警" class="headerlink" title="Prometheus告警"></a>Prometheus告警</h1><p>告警能力在Prometheus的架构中被划分成两个独立的部分：告警规则(产生告警),告警处理。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBdoxo9EmQ0bJP2BuUi%2F-LVMF4RtPS-2rjW9R-hG%2F-LPS9QhUbi37E1ZK8mXF%2Fprometheus-alert-artich.png?generation=1546578333144123&alt=media" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>告警规则：通过在Prometheus中定义AlertRule（告警规则），Prometheus会周期性的对告警规则进行计算，如果满足告警触发条件就会向Alertmanager发送告警信息。</li><li>告警处理：</li></ul><h2 id="告警规则"><a href="#告警规则" class="headerlink" title="告警规则"></a>告警规则</h2><p>一条告警规则，包括以下几个部分：</p><ul><li>告警名称：告警规则命名</li><li>告警规则：主要由PromQL进行定义，其实际意义为当表达式（PromQL）查询结果持续多长时间（During）后出发告警</li><li>告警组：对一组相关的告警进行统一定义，并通过YAML文件来统一管理。</li></ul><p>典型告警规则定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">HighErrorRate</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">job:request_latency_seconds:mean5m&#123;job="myjob"&#125;</span> <span class="string">&gt; 0.5 # 对Prometheus来说，产生的告警条数由PromQL返回的调数决定，返回几个采样值对应就产生几个告警。</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">10</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">page</span>  <span class="comment"># 附加到告警信息上的标签，可以添加额外的标签</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">High</span> <span class="string">request</span> <span class="string">latency</span> <span class="comment">#描述告警的概要信息</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">description</span> <span class="string">info</span> <span class="comment">#描述告警的详细信息</span></span><br></pre></td></tr></table></figure><p>上述告警规则中，summary和description的值可以使用模板化的值，如$labels.&lt;labelname&gt;变量可以访问当前告警实例中指定标签的值，$value则可以获取当前PromQL表达式计算的样本值</p><p>在Prometheus全局配置文件中通过rule_files指定一组告警规则文件的访问路径，Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知。默认情况下Prometheus会每分钟对这些告警规则进行计算。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">evaluation_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 1m ]</span></span><br></pre></td></tr></table></figure><h2 id="Alertmanager"><a href="#Alertmanager" class="headerlink" title="Alertmanager"></a>Alertmanager</h2><p>Alertmanager是一个独立的组件，负责接收并处理来自Prometheus Server(也可以是其它的客户端程序)的告警信息。<br>Alertmanager的安装部署和Prometheus类似，只包含一个可执行文件，以及对应的配置文件alertmanager.yml。</p><p>alertmanager.yml包括：global、templates、route、receivers、inhibit_rules这几个部分，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span> <span class="comment">#用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容；</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">resolve_timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 5m ] # 该参数表示持续多长时间未接收到告警后标记告警状态为resolved</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"></span><span class="attr">templates:</span> <span class="comment"># 定义告警通知时的模板，如HTML模板，邮件模板等；</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">route:</span> <span class="string">&lt;route&gt;</span> <span class="comment"># 告警路由配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">receivers:</span>  <span class="comment"># 告警接收者，即邮箱、微信等</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">&lt;receiver&gt;</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inhibit_rules:</span> <span class="comment"># 告警的抑制规则</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;inhibit_rule&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Router配置"><a href="#Router配置" class="headerlink" title="Router配置"></a>Router配置</h3><p>上面配置文件中最关键的配置项是route和receivers，两者一一对应构成告警信息的路由拓扑网络。</p><p>所有告警在Alertmanager中从根route进入，并匹配当前节点的子route，直到找到一个最深的匹配点，并将告警信息发送个该匹配点的receivers。</p><p>Alertmanager可以对告警通知进行分组，将多条告警合合并为一个。配置文件中可以使用group_by来定义分组规则，基于告警中包含的标签，如果满足group_by中定义标签名称，那么这些告警将会合并为一个通知发送给接收器。</p><p>route 的配置模板如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">receiver:</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># 当前route节点的receivers</span></span><br><span class="line"><span class="attr">  group_by:</span> <span class="string">'['</span> <span class="string">&lt;labelname&gt;,</span> <span class="string">...</span> <span class="string">']'</span> <span class="string">]</span> <span class="comment"># 告警分组，依据选择的label，将label取值相同的告警合并</span></span><br><span class="line"><span class="string">[</span> <span class="attr">continue:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">| default = false ] # 告警在匹配到第一个子节点是否停止</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span><span class="attr">match:</span>      <span class="comment"># 通过label值判断匹配</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">match_re:</span>   <span class="comment"># 通过label值的re表达判断匹配</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;regex&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="string">[</span> <span class="attr">group_wait:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 30s ]      # 如果在等待时间内当前group接收到了新的告警，这些告警将会合并为一个通知向receiver发送。</span></span><br><span class="line"><span class="string">[ group_interval: &lt;duration&gt; | default = 5m ]   # 定义相同的Gourp之间发送告警通知的时间间隔</span></span><br><span class="line"><span class="string">[ repeat_interval: &lt;duration&gt; | default = 4h ]  # 表示重复发送告警的时间</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span><span class="attr">routes:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;route&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Receiver配置"><a href="#Receiver配置" class="headerlink" title="Receiver配置"></a>Receiver配置</h3><p>当前官方内置的第三方receiver包括：邮件、即时通讯软件（如Slack、Hipchat）、移动应用消息推送(如Pushover)和自动化运维工具（例如：Pagerduty、Opsgenie、Victorops）以及Webhook。</p><p>下面的配置信息，展示了Alertmanager对接了企业微信的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否接受告警已处理消息消息</span></span><br><span class="line"><span class="string">[</span> <span class="attr">send_resolved:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">| default = false ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 企业微信使用的api_secret</span></span><br><span class="line"><span class="string">[ api_secret: &lt;secret&gt; | default = global.wechat_api_secret ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 企业微信的api_url地址</span></span><br><span class="line"><span class="string">[ api_url: &lt;string&gt; | default = global.wechat_api_url ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 企业微信企业id</span></span><br><span class="line"><span class="string">[ corp_id: &lt;string&gt; | default = global.wechat_api_corp_id ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 告警信息文本</span></span><br><span class="line"><span class="string">[ message: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "wechat.default.message" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string"># 告警应用id</span></span><br><span class="line"><span class="string">[ agent_id: &lt;string&gt; | default = '<span class="template-variable">&#123;&#123; template "wechat.default.agent_id" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string"># 接收告警的用户、组织、tag（三选一即可）</span></span><br><span class="line"><span class="string">[ to_user: &lt;string&gt; | default = '<span class="template-variable">&#123;&#123; template "wechat.default.to_user" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string">[ to_party: &lt;string&gt; | default = '<span class="template-variable">&#123;&#123; template "wechat.default.to_party" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string">[ to_tag: &lt;string&gt; | default = '<span class="template-variable">&#123;&#123; template "wechat.default.to_tag" . &#125;&#125;</span>' ]</span></span><br></pre></td></tr></table></figure><h3 id="告警抑制"><a href="#告警抑制" class="headerlink" title="告警抑制"></a>告警抑制</h3><p>告警抑制配置模板如下，当满足一下三个条件时：</p><ul><li>已发送的告警匹配到target_match和target_match_re规则</li><li>新的告警匹配到source_match或者source_match_re规则</li><li>发送的告警与新产生的告警中equal定义的标签完全相同</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">target_match:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">target_match_re:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;regex&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">source_match:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">source_match_re:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;regex&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="string">[</span> <span class="attr">equal:</span> <span class="string">'['</span> <span class="string">&lt;labelname&gt;,</span> <span class="string">...</span> <span class="string">']'</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>通过Alertmanager的UI临时屏蔽特定的告警通知。</p><p>通过定义标签的匹配规则(字符串或者正则表达式)，如果新的告警通知满足静默规则的设置，则不停止向receiver发送通知。</p><p>临时静默可以配置持续时间</p><h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><p>alertmanager对接wechat配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  resolve_timeout:</span> <span class="number">10</span><span class="string">m</span></span><br><span class="line"><span class="attr">  wechat_api_url:</span> <span class="string">'https://qyapi.weixin.qq.com/cgi-bin/'</span></span><br><span class="line"><span class="attr">  wechat_api_corp_id:</span> <span class="string">'xxxx'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">templates:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'/opt/alertmanager/templates/*.tmpl'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inhibit_rules:</span></span><br><span class="line"><span class="attr">- source_match:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="attr">  receiver:</span> <span class="string">'wechat'</span></span><br><span class="line"><span class="attr">  group_by:</span> <span class="string">['alertname']</span></span><br><span class="line"><span class="attr">  group_wait:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"><span class="attr">  group_interval:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"><span class="attr">  repeat_interval:</span> <span class="number">12</span><span class="string">h</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">  - receiver:</span> <span class="string">'wechat'</span></span><br><span class="line"><span class="attr">    group_by:</span> <span class="string">['alertname','cluster']</span></span><br><span class="line"><span class="attr">    match:</span></span><br><span class="line"><span class="attr">      job:</span> <span class="string">idata</span></span><br><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">'wechat'</span></span><br><span class="line"><span class="attr">  wechat_configs:</span></span><br><span class="line"><span class="attr">  - send_resolved:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    to_user:</span> <span class="string">'LinQing'</span></span><br><span class="line"><span class="attr">    message:</span> <span class="string">'<span class="template-variable">&#123;&#123; template "wechat.default.message" . &#125;&#125;</span>'</span></span><br><span class="line"><span class="attr">    agent_id:</span> <span class="string">'1000002'</span></span><br><span class="line"><span class="attr">    api_secret:</span> <span class="string">'xxxx'</span></span><br></pre></td></tr></table></figure><p>微信告警模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;wechat.default.message&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len .Alerts.Firing) 0 -&#125;&#125;</span><br><span class="line">&#123;&#123;- range $index, $alert := .Alerts -&#125;&#125;</span><br><span class="line">&#123;&#123;- if eq $index 0 -&#125;&#125;</span><br><span class="line">告警类型: &#123;&#123; $alert.Labels.alertname &#125;&#125;</span><br><span class="line">=====================</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">故障时间: &#123;&#123; $alert.StartsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.instance) 0 &#125;&#125;instance: &#123;&#123; $alert.Labels.instance &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.cluster) 0 &#125;&#125;cluster: &#123;&#123; $alert.Labels.cluster &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.node) 0 &#125;&#125;node: &#123;&#123; $alert.Labels.node &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- if gt (len .Alerts.Resolved) 0 -&#125;&#125;</span><br><span class="line">&#123;&#123;- range $index, $alert := .Alerts -&#125;&#125;</span><br><span class="line">&#123;&#123;- if eq $index 0 -&#125;&#125;</span><br><span class="line">告警类型: &#123;&#123; $alert.Labels.alertname &#125;&#125;</span><br><span class="line">=====================</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">故障时间: &#123;&#123; $alert.StartsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;</span><br><span class="line">恢复时间: &#123;&#123; $alert.EndsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.instance) 0 &#125;&#125;instance: &#123;&#123; $alert.Labels.instance &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.cluster) 0 &#125;&#125;cluster: &#123;&#123; $alert.Labels.cluster &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.node) 0 &#125;&#125;node: &#123;&#123; $alert.Labels.node &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="Recoding-Rules优化"><a href="#Recoding-Rules优化" class="headerlink" title="Recoding Rules优化"></a>Recoding Rules优化</h2><p>通过PromQL可以实时对Prometheus中采集到的样本数据进行查询，聚合以及其它各种运算操作。</p><p>而在某些PromQL较为复杂且计算量较大时，直接使用PromQL可能会导致Prometheus响应超时的情况。</p><p>这时需要一种能够类似于后台批处理的机制能够在后台完成这些复杂运算的计算，对于使用者而言只需要查询这些运算结果即可。</p><p>Prometheus通过Recoding Rule规则支持这种后台计算的方式，可以实现对复杂查询的性能优化，提高查询效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prometheus 调研&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Prometheus" scheme="https://LinQing2017.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus API</title>
    <link href="https://LinQing2017.github.io/2019/07/22/1-Prometheus/"/>
    <id>https://LinQing2017.github.io/2019/07/22/1-Prometheus/</id>
    <published>2019-07-22T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.973Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus 调研</p><a id="more"></a><h1 id="Client-API"><a href="#Client-API" class="headerlink" title="Client API"></a>Client API</h1><p>核心对象：</p><ul><li>Collector：收集器，根据Metrics的类型</li><li>CollectorRegistry：Collector在其中进行注册</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> prometheus_client <span class="keyword">import</span> start_http_server, Summary</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个Summary类型的指标，Summary是一个Collector对象;</span></span><br><span class="line"><span class="string">    1. 第一个参数是metric的name</span></span><br><span class="line"><span class="string">    2. 第二个参数是metric的Help信息</span></span><br><span class="line"><span class="string">    3. 第三个参数是指标的label名称</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">REQUEST_TIME = Summary(<span class="string">'request_processing_seconds'</span>, <span class="string">'Time spent processing request'</span>, [<span class="string">"program"</span>])</span><br><span class="line">REQUEST_TIME_WITH_LABEL = REQUEST_TIME.labels(program=<span class="string">"Test"</span>) <span class="comment"># 在指定的label上赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过装饰器的方式对process_request的执行时间进行采样</span></span><br><span class="line"><span class="meta">@REQUEST_TIME_WITH_LABEL.time()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="string">"""A dummy function that takes some time."""</span></span><br><span class="line">    time.sleep(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建http服务，将metric暴露给采集器</span></span><br><span class="line">    start_http_server(<span class="number">6789</span>)</span><br><span class="line">    <span class="comment"># Generate some requests.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        process_request(random.random())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> prometheus_client <span class="keyword">import</span> start_http_server, Gauge, CollectorRegistry, push_to_gateway</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控指标需要添加的Label</span></span><br><span class="line">LABELS = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要进行监控的指标</span></span><br><span class="line">SERVICE_MAP = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Metrics_MAP</span></span><br><span class="line">Metrics_MAP = &#123;&#125;</span><br><span class="line">Registry = CollectorRegistry()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_metric</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    初始化量测值</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> SERVICE_MAP.keys():</span><br><span class="line">        gauge_metric = Gauge(<span class="string">"memory_usage_"</span> + key.lower(), key + <span class="string">" service use memory"</span>, set(LABELS.keys()),registry=Registry)</span><br><span class="line">        Metrics_MAP.update(&#123;key: gauge_metric&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_metric</span><span class="params">(sample)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    更新测量值</span></span><br><span class="line"><span class="string">    :param sample:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> sample.keys():</span><br><span class="line">        gauge_metric = Metrics_MAP.get(key)</span><br><span class="line">        gauge_metric.labels(**LABELS).set(sample[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    init_metric()</span><br><span class="line">    <span class="keyword">if</span> exporter_config.get(<span class="string">"http_endpoint"</span>):</span><br><span class="line"><span class="comment"># 创建一个http服务暴露采样信息</span></span><br><span class="line">        start_http_server(exporter_config.get(<span class="string">"http_port"</span>), registry=Registry)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sample = metric() <span class="comment"># metric()获取采样值</span></span><br><span class="line">        update_metric(sample=sample)</span><br><span class="line">        time.sleep(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> exporter_config.get(<span class="string">"push"</span>):</span><br><span class="line"><span class="comment"># Gateway发送采样信息</span></span><br><span class="line">        push_to_gateway(exporter_config.get(<span class="string">"gateway"</span>),</span><br><span class="line">            job=exporter_config.get(<span class="string">"job"</span>),</span><br><span class="line">            grouping_key=LABELS,</span><br><span class="line">            registry=Registry)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="Push-Gateway"><a href="#Push-Gateway" class="headerlink" title="Push Gateway"></a>Push Gateway</h1><p>Push Gateway的主要用于Batch Job、网络隔离等场景的数据采集。</p><ul><li>Gateway不会Cache目标的采样数据，只是将即时数据暴露给prometheus，可以将最近一次的采样数据保存到文件中，用来在Gateway重启时恢复数据。</li><li>对于一些分布式计数的需求GateWay无法实现（可以使用<a href="https://github.com/weaveworks/prom-aggregation-gateway" target="_blank" rel="noopener">weaveworks/prom-aggregation-gateway</a>）。</li><li>Gateway 没有实现TimeOut或者TTL机制。</li></ul><p>Gateway 中采样的URL地址和label地址相关，格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;IP&#125;:&#123;Port&#125;/job/&#123;job_name&#125;/instance/&#123;instance_value&#125;/&#123;label_1&#125;/&#123;value_1&#125;/...</span><br></pre></td></tr></table></figure><p>label相同的采样被合并为一个Group。</p><h2 id="timestamps"><a href="#timestamps" class="headerlink" title="timestamps"></a>timestamps</h2><p>使用Gateway时，metrics中的timestamps会产生歧义，即：Client推送到Gateway的时间和Prometheus从Gateway获得sample的时间。</p><p>当Prometheus超过5min无法从target获取采样数据或者得到新采样（只时间变动的采样）时，认为target出现故障或者不存在。为了避免上述问题，Prometheus从Gateway得到的采样信息，以实际抓取的时间为timestamp，而push时间被保存在一个独立的metric中（push_time_seconds ）。</p><h2 id="Job-和-instance-标签"><a href="#Job-和-instance-标签" class="headerlink" title="Job 和 instance 标签"></a>Job 和 instance 标签</h2><p>当prometheus从gateway中获取数据时会将sample中的job和instance标签配置为Gateway服务对应的值，因此需要在配置honor_labels为true。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用curl发送采样到gateway</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送一个untyped类型的采样，对应到的Group为&#123;job=<span class="string">"some_job"</span>&#125;</span></span><br><span class="line">echo "some_metric 3.14" | curl --data-binary @- http://pushgateway.example.org:9091/metrics/job/some_job</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送两个采样到gateway，Group为&#123;job=<span class="string">"some_job"</span>,instance=<span class="string">"some_instance"</span>&#125;</span></span><br><span class="line">  cat &lt;&lt;EOF | curl --data-binary @- http://pushgateway.example.org:9091/metrics/job/some_job/instance/some_instance</span><br><span class="line"><span class="meta">  #</span><span class="bash"> TYPE some_metric counter</span></span><br><span class="line">  some_metric&#123;label="val1"&#125; 42</span><br><span class="line"><span class="meta">  #</span><span class="bash"> TYPE another_metric gauge</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> HELP another_metric Just an example.</span></span><br><span class="line">  another_metric 2398.283</span><br><span class="line">  EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定group</span></span><br><span class="line"></span><br><span class="line">curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job/instance/some_instance</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://prometheus.github.io/client_java/io/prometheus/client/exporter/PushGateway.html" target="_blank" rel="noopener">Pushgateway Java API</a></p><p><a href="https://github.com/prometheus/client_python#exporting-to-a-pushgateway" target="_blank" rel="noopener">Pushgateway Python API</a></p><p><a href="https://prometheus.io/docs/instrumenting/pushing/" target="_blank" rel="noopener">Pushgateway Go API</a></p><p><a href="https://github.com/prometheus/client_ruby#pushgateway" target="_blank" rel="noopener">Pushgateway Ruby API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prometheus 调研&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Prometheus" scheme="https://LinQing2017.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- Prometheus</title>
    <link href="https://LinQing2017.github.io/2019/07/15/0-Prometheus/"/>
    <id>https://LinQing2017.github.io/2019/07/15/0-Prometheus/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-10-29T07:33:55.973Z</updated>
    
    <content type="html"><![CDATA[<p>数据库调研笔记 – Prometheus</p><a id="more"></a><h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><p>Prometheus 是SoundCloud公司开源的一款监控框架，提供包括：告警工具、时序数据库、图表展示等功能，主要包括以下Feature：</p><ul><li>支持PromQL来查询数据</li><li>支持多维时间序列数据存储</li><li>集群不依赖共享存储，单个服务器节点是自治的</li><li>支持Pull、Push（通过gateway组件）两种方式获取数据</li><li>支持动态发现的模式配置服务</li><li>高效：单一实例可以处理百万个监控指标、每秒处理数十万的数据点</li></ul><p>Prometheus主要包括： </p><ul><li>Prometheus server：提供TSD能力，以及Pull数据的能力，以及基于PromQL的查询</li><li>client libraries：多种语言的客户端接口</li><li>Push gateway：数据网关，服务将数据Push到gateway，Server从gateway pull数据</li><li>exporters：Exporter将监控数据采集的端点通过HTTP服务的形式暴露给Prometheus Server。一些符本身及支持Prometheus，因此这些服务天生就是exporters，此外还有的exporters以插件的形式被安装到client端。</li><li>alertmanager：告警模块</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://prometheus.io/assets/architecture.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h2><p>Prometheus的数据模型基于time series， 由一个Metric名称和若干labels构成，表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;**</span><br></pre></td></tr></table></figure><p>Prometheus 基于time series存储数据，并且可能会因查询而生成临时派生时间序列。</p><h2 id="Time-Series"><a href="#Time-Series" class="headerlink" title="Time-Series"></a>Time-Series</h2><p>Time-Series由若干样本组成，每个Sample包含以下三个部分：</p><ul><li>指标（metric）：metric name + 描述当前样本特征的labelsets</li><li>时间戳（timestamp）：一个精确到毫秒的时间戳</li><li>样本值（value）：一个folat64的浮点型数据表示当前样本的值</li></ul><p>以下几点可以注意：</p><ul><li>metric name实际上是一个特殊的label，名称为<strong>name</strong>，以“__”作为前缀的标签是系统内置标签</li><li>形式上所有metric格式为：&lt;\metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, …}</li><li>一个Time-Series包含多个metric</li></ul><h2 id="Metric-Types"><a href="#Metric-Types" class="headerlink" title="Metric Types"></a>Metric Types</h2><p>Prometheus当前只支持四种数据类型，并且在不同的API中稍有区别：</p><ul><li>Counter：只增不减的计数器，只能在重启时将其设置为0</li><li>Gauge：常规测量值类型</li><li>Histogram：直方图统计类型</li><li>Summary：类似Histogram，区别<a href="https://prometheus.io/docs/practices/histograms/" target="_blank" rel="noopener">参考</a></li></ul><p>Histogram 和 Summary 本质上都是统计指标，不会保存原始数据。</p><h3 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h3><p>Histogram 指标对每个采样点进行统计，并根据bucket将数据划分到不同区域。</p><p>假设bucket配置为[1,5,10], Prometheus观察到的数据被划分到[0,1],[1,5],[5,10]，[5,+inf] 四个不同的区间。</p><p>对每个Histogram 可以获取以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[basename]_bucket&#123;le=“1”&#125; # 观测小于1的次数</span><br><span class="line">[basename]_bucket&#123;le=“5”&#125;   # 观测小于5的次数</span><br><span class="line">[basename]_bucket&#123;le=“10”&#125;   # 观测小于10的次数</span><br><span class="line">[basename]_count         # 所有观测值的个数</span><br><span class="line">[basename]_sum   # 所有观测值之和</span><br></pre></td></tr></table></figure><p>Prometheus 只会存储每个区间内观测值的个数，并且histogram_quantile使用分段线性近似的方式绘制分布曲线。</p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>summary是精度更高的直方图测量，可以获取以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. [basename]&#123;quantile=&quot;φ&quot;&#125; (0 ≤ φ ≤ 1) # 获取百分之φ数据的最小值，基于第三方库perk</span><br><span class="line">2. [basename]_sum   #指所有观察值的总和</span><br><span class="line">3. [basename]_count #指已观察到的事件计数值</span><br></pre></td></tr></table></figure><h2 id="JOBS-AND-INSTANCES"><a href="#JOBS-AND-INSTANCES" class="headerlink" title="JOBS AND INSTANCES"></a>JOBS AND INSTANCES</h2><p> Instances 表示能够pull到数据的一个endpoint通过 Host:Port 表示，多个类型一致 Instances 组成 job。</p><p> 在Prometheus拉取数据时，会自动为time series添加job和instance的名称到labels，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: api-server</span><br><span class="line">instance 1: 1.2.3.4:5670</span><br><span class="line">instance 2: 1.2.3.4:5671</span><br><span class="line">instance 3: 5.6.7.8:5670</span><br><span class="line">instance 4: 5.6.7.8:5671</span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://prometheus.io/docs/prometheus/latest/installation/" target="_blank" rel="noopener">官方</a>提供了包括：二进制安装包、Docker、Ansible等多种安装方式。</p><p><a href="https://prometheus.io/docs/instrumenting/exporters/" target="_blank" rel="noopener">Exporters</a></p><p>Prometheus 使用命令行和配置文件指定服务的配置项，其中：</p><ul><li>命令行参数：指定数据目录、memory配置等服务配置，使用./prometheus -h可以查看相关配置。</li><li>配置文件：配置文件基于yaml格式，用于指定jobs、instances、rules，启动时通过–config.file指定配置文件，官方提供配置项有<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#configuration-file" target="_blank" rel="noopener">详细说明</a>，以及<a href="https://prometheus.io/docs/prometheus/latest/configuration/template_examples/" target="_blank" rel="noopener">模板</a>。</li></ul><p>Prometheus支持动态刷新配置，用户可以通过向进程发送 SIGHUP 或者 HTTP POST 方式重载配置项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行配置文件动态刷新</span><br><span class="line"></span><br><span class="line">kill -HUP &#123;pid&#125;</span><br><span class="line">curl -X POST http://localhost:9090/-/reload</span><br></pre></td></tr></table></figure><p>比较关键的启动配置包括：</p><ul><li>storage.tsdb.path：决定数据目录的存储位置</li><li>config.file：读取的配置文件位置</li></ul><h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>官方网站的QuickStart展示了使用Node Exporter采集主机数据的例子。</p><p>Node Exporter是Golang编写，主机系统测量值采集工具，不存在任何的第三方依赖，只需要<a href="https://github.com/prometheus/node_exporter" target="_blank" rel="noopener">下载</a>后即可直接运行。</p><p>主机启动Node Exporter命令后，会在 9100 端口暴露采集到的监控数据，每次metrics请求会返回多个指标，其格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">PS:每个指标的开头包含HELP和TYPE两行，HELP解释指标的内容、TYPE解释指标的类型</span></span><br><span class="line"><span class="meta">#</span><span class="bash">PS:每个指标&#123;&#125;中的内容是lable信息，</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP node_cpu Seconds the cpus spent <span class="keyword">in</span> each mode. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE node_cpu counter</span></span><br><span class="line">node_cpu&#123;cpu="cpu0",mode="idle"&#125; 362812.7890625</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP node_load1 1m load average.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE node_load1 gauge</span></span><br><span class="line">node_load1 3.0703125</span><br></pre></td></tr></table></figure><p>以下配置文件中，包含了两个job：prometheus是服务自身的监控，node是我们定义的主机运行情况监控，共包含三个instance。</p><p>重启prometheus后，在console页面执行up函数可以看到每个instance的运行情况（1表示正在运行）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">15</span><span class="string">s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line"><span class="attr">  evaluation_interval:</span> <span class="number">15</span><span class="string">s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">1</span><span class="string">s</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['bdnode1:9100','bdnode2:9100','bdnode3:9100']</span></span><br></pre></td></tr></table></figure><h1 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h1><h2 id="查询时间序列"><a href="#查询时间序列" class="headerlink" title="查询时间序列"></a>查询时间序列</h2><p>查询时间序列的基本格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metric_name&#123;label_name OP label_value, ...&#125;[duration] offset offset time</span><br></pre></td></tr></table></figure><ul><li>OP可以支持完全匹配、正则匹配，允许以下符号：=、!=、=<del>、!</del></li><li>duration表示访问指定时间范围的数据，尺度为s、m、h、d、w、y</li><li>offset表示从当前时间向前位移</li></ul><h2 id="聚合、操作符运算"><a href="#聚合、操作符运算" class="headerlink" title="聚合、操作符运算"></a>聚合、操作符运算</h2><p>Prometheus支持对序列进行聚合、以及运算符操作。</p><h3 id="运算符操作"><a href="#运算符操作" class="headerlink" title="运算符操作"></a>运算符操作</h3><p>运算符操作包括：数学运算符，逻辑运算符，布尔运算符。</p><p>运算符的操作对象包括：序列、标量</p><ul><li>数学运算符：+、-、*、/、%、^</li><li>布尔运算符：=、！=、&gt;、&lt;、&gt;=、&lt;= 将过滤掉不满足条件的采样，这些运算符用bool修饰之后，不会进行采样过滤，而是返回0或1</li><li>逻辑运算符：and、or、unless 根据情况产生两个时间序列的交集、并集、补集</li></ul><p>需要注意的是：</p><ul><li>操作符之间存在优先级</li><li>序列的运算遵循匹配规则：<ul><li>标签完全一致的元素之间进行计算，没找到匹配元素，则直接丢弃。</li><li>通过on、ignoreing可以限定匹配的标签、或者忽略特定标签。</li><li>当出现一对多、一对一匹配时，可以通过group运算符使唯一值被匹配多次。</li></ul></li></ul><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br><span class="line"></span><br><span class="line"># without：表示排除特定标签</span><br><span class="line"># by：只考虑特定标签</span><br></pre></td></tr></table></figure><p>支持的聚合函数包括：</p><ul><li>sum (求和)</li><li>min (最小值)</li><li>max (最大值)</li><li>avg (平均值)</li><li>stddev (标准差)</li><li>stdvar (标准差异)</li><li>count (计数)</li><li>count_values (对value进行计数)</li><li>bottomk (后n条时序)</li><li>topk (前n条时序)</li><li>quantile (分布统计)</li></ul><h3 id="其他内置函数"><a href="#其他内置函数" class="headerlink" title="其他内置函数"></a>其他内置函数</h3><ul><li>increase(v range-vector)：返回区间的增长量</li><li>rate(v range-vector)：返回区间的平均增长率</li><li>irate(v range-vector)：返回区间的瞬时增长率</li><li>predict_linear(v range-vector, t scalar)：基于简单线性回归，预测序列在t秒后的值</li><li>histogram_quantile(0.5, http_request_duration_seconds_bucket)：计算histogram的分位数值</li><li>label_replace：动态替换标签</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;instance="bdnode3:9100"&#125;                           # 返回节点3的所有量测信息</span><br><span class="line">node_hwmon_temp_celsius                             # 查询所有CPU核心的温度</span><br><span class="line">node_hwmon_temp_celsius&#123;chip="platform_coretemp_0"&#125; #所有节点CPU0上的核心温度</span><br><span class="line">node_hwmon_temp_celsius&#123;chip="platform_coretemp_0",instance="bdnode3:9100"&#125;[10s] offset 30s                  # 之前40s到30s的温度数据</span><br><span class="line">avg(node_hwmon_temp_celsius&#123;chip=~"platform_coretemp_[0-9]*" &#125;) by (instance)         #查询每个节点CPU的平均温度</span><br><span class="line">avg(node_hwmon_temp_celsius&#123;chip=~"platform_coretemp_[0-9]*" &#125;) by (instance,chip) #查询每个节点的所有CPU的平均温度</span><br></pre></td></tr></table></figure><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>对于本地存储，Prometheus 2.x 采用自定义的存储格式将样本数据保存在本地磁盘当中。</p><p>Prometheus按照两个小时为一个时间窗口，将两小时内产生的数据存储在一个块(Block)中，每一个块中包含该时间窗口内的所有样本数据(chunks)，元数据文件(meta.json)以及索引文件(index)。</p><p>写入数据时，Prometheus先写内存，并且通过WAL进行重播进行数据会，API对数据删除同样通过tombstone进行标记删除。</p><p>Prometheus或周期合并时间窗内的数据，并删除垃圾数据。</p><h3 id="远程存储"><a href="#远程存储" class="headerlink" title="远程存储"></a>远程存储</h3><p>远程存储的目的是要使Prometheus<strong>存储大量历史数据</strong>、以及进行<strong>灵活扩展</strong>和<strong>迁移</strong>。</p><p>通过remote_write/remote_read，Prometheus可以将数据存放到其他<a href="https://prometheus.io/docs/prometheus/latest/storage/#remote-storage-integrations" target="_blank" rel="noopener">存储服务</a>中</p><p>远程存储是一种附加功能（可以和本地存储同时工作），部分存储服务Prometheus只支持写入，不支持读取，作为一种长期数据备份工具。</p><p>当前支持的远程存储包括：</p><table><thead><tr><th>Storage</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://github.com/cortexproject/cortex" target="_blank" rel="noopener">Cortex</a></td><td>读写</td><td>这个项目专门为Prometheus提供可扩展的长期存储，并且是 CNCF 的孵化项目github上有1500+的star</td></tr><tr><td><a href="https://m3db.github.io/m3/" target="_blank" rel="noopener">M3DB</a></td><td>读写</td><td>Uber开源的分布式时序数据库,github上有两千多个stars，支持PromQL和Prometheus本身有非常好的兼容性</td></tr><tr><td><a href="https://github.com/improbable-eng/thanos" target="_blank" rel="noopener">thanos</a></td><td>写入</td><td>专门为Prometheus设计的集群方案，提供了全局查询、降准采样等能力、以及数据转存到对象存储的能力。Github上有4000+star</td></tr><tr><td><a href="https://github.com/VictoriaMetrics/VictoriaMetrics" target="_blank" rel="noopener">VictoriaMetrics</a></td><td>写</td><td>开源分布式时序数据库，支持 PromQL 接口、号称相比TimeScale和Influxdb相比有20以上的性能</td></tr><tr><td><a href="https://github.com/ChronixDB" target="_blank" rel="noopener">Chronix</a></td><td>写入</td><td>基于Lucene的一款时序数据库，支持单机集群方式部署。单机模式基于纯Lucene实现可以嵌入到应用程序中，集群模式基于solr实现分布式能力。同时该项目有Spark接口。</td></tr><tr><td><a href="https://github.com/crate/crate" target="_blank" rel="noopener">CrateDB</a></td><td>读写</td><td>分布式数据库，主要的应用场景是IoT场景（智能工厂、智能驾驶等等），涵盖了一整套IoT场景的平台方案（平台不是开源的）。</td></tr><tr><td><a href="https://github.com/pruthvikar/irondb" target="_blank" rel="noopener">irondb</a></td><td>读写</td><td>一个连官网都没有、Github上只有五个Star的keyvalue数据库</td></tr><tr><td><a href="https://signalfx.github.io/" target="_blank" rel="noopener">SignalFx</a></td><td>写</td><td>SignalFx本身也是一个监控平台</td></tr><tr><td>Wavefront</td><td>写入</td><td>VMware的企业级监控平台</td></tr><tr><td>Splunk</td><td>读写</td><td>商业日志分析工具</td></tr><tr><td>AppOptics</td><td>写入</td><td>商业APM工具，用在应用性能监控场景</td></tr><tr><td>Gnocchi</td><td>写入</td><td>从OpenStack的孵化出的项目，本质上是一个中间件，用来将metric数据进行时序封装，并写入到后端存储中。</td></tr><tr><td><a href="https://graphiteapp.org/" target="_blank" rel="noopener">graphite</a></td><td>写入</td><td>时序数据库、图形渲染层。这个工具只被动收集数据，并且图形渲染能力较弱一般和Grafana配合使用。</td></tr></tbody></table><p>其他开源组件存储包括：Elasticsearch、InfluxDB、Kafka、OpenTSDB、TiKV、PostgreSQLTimescaleDB</p><h1 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h1><p>目前，Prometheus并没有一套非常完整的集群方案，仅能够通过联邦的方式解决部分问题。</p><p>当前可以采用的</p><ul><li>基本HA方式：部署多套Prometheus，并且采集相同的Server实例。这种方式只能解决服务可用性的问题，无法解决一致性、故障恢复、动态扩展等问题，只适合：<strong>小集群、不进行迁移</strong>的场景。</li><li>基本HA方式 + 远程存储：Promthus Server将数据保存在远程服务上，并且部署多个实例，用NGINX路由请求。</li><li>基本HA + 远程存储 + 联邦集群</li><li>其他集群方案，如thanos</li></ul><h1 id="常用管理员命令"><a href="#常用管理员命令" class="headerlink" title="常用管理员命令"></a>常用管理员命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除数据</span></span><br><span class="line">curl -X POST \</span><br><span class="line">  -g 'http://172.24.33.31:9090/api/v1/admin/tsdb/delete_series?match[]=&#123;job="node"&#125;'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 触发压缩操作</span></span><br><span class="line">curl -XPOST http://localhost:9090/api/v1/admin/tsdb/clean_tombstones</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载配置文件</span></span><br><span class="line">kill -HUP &#123;pid&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://prometheus.io/docs/prometheus/latest/getting_started/" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="noopener">Prometheus-book</a></p><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener">FUNCTIONS</a></p><p><a href="https://prometheus.io/docs/prometheus/latest/querying/api/" target="_blank" rel="noopener">HTTP API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库调研笔记 – Prometheus&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Prometheus" scheme="https://LinQing2017.github.io/tags/Prometheus/"/>
    
  </entry>
  
</feed>
