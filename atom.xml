<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LQing的博客</title>
  
  <subtitle>“做程序员太辛苦了, 我想换行，我该怎么办?” “敲一下回车。”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LinQing2017.github.io/"/>
  <updated>2020-06-06T10:43:09.777Z</updated>
  <id>https://LinQing2017.github.io/</id>
  
  <author>
    <name>LQing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Kadmin安装Kubernetes</title>
    <link href="https://LinQing2017.github.io/2020/06/06/%E4%BD%BF%E7%94%A8Kadmin%E5%AE%89%E8%A3%85Kubernetes/"/>
    <id>https://LinQing2017.github.io/2020/06/06/使用Kadmin安装Kubernetes/</id>
    <published>2020-06-06T10:43:09.777Z</published>
    <updated>2020-06-06T10:43:09.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-kubeadm（控制面单点）"><a href="#安装-kubeadm（控制面单点）" class="headerlink" title="安装 kubeadm（控制面单点）"></a>安装 kubeadm（控制面单点）</h1><h2 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1. 前提条件"></a>1. 前提条件</h2><ul><li><p>关闭swap</p><ul><li>echo vm.swappiness=0 &gt;&gt; /etc/sysctl.conf</li><li>注释掉fstab里的swap</li></ul></li><li><p>进行网络参数配置</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe br_netfilter</span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h2 id="2-安装kubeadm、kubelet、kubectl"><a href="#2-安装kubeadm、kubelet、kubectl" class="headerlink" title="2. 安装kubeadm、kubelet、kubectl"></a>2. 安装kubeadm、kubelet、kubectl</h2><p>Kubeadm不会替用户安装kubelet和kubectl，用户可以通过yum、二进制安装包在所有node安装这些服务。</p><p>PS：安装时需要kubelet、kubectl和kubeadm版本匹配</p><p>三个服务都可以通过下面的repo安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config</span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet</span><br><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure><p>国内源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="3-kubeadmin介绍"><a href="#3-kubeadmin介绍" class="headerlink" title="3. kubeadmin介绍"></a>3. kubeadmin介绍</h2><p>通过kubeadmin可以快速的安装部署kubernetes集群：</p><ul><li><p>init：用于创建kubernetes中的管理面节点（control-plane node），即运行 etcd 、API Service的节点</p><ul><li><p>init执行了哪些工作，可以参考<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/" target="_blank" rel="noopener">Kubernetes官网</a></p></li><li><p>相关重要参数：</p><ul><li>apiserver-advertise-address：API Service的监听地址，默认情况下如果不指定，那么走的就是默认ip地址</li><li>apiserver-bind-port：默认6443</li><li>cert-dir：证书文件目录，默认/etc/kubernetes/pki</li><li>config：kubeadm 配置文件</li><li>control-plane-endpoint：控制面板的稳定地址</li><li>image-repository：镜像地址，默认k8s.gcr.io</li><li>kubernetes-version：kubernetes版本</li><li>pod-network-cidr：pod分配的ip网段</li><li>service-cidr：Default: “10.96.0.0/12”，service分配到的ip网段</li></ul></li><li><p>init命令会创建静态pod的yaml文件到/etc/kubernetes/manifests目录，包括：manager 、etcd、scheduler等</p></li><li><p>init命令执行完成后，可以使用以下命令配置kubectl</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure></li></ul></li><li><p>config：可以查看相关k8s集群的配置</p><ul><li>images list：列出k8s相关镜像</li><li>images pull：批量拉取k8s相关镜像</li></ul></li><li><p>join：添加一个node到一个指定的control-plane node控制面</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubeadm join 172.24.33.110:6443 --token wm28gj.xoeiagyk2epva317 \</span><br><span class="line">    --discovery-token-ca-cert-hash  sha256:b6a91123760c45b7e7ae6eca075674b43b31d1103bdd890256c318640e4e5d4b</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> token可以使用 kubeadm token list 查看，默认情况下Token会在24小时后过期，此时用户可以通过 kubeadm token create 重新创建</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cert的<span class="built_in">hash</span>编码值，可以使用以下命令获取：</span></span><br><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin    -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'</span><br></pre></td></tr></table></figure></li></ul><p>默认情况，如果安装单机场景的K8S（即控制平面单机），只需要用户安装完成docker，并下载好镜像后，执行 kubeadm init 就完成了控制平面的安装。</p><h2 id="4-安装网络插件"><a href="#4-安装网络插件" class="headerlink" title="4. 安装网络插件"></a>4. 安装网络插件</h2><p>网络插件称为Container Network Interface (CNI)，是K8S中容器间通信的接口规范，实现了这个规范后，就能提供IP地址、网关、路由、DNS等相关的网络参数。</p><p>当前K8S提供了非常多的CNI实现，并且全都是通过K8s工作负载的方式安装的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装calico插件</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure><h2 id="5-其他配置"><a href="#5-其他配置" class="headerlink" title="5. 其他配置"></a>5. 其他配置</h2><p>当使用 kubeadmin 安装时，控制面相关服务的YAML文件保存在/etc/kubernetes/manifests/目录下（包括：etcd、apiserver、controller-manager、shceduler），需要修改Kubernetes服务时，可以修改这些 YAML 文件中的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移除master节点隔离，服务可以调度到Master节点</span></span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署dashboad</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取临时登录的token。PS：需要暴露服务到nodeport，并且创建相应的账号</span></span><br><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep kubernetes-dashboard | awk '&#123;print $1&#125;')</span><br></pre></td></tr></table></figure><h2 id="6-清理环境"><a href="#6-清理环境" class="headerlink" title="6. 清理环境"></a>6. 清理环境</h2><p>略</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Installing kubeadm</a></p><p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">kubeadm Doc</a></p><p><a href="https://docs.projectcalico.org/getting-started/kubernetes/quickstart" target="_blank" rel="noopener">Kubernetes安装calico插件</a></p><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#tear-down" target="_blank" rel="noopener">Clean Up</a></p><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">web-ui-dashboard</a></p><p><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md" target="_blank" rel="noopener">集群外访问Dashboad</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装-kubeadm（控制面单点）&quot;&gt;&lt;a href=&quot;#安装-kubeadm（控制面单点）&quot; class=&quot;headerlink&quot; title=&quot;安装 kubeadm（控制面单点）&quot;&gt;&lt;/a&gt;安装 kubeadm（控制面单点）&lt;/h1&gt;&lt;h2 id=&quot;1-前提条
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spark调优笔记</title>
    <link href="https://LinQing2017.github.io/2020/06/06/Spark%E8%B0%83%E4%BC%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2020/06/06/Spark调优笔记/</id>
    <published>2020-06-06T10:43:09.768Z</published>
    <updated>2020-06-06T10:43:09.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>每一个Spark任务，从不同的角度、从大到小涉及到以下概念：</p><ul><li>按照占用的资源：Application –&gt; Driver/若干Executor –&gt; 每一个Executor 运行多个 Task（线程）</li><li>按照任务的逻辑：Application –&gt; 若干连续执行的Job –&gt; 每个Job划分为多个Stage</li></ul><p>知识点：</p><ul><li>从JVM角度每个Executor是一个独立进程，每个task是该进程的一个子线程。</li><li>Job 中划分 Stage 以shuffle操作作为边界，而划分 Job 边界的是代码中的 action。</li><li>每个数据 partition 由一个 Task 处理，因此每个 Task 处理的数据量和 partition num 的大小成反比，控制 partition num 可以防止 Executor 发生 Oom。</li><li>Task 的并行度由 slot 决定，slots = spark.num.executors * spark.executor.cores / spark.task.cpus。</li></ul><h1 id="Shuffle-操作"><a href="#Shuffle-操作" class="headerlink" title="Shuffle 操作"></a>Shuffle 操作</h1><p>Shuffle描述着数据从map task输出到reduce task输入的这段过程。在分布式情况下，每个 Reduce task 从不同 Map task 输出中拉取相同 Key 的 Records，这一过程会产生网络资源、内存、磁盘IO的消耗。</p><p>通常情况下，Shuffle 分成两个部分， 每个 Stage 从上一个 Stage Shuffle Read 得到数据，处理后进行 Shuffle Write 输出给下一个任务</p><ul><li>Map阶段的数据准备：Shuffle Write</li><li>Reduce阶段的数据拷贝：Shuffle Read</li></ul><p>在Spark的中负责shuffle的主要组件是ShuffleManager。</p><p>ShuffleManager随着Spark的发展有两种实现的方式：</p><ul><li><p>HashShuffleManager：Hash Shuffle</p><ul><li>Spark 1.2以前默认配置</li><li>会产生大量的中间磁盘文件，影响磁盘性能</li></ul></li><li><p>SortShuffleManager：Sort Shuffle</p><ul><li>从1.2 开始成为默认配置，并且在 Spark 2.0 时成为唯一的选择</li><li>每个Task在进行shuffle后，将所有的临时文件合并(merge)成一个磁盘文件，因此每个Task就只有一个磁盘文件。Reduce Task 根据索引读取每个磁盘文件中的部分数据</li></ul></li></ul><p>参考资料：</p><p> <a href="https://www.jianshu.com/p/4c5c2e535da5" target="_blank" rel="noopener">Spark Shuffle的技术演进</a></p><p> <a href="http://bigdatatn.blogspot.com/2017/05/spark-performance-optimization-shuffle.html" target="_blank" rel="noopener">Spark performance optimization: shuffle tuning</a></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Spark中一个Executor对应一个JVM进程，Executor占用的内存分为两部分：ExecutorMemory和MemoryOverhead。ExecutorMemory是堆区内存，MemoryOverhead是Spark的堆外内存。</p><p>在Spark1.6以前的版本中，heap内存是静态管理的，而新版中内存使用动态管理方案进行管理。通过配置项spark.memory.useLegacyMode可以在两种方式中进行切换。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>动态配置的情况下，Heap内存包括以下几个部分：</p><ul><li>Reserved Memory：预留给系统使用，是固定不变的。默认300MB，并且这一部分是不可变的。</li><li>User Memory：临时数据或者是自己维护的一些数据结构使用的内存空间， 默认大小：(Java Heap - Reserved Memory) x （1-spark.memory.fraction）（默认情况下1GB大小的Executor为289MB）。</li><li>Spark Memory：系统框架运行时需要使用的空间，这是从两部份构成的分别是 Storage Memeory 和 Execution Memory。前者用来进行RDD缓存，后者用来Shuffle缓存。Storage 和 Execution (Shuffle) 采用了 Unified 的方式共同使用一个内存区域，默认情况下两者各站这一部分内存的50%，当一方内存不足时两者会相互占用对方内存，但是通常情况下Execution (Shuffle)的优先级更高！</li></ul><h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>Spark的堆外内存称为Memory-Overhead是JVM进程中除Java堆以外占用的空间大小，包括方法区（永久代）、Java虚拟机栈、本地方法栈、JVM进程本身所用的内存、直接内存（DirectMemory）等。通过spark.yarn.executor.memoryOverhead设置，单位MB。</p><p>默认情况下，spark.yarn.executor.memoryOverhead的大小按照下面的方式决定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY_OVERHEAD_FACTOR = 0.07 </span><br><span class="line">MEMORY_OVERHEAD_MIN = 384</span><br><span class="line">min（MEMORY_OVERHEAD_FACTOR*spark.executor.memory，MEMORY_OVERHEAD_MIN）</span><br></pre></td></tr></table></figure><p>默认情况下，spark单个Executor占用的内存资源为Spark堆外内存和Heap内存，当堆外内存超出限制时会产生OOM，使Yarn直接杀死容器，这时候没有任何异常。</p><p><a href="https://juejin.im/post/5cac122ef265da0356320f09" target="_blank" rel="noopener">浅析 Spark Shuffle 内存使用</a></p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>Spark任务的输入在绝大多数场景下存在分区的概念，默认情况下一个分区的数据在一个Task线程中执行。</p><p>可以使用以下两个参数，控制 Spark 任务的分区：</p><ul><li>spark.default.parallelism：控制RDD的分区数量</li><li>spark.sql.shuffle.partitions：控制SQL的分区数量</li></ul><p>需要注意，进行Shuffle时分区的数目是会发生变化的。</p><h2 id="Spark-SQL-自动调整-Shuffle-Partition"><a href="#Spark-SQL-自动调整-Shuffle-Partition" class="headerlink" title="Spark SQL 自动调整 Shuffle Partition"></a>Spark SQL 自动调整 Shuffle Partition</h2><p>这个特性可以将Spark SQL执行Shuffle时，较小的连续分区进行合并，从而自适应 shuffle 时的分区数目。</p><p>该特性是 Intel 在<a href="https://github.com/Intel-bigdata/spark-adaptive" target="_blank" rel="noopener">Intel-bigdata/spark-adaptive</a>中设计，并且合入了Spark 2.3.1(<a href="https://issues.apache.org/jira/browse/SPARK-23128" target="_blank" rel="noopener">SPARK-23128</a>)。</p><p>spark-adaptive 针对 Spark 有下面三个优化：</p><ul><li>在Spark SQL下，自适应 Shuffle Partition 的数量</li><li>动态调整执行计划（基于一些中间结果的数据量大小，动态的改变执行计划）</li><li>自动处理数据倾斜</li></ul><p>参考: </p><p><a href="http://www.jasongj.com/spark/adaptive_execution/" target="_blank" rel="noopener">Adaptive Execution 让 Spark SQL 更高效更智能</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4Mzc0NjkwNA==&mid=2650784030&idx=1&sn=2c61e166b535199ee53e579a5092ff80&chksm=87faa829b08d213f55dab289bf5a12cfe376be0c944e03279a1c93e0f0d2164f1c6a6c7c880a&mpshare=1&scene=1&srcid=0111fEEzMCuhKozD4hsN4EE5&pass_ticket=WwOAQGxxBX9z63UyuFIXnWVm%2FSJhHkYwdsKplVDbaiA66ueqnDOtzgq86NgTgqvt#rd" target="_blank" rel="noopener">Spark SQL在100TB上的自适应执行实践</a></p><h1 id="Spark-Web-UI"><a href="#Spark-Web-UI" class="headerlink" title="Spark Web UI"></a>Spark Web UI</h1><p>Spark UI 的页面中，对检查任务的运行状态最有意义的是 Executors 和 Stages：</p><ul><li><p>Executors 可以查看以下内容</p><ul><li>Task 运行情况，包括：正在运行数、失败数目、已经完成数目、以及 Task 的总数；</li><li>Task 累积运行时间，以及累积的GC时间</li><li>executor的Input（累积输入）、Shuffle Read（Reduce端读）、Shuffle Write（Map端写）</li><li>driver和executor的聚合日志</li></ul></li><li><p>Stages 可以查看以下内容</p><ul><li>每个Stages的持续时间（Duration）</li><li>Stages 的输入/ 输出数据大小（Input/Output）,这个指读写到Hadoop等外部存储的数据，以及从Spark Storage读到的数据</li><li>Shuffle Read / Shuffle Write 序列化后，shuffle读写的数据量</li><li>Stages 中每个 Task 的统计细节<ul><li>Shuffle Read Size / Records : 序列化的shuffle读数据大小</li><li>Shuffle Write Size / Records : 序列化的shuffle写数据大小</li><li>Shuffle Spill (Memory) ： shuffle 过程中spill到disk的数据大小，这里指的是反序列化后数据大小</li><li>Shuffle Spill (Disk) ： shuffle 过程中spill到disk的数据大小，这里指的是序列化后数据大小</li></ul></li></ul></li></ul><h1 id="Oom"><a href="#Oom" class="headerlink" title="Oom"></a>Oom</h1><p>处理Oom的一些手段：</p><ul><li><p>Driver Oom 时通常有以下可能：</p><ul><li>Executor 返回的序列化结果集太小，而 spark.driver.maxResultSize（默认1g） 太小</li></ul></li><li><p>Executor Oom 时通常有以下可能：</p><ul><li>分区数量过小，那么单个Executor需要处理数据量会增多，使Executor的压力过大。</li><li>spark.yarn.executor.memoryOverhead太小，这时候堆外内存溢出，yarn会直接杀死容器，可能spark上可能看不到任何异常。</li><li>由于Spark executor中多个Task并行时是共享内存的，因此减少slot可以改善Oom的情况；</li><li>数据倾斜造成 OOM（主要原因是，堆内对象的分配和释放是由 JVM 管理的，而 Spark 是通过采样获取已经使用的内存情况，有可能因为采样不准确而不能及时 Spill，导致OOM）；</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;p&gt;每一个Spark任务，从不同的角度、从大到小涉及到以下概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照占用的资源：Applicatio
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/11/07/Greenplum-pxf%E4%BD%BF%E7%94%A8/"/>
    <id>https://LinQing2017.github.io/2019/11/07/Greenplum-pxf使用/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.705Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="PXF"><a href="#PXF" class="headerlink" title="PXF"></a>PXF</h1><p>PXF 是 Greenplum 自带的外表连接插件，可以用来连接包括：Hive、HDFS、HBase、S3、JDBC 等外部数据源。 </p><p>PXF 运行在每个 Segment 主机上，可以直接连接外部数据源获取数据，具有：谓词下推、列式查询等特性。</p><p>PXF 基于JAVA，使用时需要在所有Greenplum集群上安装jdk，其安装目录位于$GPHOME/pxf。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="Conf配置目录"><a href="#Conf配置目录" class="headerlink" title="Conf配置目录"></a>Conf配置目录</h3><p>当用户初始化PXF时，初始化进程会在 $PXF_CONF 目录下创建用户配置目录。</p><p>用户配置目录以 /usr/local/greenplum-db/pxf 下的文件为模板，用户应该在 $PXF_CONF 目录中修改配置文件。</p><p>用户需要关注 $PXF_CONF/conf 目录中的三个配置文件：</p><ul><li>pxf-env.sh：定义 PXF 使用的环境变量</li><li>pxf-log4j.properties：日志文件</li><li>pxf-profiles.xml：自定义profiles</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">profiles 配置是用来定义：数据格式、依赖jar等内容的，可以认为一个profiles 是 pxf 和外部数据源之间的连接器。</span><br><span class="line"></span><br><span class="line">通常一个数据源有多种连接器，PXF 已经预定义了一些 profiles 配置（参考$GPHOME/pxf/conf/pxf-profiles-default.xml文件）</span><br><span class="line"></span><br><span class="line">Hadoop作为外部数据源时，数据格式和数据源（HIVE、HBASE、HDFS）对应的 profiles 参考：</span><br><span class="line"></span><br><span class="line">[Connectors, Data Formats, and Profiles](https://gpdb.docs.pivotal.io/6-1/pxf/access_hdfs.html)</span><br></pre></td></tr></table></figure><h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p>PXF 中将外部数据源定义为Server，用户在创建外部表时可以指定不同的Server，当不指定Server时从默认数据源（default server）拉取数据。</p><p>Server的配置存放在 $PXF_CONF/servers/{server_name}/ 目录中，每一个Server表示一种外部数据源。</p><p>Server的配置文件取决于类型，可能包含多种配置文件。PXF 还允许不同Greenplum用户连接数据源时，使用不同的配置用户可以在 $PXF_CONF/servers/{server_name}/ 中创建 {greenplum_user_name}-user.xml 文件，根据需要编辑该用户使用参数（比如，<strong>身份信息</strong>和<strong>其他配置</strong>）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用JDBC作为外部存储时，在用户配置中定义JDBC的用户信息 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>jdbc.user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>pguser1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>jdbc.password<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>changeme<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="comment">-- pxf协议中，包含以下参数：</span></span><br><span class="line"><span class="comment">--      PROFILE         ：指定了配置文件地址</span></span><br><span class="line"><span class="comment">--      SERVER          ：配置文件中定义的数据源配置</span></span><br><span class="line"><span class="comment">--      path-to-data    ：数据地址，HDFS上的地址或者HIVE上的表名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> [WRITABLE] <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> &lt;table_name&gt;</span><br><span class="line">        ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | <span class="keyword">LIKE</span> &lt;other_table&gt; )</span><br><span class="line">LOCATION(<span class="string">'pxf://&lt;path-to-data&gt;?PROFILE=&lt;profile_name&gt;[&amp;SERVER=&lt;server_name&gt;][&amp;&lt;custom-option&gt;=&lt;value&gt;[...]]'</span>)</span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'[TEXT|CSV|CUSTOM]'</span> (&lt;formatting-properties&gt;);</span><br></pre></td></tr></table></figure><h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>以下Demo展示了Greenplum访问HDFS上的Text文本数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有节点指定PXF配置目录</span></span><br><span class="line">echo "export PXF_CONF=/home/gpadmin/conf/pxf_conf" &gt;&gt; ~/.bashrc </span><br><span class="line">source ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在整个集群中初始化pxf服务，pxf会在 <span class="variable">$PXF_CONF</span> 指定的路径下生成一系列配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GPHOME/pxf/bin/pxf cluster init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copy Hadoop环境的以下文件到<span class="variable">$PXF_CONF</span>/servers/default目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   core-site.xml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   hdfs-site.xml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   mapred-site.xml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   yarn-site.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Hadoop使用Kerberos认证时，执行以下操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   1. 安装kerberos客户端，yum -y install  krb5-libs krb5-workstation</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   2. 配置krb5.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   3. copy keytab文件到所有segment机器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   4. 修改<span class="variable">$PXF_CONF</span>/conf/pxf-env.sh中的以下几个配置项：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">           PXF_KEYTAB：            使用的keytab</span></span><br><span class="line"><span class="meta">#</span><span class="bash">           PXF_PRINCIPAL：         认证的账号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">           PXF_USER_IMPERSONATION：建议改为<span class="literal">false</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下命令同步配置到所有segment节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   </span></span><br><span class="line"><span class="meta">$</span><span class="bash">GPHOME/pxf/bin/pxf cluster sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GPHOME/pxf/bin/pxf cluster start</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- HDFS 上文本内容如下，文件位于/tmp/pxf_hdfs_simple.txt目录</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Prague,Jan,101,4875.33</span></span><br><span class="line"><span class="comment">-- Rome,Mar,87,1557.39</span></span><br><span class="line"><span class="comment">-- Bangalore,May,317,8936.99</span></span><br><span class="line"><span class="comment">-- Beijing,Jul,411,11600.67</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建Greenplum用户用来访问外部表，这里建议和PXF_PRINCIPAL中定义一致，否则需要配置 PXF_USER_IMPERSONATION</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> idata LOGIN <span class="keyword">REPLICATION</span> CREATEDB CREATEEXTTABLE <span class="keyword">PASSWORD</span> <span class="string">'idata'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建db，并且注册pxf插件</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> idata;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION pxf;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为用户赋pxf协议权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> PROTOCOL pxf <span class="keyword">TO</span> idata; </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> PROTOCOL pxf <span class="keyword">TO</span> idata; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> pxf_hdfs_textsimple(location <span class="built_in">text</span>, <span class="keyword">month</span> <span class="built_in">text</span>, num_orders <span class="built_in">int</span>, total_sales float8) LOCATION (<span class="string">'pxf://tmp/pxf_examples/pxf_hdfs_simple.txt?&amp;PROFILE=hdfs:text'</span>)<span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (delimiter=E<span class="string">','</span>);</span><br></pre></td></tr></table></figure><p><strong>需要注意：当使用Kerberos认证的Hadoop时，只能使用default作为server配置</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://gpdb.docs.pivotal.io/6-1/pxf/intro_pxf.html" target="_blank" rel="noopener">Introduction to PXF</a></p><p><a href="https://gpdb.docs.pivotal.io/6-1/pxf/access_hdfs.html" target="_blank" rel="noopener">Accessing Hadoop with PXF</a>：读写不同格式的HDFS文件、读写hive表、HBase表</p><p><a href="https://gpdb.docs.pivotal.io/6-0/pxf/pxf_kerbhdfs.html" target="_blank" rel="noopener">Configuring PXF for Secure HDFS</a></p><p><a href="https://gpdb.docs.pivotal.io/6-1/pxf/troubleshooting_pxf.html" target="_blank" rel="noopener">Troubleshooting</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/11/06/Greenplum-%E5%8E%86%E5%8F%B2%E6%8B%89%E9%93%BE%E8%A1%A8/"/>
    <id>https://LinQing2017.github.io/2019/11/06/Greenplum-历史拉链表/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.716Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><p>《Greenplum企业应用实战》一书第三章读书笔记。</p><h1 id="历史拉链表"><a href="#历史拉链表" class="headerlink" title="历史拉链表"></a>历史拉链表</h1><p>历史拉链表主要用于：记录一个事务从开始一直到当前状态的所有变化信息。相比于定时快照，历史拉链表结构可以避免数据海量存储，是处理缓慢变化数据的常见方式。</p><p>记录member事实表的变换情况，可以通过以下四张表实现历史拉链表：</p><ul><li>member_fatdt0：事实表，添加 dw_end_date 和 dw_beg_date 字段分别表示记录的失效时间和生效时间，使用 dw_end_date 分区，最后一个分区（取值为无穷大）是最新数据，其余分区是失效数据。</li><li>member_delta：当天数据库的变更，action字段表示数据操作类型（I,U,D）。</li><li>member_tmp0：刷新过程的临时表，有二个分区记录历史数据（当天失效数据）和当前数据，结构和member_fatdt0一样。</li><li>member_tmp1：刷新过程的临时表，用来交换分区，结构和member_fatdt0一样。</li></ul><p>更新过程：</p><ul><li><p>当天任意数据变更插入到 member_delta 中，但次日凌晨将 member_delta 合并到 member_fatdt0 中</p></li><li><p>member_delta 和 member_fatdt0 的合并参考下面的步骤：</p><ul><li><p>member_fatdt0 和 member_delta 最后一个分区使用 member_id 进行左外连接，关联上了说明数据发生变更，关联不上说明没有发生变更。</p><ul><li>关联上的数据修改 dw_end_date 插入 member_tmp0 的历史分区</li><li>关联不上的数据插入 member_tmp0 的当前分区（即今天没有发生变更的数据）</li></ul></li><li><p>将 member_delta 中 action 类型为（I,U）的插入到 member_tmp0 当前数据分区（dw_end_date = 无穷大， dw_beg_date = 当天时间）</p></li><li><p>将 member_fatdt0 的当天分区和 member_tmp0 历史数据分区交换</p></li><li><p>将 member_fatdt0 的最后一个分区和 member_tmp0 当前分区交换</p></li></ul></li></ul><p>查询 member_fatdt0 时通过 dw_end_date 和 dw_beg_date 可以回溯到任意一天的状态。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> public.member_fatdt0 <span class="keyword">where</span> dw_beg_date &lt;= <span class="built_in">date</span><span class="string">'2011-12-01'</span> <span class="keyword">and</span> dw_end_date &gt;= <span class="built_in">date</span><span class="string">'2011-12-01'</span> <span class="keyword">order</span> <span class="keyword">by</span> member_id;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/11/06/Greenplum-%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://LinQing2017.github.io/2019/11/06/Greenplum-性能相关的知识/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.717Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="收集统计信息"><a href="#收集统计信息" class="headerlink" title="收集统计信息"></a>收集统计信息</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- ANALYZE无参数数时收集整个数据库的统计信息；</span></span><br><span class="line"><span class="comment">-- 可以收集单个表，或表的单个列的统计信息；</span></span><br><span class="line"><span class="comment">-- 不收集外表的统计信息；</span></span><br><span class="line"><span class="comment">-- 通常建议每天运行一次 VACUUM 和 ANALYZE；</span></span><br><span class="line"><span class="comment">-- ANALYZE 在表中产生 UPDATE EXCLUSIVE 锁，因此一些查询语句可能为产生冲突；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ANALYZE</span> [VERBOSE] [ROOTPARTITION [<span class="keyword">ALL</span>] ] </span><br><span class="line">   [<span class="keyword">table</span> [ (<span class="keyword">column</span> [, ...] ) ]];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 收集分区表的根表信息，该命令不会收集普通表的信息</span></span><br><span class="line"><span class="keyword">ANALYZE</span> ROOTPARTITION <span class="keyword">ALL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 审定test表的note列不收集统计信息；</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">alter</span> note <span class="keyword">SET</span> <span class="keyword">STATISTICS</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>相关配置：</p><ul><li>optimizer_analyze_root_partition：为on，ANALYZE命令同样会收集分区表的统计信息</li><li>default_statistics_target：ANALYZE命令进行随机抽样时的采样系数，值越大采样越准确，所花的时间更长。一些特定的列可以单独设定这个值（ALTER TABLE … ALTER COLUMN … SET STATISTICS）</li><li>gp_enable_relsize_collection：没有统计值时，使用表的大小进行估计</li><li>gp_autostats_mode：NONE（不收集）、ON_CHANGE（变化收集）、no_no_stats（建表时收集一次）</li><li>gp_autostats_on_change_threshold：自动收集阈值，默认是20亿</li></ul><h1 id="分析执行计划"><a href="#分析执行计划" class="headerlink" title="分析执行计划"></a>分析执行计划</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> [<span class="keyword">ANALYZE</span>] [VERBOSE] <span class="keyword">statement</span></span><br></pre></td></tr></table></figure><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>EXPLAIN语句不会实际执行语句，只是根据当前收集的统计信息生成<strong>执行计划树</strong>来评估SQL运行成本。</p><p>计划树中每一个节点代表SQL需要进行的操作，并包含以下信息：</p><ul><li>cost：当前节点以及子节点需要读取的磁盘页，格式为：cost=xxx..xxx(第一行输出时..输出完成时)</li><li>rows: 表示该节点需要读取的行数</li><li>width：平均每行的字节数</li></ul><h2 id="EXPLAIN-ANALYZE"><a href="#EXPLAIN-ANALYZE" class="headerlink" title="EXPLAIN ANALYZE"></a>EXPLAIN ANALYZE</h2><p>EXPLAIN ANALYZE 会实际执行SQL语句并且提供一些额外的统计信息：</p><ul><li>actual time：实际执行时间，单位是ms，格式和cost相同</li><li>rows：实际返回的行数</li><li>loops：？？？</li><li>每个Slice使用的内存情况（应该包括：work_mem和statement_mem的内存使用情况，<strong>测试中只要statement_mem够大就不会发生磁盘IO能一定程度提高性能</strong>）</li></ul><h2 id="执行计划中的重要关键字"><a href="#执行计划中的重要关键字" class="headerlink" title="执行计划中的重要关键字"></a>执行计划中的重要关键字</h2><ul><li><p>数据扫描（Scan）：</p><ul><li>Seq Scan：顺序扫描，有时候可能带有Dynamic前缀，表示分区顺序扫描</li><li>Shared Scan：扫描shared_buffer中的某个slice</li><li>Index Scan：索引扫描</li><li>其他扫描子句：Bitmap Heap Scan、Tid Scan、Subquery Scan、Function Scan</li></ul></li><li><p>数据移动（Motion）：</p><ul><li><p>Gather Motion(N:1)：在master上聚合</p></li><li><p>Broadcast Motion(N:N)：所有Segment上广播</p></li><li><p>Redistribute Motion(N:N)：重分布，常见关联、Group by、开窗函数中发生。</p><ul><li>重分布除了IO开销之外，还会带来数据不均衡的问题！！</li><li>union合并表时，去重会导致重分布，并且此时以整行（所有列）进行重分布，因此慎用union（整行重分布 –&gt; 排序 –&gt; 去重 –&gt; 插入结果集），另外union all虽然和并时不涉及去重，但是在写入结果集时任然会引发重分布，需要注意。</li></ul></li></ul></li></ul><ul><li><p>Slice：将SQL拆分多个切片，Montion操作都会产生一个切片，通常Montion操作后会表名其切片号，以及涉及的segment数目。</p></li><li><p>数据聚合：</p><ul><li>HashAggregate：基于Group By字段的hash值维护内存hash表，hash表的长度正比于聚合字段的distinct值，对n个聚合字段Greenplum需要维护n个hash表。</li><li>GroupAggregate：基于聚合字段排序后，对数据进行一次全扫描从而得到聚合结果。</li><li>建议：GroupAggregate的性能相比HashAggregate较为稳定，当聚合函数的种类较多并且聚合键的重复性较差时会使HashAggregate使用的内存急剧上升，此时应该选择GroupAggregate方式聚合。</li></ul></li><li><p>关联：涉及到广播和重分布</p><ul><li>Hash join：通过内存中的Hash表来实现关联</li><li>NestLoop：效率最低，执行笛卡尔积时使用该方式</li><li>Merge Join：两表按照关联键排序，之后通过归并排序的方式关联（性能不如hash join）</li></ul></li><li><p>开窗函数：</p><ul><li>当开窗函数的分布键不是表的分布键时，会引起表<strong>多次</strong>的重分布。</li><li>如果开窗函数没有partition字段，只有Order字段那么为了维护一个全局序列，所有数据必须汇聚到Master上进行排序操作，此时Master会成为系统瓶颈。</li></ul></li></ul><p>有些参数可以控制优化器的执行计划,参考<a href="https://gpdb.docs.pivotal.io/6-0/ref_guide/config_params/guc-list.html" target="_blank" rel="noopener">enable_xxx配置</a>!</p><h3 id="优化器开销的计算"><a href="#优化器开销的计算" class="headerlink" title="优化器开销的计算"></a>优化器开销的计算</h3><p>优化器通过开销的计算结果选择SQL的执行步骤，其Cost值的计算方式是可以用参数控制的。</p><p>通常以抓取顺序页的开销作为基准单位(seq_page_cost取值为1)，以下是不同开销的默认值：</p><ul><li>seq_page_cost：磁盘顺序读的开销</li><li>random_page_cost：磁盘随机读取的开销</li><li>cpu_tuple_cost：处理一行数据的开销</li><li>cpu_index_tuple_cost：索引扫描每个索引行的开销</li><li>cpu_operator_cost：一次查询中执行一个操作符或者函数的开销</li><li>gp_motion_cost_per_row：motion操作的开销</li><li>effective_cache_size</li></ul><p>Greenplum优化器会根据pg_class表中的relname、relpages、reltuples的值每种运行方式的cost成本，之后选择cost最小值做为执行方案。</p><p>调整经验：</p><ul><li>如果内存充足random_page_cost可以适当降低；</li><li>seq_page_cost和 random_page_cost同时降低时，会使CPU开销上升；</li></ul><h1 id="Join的广播和重分布"><a href="#Join的广播和重分布" class="headerlink" title="Join的广播和重分布"></a>Join的广播和重分布</h1><p>Join通常涉及单库关联、以及跨库关联：</p><ul><li>单库关联：关联键和分布键一致，此时没有数据重分布</li><li>跨库关联：关联键和分布键不一致，数据重新分布，装换为单库关联</li></ul><table><thead><tr><th>表名</th><th>字段</th><th>分布键</th><th>数据量</th></tr></thead><tbody><tr><td>A</td><td>id，id2</td><td>id</td><td>M</td></tr><tr><td>B</td><td>id，id2</td><td>id</td><td>N</td></tr></tbody></table><p>以下是A、B表进行内连接时的场景，左连接和其原理类似（PS：左连接时一般不广播左表）。</p><p>遇到全连接时，Greenplum中使用Merge Join方式实现（即排序方式实现Join），全连接通常进行重分布。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于A，B表的分布键均是id，且此关联的关联键也是id，此时A，B中id取值相同的行在同一个pg库中，可以直接关联</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A,B <span class="keyword">where</span> A.id=B.id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表A的关联键是分布键，但是表B的关联键不是分布键</span></span><br><span class="line"><span class="comment">-- 方式一：将表B按照id2字段重分布到每一个节点上 ———— 重分布（处理数据量是N）；</span></span><br><span class="line"><span class="comment">-- 方式二：将表A广播到每个节点中 ———— 广播（处理数据量是M*节点数）；</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A,B <span class="keyword">where</span> A.id=B.id2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表A、B的关联键都不是分布键</span></span><br><span class="line"><span class="comment">-- 方式一：将表A和表B都按照id2字段，将数据重分布到每个节点，代价是M+N</span></span><br><span class="line"><span class="comment">-- 方式二：将小表广播</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A,B <span class="keyword">where</span> A.id1=B.id2</span><br></pre></td></tr></table></figure><p>PS：<strong>Greenplum判断表的大小是通过统计信息决定的，因此如果统计信息不准确可能会使重分布策略选择错误</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/11/06/Greenplum-%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/"/>
    <id>https://LinQing2017.github.io/2019/11/06/Greenplum-数据字典/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.718Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><p>《Greenplum企业应用实战》一书第四章读书笔记。</p><h1 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h1><p>这里的数据字典指的是 Greenplum 中元数据信息，包括：pg_ 和 gp_ 开头的一些系统表。</p><h2 id="oid"><a href="#oid" class="headerlink" title="oid"></a>oid</h2><p>oid 是 PG/GP 中用来表示对象（包括：表、函数、操作符等等）的全局递增 id （是32位数字），GP 中绝大多数数据字典通过oid相互关联。</p><p>表名、函数名、操作符名可以和 oid 相互转换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 类似的还有</span></span><br><span class="line"><span class="comment">-- regclass : pg_class中的oid关联</span></span><br><span class="line"><span class="comment">-- regproc/regprocedure : pg_proc 中的oid关联</span></span><br><span class="line"><span class="comment">-- regoper/regoperator：pg_operator中的oid关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- pg_class表的oid是1259</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">1259</span>::regclass ; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">oid</span>,relname <span class="keyword">from</span> pg_class <span class="keyword">where</span> <span class="keyword">oid</span>=<span class="string">'pg_class'</span>::regclass;</span><br></pre></td></tr></table></figure><h2 id="数据库集群信息"><a href="#数据库集群信息" class="headerlink" title="数据库集群信息"></a>数据库集群信息</h2><p>gp_configuration<br>gp_segment_configuration</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- MyCat</title>
    <link href="https://LinQing2017.github.io/2019/11/04/MyCat-%E4%BB%8B%E7%BB%8D/"/>
    <id>https://LinQing2017.github.io/2019/11/04/MyCat-介绍/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.729Z</updated>
    
    <content type="html"><![CDATA[<p>数据库调研笔记 – MyCat</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>MyCat基于Ali的开源组件cobar演变而来，是一款知名度较高的SQL中间件。</p><p>当前<a href="https://github.com/MyCATApache/Mycat-Server" target="_blank" rel="noopener">MyCATApache/Mycat-Server</a>项目有7.2K Star，89个贡献者。</p><p>当前的稳定版本是<a href="http://dl.mycat.io/1.6.5/" target="_blank" rel="noopener">MyCat 1.6.5</a>，另外社区还有<a href="https://github.com/MyCATApache/Mycat2/blob/master/doc/00-mycat-readme.md" target="_blank" rel="noopener">Mycat2</a>项目，但是当前还没有正式发行版。</p><p>目前，MySQL后端支持以下数据库： Mysql、SQL Server、Oracle、 DB2、PostgreSQL、部分NoSQL</p><p>PS：”MyCat目前在Github上有655个open状态的issue，绝大数issue没有人回应。”</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>第一次安装使用MySQL 8.0作为后端，但是安装完成后发现存在兼容性问题：Mysql 8.0自带的mysql客户端无法正常连接mycat，但是使用低版本的mysql客户端可以正常连接（这个问题Github上有<a href="https://github.com/MyCATApache/Mycat-Server/issues/1842" target="_blank" rel="noopener">issues</a>，但是没有修复）。</p><p>mysql 8.0 安装过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装mysql 8.0</span></span><br><span class="line">wget -i -c  https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">yum -y install mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">yum -y install mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装mysql5.7</span></span><br><span class="line"><span class="meta">#</span><span class="bash">wget -i -c https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tar -xvf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar</span></span><br><span class="line"><span class="meta">#</span><span class="bash">yum -y localinstall mysql-community-*5.7.28-1*.rpm</span></span><br><span class="line"></span><br><span class="line">echo "lower_case_table_names=1" &gt;&gt; /etc/my.cnf</span><br><span class="line">echo "default-authentication-plugin=mysql_native_password" &gt;&gt;  /etc/my.cnf  # 安装低版本mysql时无需配置</span><br><span class="line">systemctl enable mysqld.service &amp;&amp; systemctl start mysqld.service</span><br><span class="line"></span><br><span class="line">grep "password" /var/log/mysqld.log</span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接mysql修改默认密码，以及认证加密方式，并创建数据库</span></span><br><span class="line"></span><br><span class="line">ALTER USER 'root'@'localhost' IDENTIFIED BY 'Ruijie@123';</span><br><span class="line">ALTER USER 'root'@'%' IDENTIFIED BY 'Ruijie@123' PASSWORD EXPIRE NEVER;       # 使用低版本mysql时无需执行</span><br><span class="line">ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'Ruijie@123';  # 使用低版本mysql时无需执行</span><br><span class="line"></span><br><span class="line">use mysql;</span><br><span class="line"><span class="meta">#</span><span class="bash">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'Ruijie@123'</span>;         </span></span><br><span class="line">UPDATE USER SET HOST = '%' where USER = 'root'; </span><br><span class="line">flush privileges;</span><br><span class="line">CREATE DATABASE mycat_db;</span><br></pre></td></tr></table></figure><p>部署mycat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">groupadd -g 550 mycat</span><br><span class="line">useradd -g 550 -u 550 -m -d /home/mycat -s /bin/bash mycat</span><br><span class="line">echo "ruijie" | passwd --stdin mycat</span><br><span class="line"></span><br><span class="line">wget http://dl.mycat.io/1.6.7.3/20190927161129/Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz</span><br><span class="line">tar -xzvf Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz -C /usr/local</span><br><span class="line">chown -R mycat:mycat /usr/local/mycat</span><br><span class="line"></span><br><span class="line">echo "export MYCAT_HOME=/usr/local/mycat" &gt; /etc/profile.d/mycat.sh</span><br><span class="line">echo "export PATH=$PATH:$MYCAT_HOME/bin" &gt;&gt; /etc/profile.d/mycat.sh</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果后端数据库使用的是mysql 8.0需要替换lib目录下的驱动文件</span></span><br></pre></td></tr></table></figure><p>安装过程中，注意schema.xml和server.xml文件：</p><ul><li>schema.xml定义mycat的逻辑表和逻辑库信息，以及后端mysql信息；</li><li>server.xml文件定义连接信息和用户信息，安装包中默认提供二个用户 root/123456 和 user/user；</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    PS：该配置文件中mycat规划了2个shard，小于默认的三个，需要修改autopartition-long.txt，将最后一行配置删掉</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"true"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"travelrecord"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-long"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"mycat71"</span> <span class="attr">database</span>=<span class="string">"mycat_db"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn2"</span> <span class="attr">dataHost</span>=<span class="string">"mycat72"</span> <span class="attr">database</span>=<span class="string">"mycat_db"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"mycat71"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"mycat71"</span> <span class="attr">url</span>=<span class="string">"mycat71:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Ruijie@123"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"mycat72"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"mycat72"</span> <span class="attr">url</span>=<span class="string">"mycat72:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Ruijie@123"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>安装完成后执行mycat start启动mycat服务。</p><h1 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h1><p>Mycat的配置信息主要位于schema.xml、server.xml、rule.xml三个文件中。</p><p><a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=http%3A%2F%2Fwww.mycat.io%2Fdocument%2Fmycat-definitive-guide.pdf" target="_blank" rel="noopener">MyCat权威指南</a>第七章详细说明了这三个配置文件。</p><h2 id="schema-xml文件"><a href="#schema-xml文件" class="headerlink" title="schema.xml文件"></a>schema.xml文件</h2><h3 id="1-schema标签"><a href="#1-schema标签" class="headerlink" title="1. schema标签"></a>1. schema标签</h3><p>该标签用来定义mycat中的逻辑数据库，对于一个mycat实例可以配置多个逻辑数据库。</p><p>schema字段包含以下属性：</p><ul><li>name：逻辑库名称</li><li>dataNode：将逻辑库绑定到后端一个具体的数据库，此时没有配置分片的表落在该数据库中</li><li>checkSQLschema：将发送到后端DB的schema关键字去除</li><li>sqlMaxLimit：自动加上limit语句</li></ul><h3 id="2-table标签"><a href="#2-table标签" class="headerlink" title="2. table标签"></a>2. table标签</h3><p>该标签是schema的子标签，所有需要拆分的表在该标签中定义，形成一张拆分逻辑表。</p><ul><li>name：逻辑表名</li><li>dataNode：逻辑表分片到的实际数据库，可以定义多个，或者通配符定义</li><li>rule：逻辑表遵循的分片规则，规则在rule.xml中定义（tableRule标签中的name属性一一对应）</li><li>ruleRequired：该属性用于指定表是否绑定分片规则，如果配置为true</li><li>primaryKey：该逻辑表对应真实表的主键。使用非主键分片时，指定实际主键会使Mycat缓存查询结果，提高性能</li><li>type：表属性，包括全局表、普通表两种</li><li>autoIncrement：指定这个表有使用自增长主键</li><li>subTables：启用分表属性（指对大表宽表进行垂直拆分），分表放在一个数据库中，并且不支持各种条件的join</li><li>needAddLimit：自动的在每个语句后面加上limit 限制（默认为true）</li></ul><h3 id="3-childTable标签"><a href="#3-childTable标签" class="headerlink" title="3.childTable标签"></a>3.childTable标签</h3><p>childTable用于定义E-R分片的子表</p><h3 id="4-dataNode-dataHost标签"><a href="#4-dataNode-dataHost标签" class="headerlink" title="4. dataNode/dataHost标签"></a>4. dataNode/dataHost标签</h3><p>dataNode 标签定义了MyCat中的数据节点。一个dataNode 标签就是一个独立的数据分片，对应一个后端数据库。</p><p>dataHost 标签定义了一个数据库的具体链接方式，读写分离配置、和心跳语句。dataHost 标签比较重要的参数包括：</p><ul><li>maxCon/minCon：连接池配置</li><li>balance ：读操作负载均衡配置，当前支持单点读、读写分离、双主双从、随机分发</li><li>writeType ：写操作的服务负载均衡</li><li>switchType：主备切换配置</li><li>dbType：数据库类型，目前实际上mycat只支持mysql的二进制协议，但是这里可以填写MongoDB、Oracle、Spark等类型的数据库，但本质上都是通过jdbc连接的后端。</li><li>dbDriver：驱动类型支持natvie、jdbc两种</li><li>heartbeat 标签：心跳语句</li><li>writeHost标签、readHost标签</li></ul><h2 id="server-xml文件"><a href="#server-xml文件" class="headerlink" title="server.xml文件"></a>server.xml文件</h2><p>server.xml几乎保存了所有mycat需要的系统配置信息。其在代码内直接的映射类为SystemConfig类。其中最为重要的标签是：</p><ul><li>user标签：定义mycat的连接用户和权限。</li><li>system标签：定义mycat的系统配置，如字符集、sql解析器、线程数据等等</li></ul><h2 id="rule-xml文件"><a href="#rule-xml文件" class="headerlink" title="rule.xml文件"></a>rule.xml文件</h2><p>该文件定义了一些分片策略，在schema.xml文件中指定表分片时可以指定这些分片策略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule1"</span>&gt;</span>    <span class="comment">&lt;!--表规则名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span>   <span class="comment">&lt;!--片键名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span> <span class="comment">&lt;!--路由算法名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--分片算法通过java类实现，配置指定在文件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span><span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByFileMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常用分片算法：参考<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=http%3A%2F%2Fwww.mycat.io%2Fdocument%2Fmycat-definitive-guide.pdf" target="_blank" rel="noopener">MyCat权威指南</a>第10.5章节！</p><h1 id="Mycat的join操作"><a href="#Mycat的join操作" class="headerlink" title="Mycat的join操作"></a>Mycat的join操作</h1><p>Mycat支持以下几种场景的Join：</p><h2 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h2><p>全局表在所有节点保存完整副本，具备以下特性：</p><ul><li><p>全局表的插入、更新操作会实时在所有节点上执行，保持各个分片的数据一致性</p></li><li><p>全局表的查询操作，只从一个节点获取</p></li><li><p>全局表可以跟任何一个表进行JOIN操作</p></li><li><p>Mycat通过在MYSQL中额外添加内部列进行全局一致性检查</p><ul><li>检查全局表是否存在内部列</li><li>检查全局表的记录总数</li><li>检查全局表的时间戳最大值</li></ul></li><li><p>插入全局表时必须带列名插入</p></li></ul><h2 id="E-R-Join"><a href="#E-R-Join" class="headerlink" title="E-R Join"></a>E-R Join</h2><p>E-R Join是在schema.xml文件中预先定义两张的关联key，使分片时关联键相同的数据分布在同一个数据库中，从而保证不会发生跨跨库join。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- customer 和 orders 的关联关系为 orders.customer_id=customer.id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-intfile"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">"orders"</span>  <span class="attr">joinKey</span>=<span class="string">"customer_id"</span> <span class="attr">parentKey</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="其他Join方式"><a href="#其他Join方式" class="headerlink" title="其他Join方式"></a>其他Join方式</h2><ul><li>Share Join：ShareJoin是一个简单的跨分片Join,基于HBT的方式实现，目前支持两个表join，官方文档称只在开发版中有该功能。</li><li>Catlet Join：通过自定义接口实现Join操作。</li><li>Spark/Storm对join扩展：还没有实现！！</li></ul><h1 id="全局序列号"><a href="#全局序列号" class="headerlink" title="全局序列号"></a>全局序列号</h1><p>Mycat中全局序列号主要用来为表提供自增组件，用户可以通过：本地文件、数据库配置、时间戳配置、以及分布式ZK ID生成器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过几天的测试，对 MyCat 使用总结以下几点：</p><p>优势：</p><ul><li>使用较为简便，主要因为是，原理简单（就是SQL变换），并且是国产软件有很多中文资料；</li><li>预留了很多API进行自定义开发；</li><li>纯java实现，有进行源码级别Debug、自定义开发的可能；</li></ul><p>劣势：</p><ul><li>并非真正意义上的分布式数据库，相比Greenplum、TiDB这种真正的分布式方案架构上有先天缺陷（个人认为，Mycat的发展方向路子走偏了）</li><li>有很多功能性的限制，以下是官方权威指南中提到的功能限制（不包括网络上其他人发现的）</li></ul><pre><code>- 跨库Join 功能太弱，只能支持全局表Join或者片内join（Share join支持2个表的跨库join，但是性能堪忧），考虑以下场景MyCat很难胜任：</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- A表：id1 、id2</span></span><br><span class="line"><span class="comment">-- B表: 片键id</span></span><br><span class="line"><span class="comment">-- C表: 片键id</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- E-R join无法同时满足下面二个Join，只能选择将一张表设定成全局表：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A , B <span class="keyword">where</span> A.id1 = B.id;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A , B <span class="keyword">where</span> A.id2 = C.id;</span><br></pre></td></tr></table></figure><pre><code>- Mycat的全局表的一致性检查机制比较简单，且出现不一致时没有自动恢复机制（个人认为：误操作、掉电等场景都有可能出现不一致，Mycat的一致性检查太low了）- 官方文档提到MyCat不支持复杂子查询，但没有给出具体说明（很迷！！）- 保证高可用需要用户自行设计组网方案：MyCat本身不提供后端数据库的HA能力，也不提供MyCat服务本身的HA功能。每个接入的MySQL都需要进行主从复制的配置，而MyCat本身使用HAProxy避免单点故障。（这一点实际上又引申出如何保障mysql高可用的问题，从IData的应用场景来看还是比较复杂的）- Mycat没有提供备份和恢复方案，只能使用mysql的备份工具备份每一个mysql数据库，并且为了保证数据一致性每一次备份需要业务停止写入；- MyCat使用配置文件定义分片策略，如果分片规则变更数据无法同步更新。换句话说，如果生产中发现之前定义的分片不均衡或者节点扩容，那么需要重写整张表。- 分布式事务能力较弱，官方文档提到：Mycat 目前没有出来跨分片的事务强一致性支持，目前单库内部可以保证事务的完整性，如果跨库事务，在执行的时候任何分片出错，可以保证所有分片回滚，但是一旦应用发起commit 指令，无法保证所有分片都成功考虑到某个分片挂的可能性不大所以称为弱xa。（看到一篇blog说MyCat基于 Mysql XA 接口实现分布式事务，但是 Mysql XA 接口本身用户不多，因此性能和可用性都可能存在问题！）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库调研笔记 – MyCat&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MyCat" scheme="https://LinQing2017.github.io/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/25/Greenplum-%E5%88%86%E5%8C%BA%E8%A1%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://LinQing2017.github.io/2019/10/25/Greenplum-分区表介绍/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.716Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>Greenplum 支持分区表，但是<strong>分区</strong>的概念需要和<strong>分布式</strong>区别开，Greenplum中所有表都是分布式的（分布在不同Segment上），但是并非所有表都是分区表。</p><p>分区是进行<strong>逻辑划分</strong>，而分布是表的<strong>物理划分</strong>，前者减少查询的数据扫描量，后者提供并行查询能力。</p><p><img src="https://greenplum.cn/gp6/graphics/partitions.jpg" alt=""></p><ul><li>分区操作会创建一个顶层（父）表以及一层或者多层子表；</li><li>这些父表和子表都可以独立查询，子表看上去和普通表无异；</li><li>使用pg_relation_size函数查询父表的存储空间时，大小为0；</li><li>父表和子表之间存在继承关系（即表结构、NOT NULL，DEFAULT，CHECK三种约束），修改父表的表结构子表会同步修改；</li><li>创建分区后可以用带有PARTITION子句的ALTER TABLE修改父表；</li><li>可以在父表插入语句，或者直接插入到子表。直接插入子表时会触发check检查，如果检查失败会返回一个错误；</li><li>删除父表时，子表会一并删除</li><li>复制表复制表不能进行分区；</li><li>多级分区可以基于同一个分区键，如可以基于年、月、日进行三级分区；</li><li>已有表不能改为分区表，用户需要创建新的表将原有表的数据导入；</li><li>分区表最多能有32,767个分区；</li><li>分区表上的主键或者唯一约束必须包含所有的分区列；</li></ul><p>分区策略：<strong>除非查询优化器能基于查询谓词排除一些分区，否则分区技术不能改进查询性能。</strong></p><p>对外部表进行分区时会产生一些限制：参考<a href="https://greenplum.cn/gp6/ddl/ddl-partition.html#topic80" target="_blank" rel="noopener">分区表的限制</a></p><h2 id="分区操作"><a href="#分区操作" class="headerlink" title="分区操作"></a>分区操作</h2><h3 id="默认分区"><a href="#默认分区" class="headerlink" title="默认分区"></a>默认分区</h3><ul><li>默认分区用来装载其他分区CHECK约束失败的行；</li><li>优化器在扫描时总会扫描默认分区（因此默认分区会影响分区表性能；</li><li>多级分区，一旦存在默认分区，那么每一级都需要保存默认分区；</li><li>含有默认分区时，用户可以从默认分区中分裂出新的分区；</li></ul><h3 id="pg-partitions视图"><a href="#pg-partitions视图" class="headerlink" title="pg_partitions视图"></a>pg_partitions视图</h3><ul><li>pg_partition：跟踪分区表以及它们的继承层次关系。</li><li>pg_partition_templates：展示使用一个子分区模板创建的子分区。</li><li>pg_partition_columns：显示在一个分区设计中用到的分区键列。</li></ul><h3 id="分区表操作"><a href="#分区表操作" class="headerlink" title="分区表操作"></a>分区表操作</h3><p>增加分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设原有分区范围为“2016-01-01 - 2017-02-01”，下面的语句将分区范围拓宽</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> </span><br><span class="line">    <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2017-02-01'</span>) INCLUSIVE </span><br><span class="line">    <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-03-01'</span>) EXCLUSIVE;、</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> </span><br><span class="line">            <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2017-02-01'</span>) INCLUSIVE </span><br><span class="line">            <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-03-01'</span>) EXCLUSIVE</span><br><span class="line">      ( <span class="keyword">SUBPARTITION</span> usa <span class="keyword">VALUES</span> (<span class="string">'usa'</span>), </span><br><span class="line">        <span class="keyword">SUBPARTITION</span> asia <span class="keyword">VALUES</span> (<span class="string">'asia'</span>), </span><br><span class="line">        <span class="keyword">SUBPARTITION</span> europe <span class="keyword">VALUES</span> (<span class="string">'europe'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为sales表的第12分区，添加一个2级分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ALTER</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="keyword">RANK</span>(<span class="number">12</span>))</span><br><span class="line">      <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> africa <span class="keyword">VALUES</span> (<span class="string">'africa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加默认分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> other;</span><br></pre></td></tr></table></figure><p>重命名分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 分区表使用下列命名习惯：&lt;parentname&gt;_&lt;level&gt;_prt_&lt;partition_name&gt;</span></span><br><span class="line"><span class="comment">-- 重命名父表，子表会跟着修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">RENAME</span> <span class="keyword">TO</span> globalsales;</span><br><span class="line"><span class="comment">-- 修改表的分区名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">RENAME</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="string">'2016-01-01'</span>) <span class="keyword">TO</span> jan16;</span><br></pre></td></tr></table></figure><p>删除分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="keyword">RANK</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">-- trancate分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">TRUNCATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="keyword">RANK</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>交换分区(参考<a href="https://greenplum.cn/gp6/ddl/ddl-partition.html#topic80" target="_blank" rel="noopener">用外部表交换叶子子分区</a>)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将分区sales_1_prt_1和jan12表交换，此后jan12表成为sales的分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> jan12 (<span class="keyword">LIKE</span> sales) <span class="keyword">WITH</span> (appendoptimized=<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> jan12 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_1_prt_1 ;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">EXCHANGE</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="built_in">DATE</span> <span class="string">'2012-01-01'</span>) </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">TABLE</span> jan12;</span><br></pre></td></tr></table></figure><p>分裂分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分裂普通分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">SPLIT</span> <span class="keyword">PARTITION</span> <span class="keyword">FOR</span> (<span class="string">'2017-01-01'</span>) <span class="keyword">AT</span> (<span class="string">'2017-01-16'</span>)</span><br><span class="line"><span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> jan171to15, <span class="keyword">PARTITION</span> jan1716to31);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分裂默认分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">SPLIT</span> <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> </span><br><span class="line"><span class="keyword">START</span> (<span class="string">'2017-01-01'</span>) INCLUSIVE </span><br><span class="line"><span class="keyword">END</span> (<span class="string">'2017-02-01'</span>) EXCLUSIVE </span><br><span class="line"><span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> jan17, <span class="keyword">default</span> <span class="keyword">partition</span>);</span><br></pre></td></tr></table></figure><p>修改分区模板：修改后原有的分区不发生变化，参考<a href="https://greenplum.cn/gp6/ddl/ddl-partition.html#topic80" target="_blank" rel="noopener">修改子分区模板</a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>日期范围分区：使用单个date或者timestamp列作为分区键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在[START,END)范围内进行分区，每个分区的长度是‘1 day’，因此产生365个分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="built_in">date</span> <span class="built_in">date</span>, amt <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="built_in">date</span>)</span><br><span class="line">( <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-01-01'</span>) INCLUSIVE  </span><br><span class="line">   <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-01-01'</span>) EXCLUSIVE</span><br><span class="line">   EVERY (<span class="built_in">INTERVAL</span> <span class="string">'1 day'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定生成按月的分区，显示指定分区范围</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="built_in">date</span> <span class="built_in">date</span>, amt <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="built_in">date</span>)</span><br><span class="line">( <span class="keyword">PARTITION</span> Jan16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-01-01'</span>) INCLUSIVE , </span><br><span class="line">  <span class="keyword">PARTITION</span> Feb16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-02-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Mar16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-03-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Apr16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-04-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> May16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-05-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Jun16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-06-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Jul16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-07-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Aug16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-08-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Sep16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-09-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Oct16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-10-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Nov16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-11-01'</span>) INCLUSIVE ,</span><br><span class="line">  <span class="keyword">PARTITION</span> Dec16 <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2016-12-01'</span>) INCLUSIVE </span><br><span class="line">                  <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2017-01-01'</span>) EXCLUSIVE );</span><br></pre></td></tr></table></figure><p>按数字范围分区：表使用单个数字数据类型列作为分区键列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面的建表语句会创建11个分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">rank</span> (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">rank</span> <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, gender </span><br><span class="line"><span class="built_in">char</span>(<span class="number">1</span>), <span class="keyword">count</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">year</span>)</span><br><span class="line">( <span class="keyword">START</span> (<span class="number">2006</span>) <span class="keyword">END</span> (<span class="number">2016</span>) EVERY (<span class="number">1</span>), </span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> extra );</span><br></pre></td></tr></table></figure><p>定义列表分区表：使用任意允许等值比较的数据类型列作为它的分区键列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建rank_1_prt_boys、rank_1_prt_girls、rank_1_prt_other三个分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">rank</span> (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">rank</span> <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, gender </span><br><span class="line"><span class="built_in">char</span>(<span class="number">1</span>), <span class="keyword">count</span> <span class="built_in">int</span> ) </span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span> (gender)</span><br><span class="line">( <span class="keyword">PARTITION</span> girls <span class="keyword">VALUES</span> (<span class="string">'F'</span>), </span><br><span class="line">  <span class="keyword">PARTITION</span> boys <span class="keyword">VALUES</span> (<span class="string">'M'</span>), </span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> other );</span><br></pre></td></tr></table></figure><p>多级分区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于时间和值的多级分区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    trans_id <span class="built_in">int</span>, </span><br><span class="line">    <span class="built_in">date</span> <span class="built_in">date</span>, </span><br><span class="line">    amount <span class="built_in">decimal</span>(<span class="number">9</span>,<span class="number">2</span>), </span><br><span class="line">    region <span class="built_in">text</span></span><br><span class="line">) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (trans_id)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="built_in">date</span>) </span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span> (region)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">TEMPLATE</span> ( </span><br><span class="line">    <span class="keyword">SUBPARTITION</span> usa <span class="keyword">VALUES</span> (<span class="string">'usa'</span>), </span><br><span class="line">    <span class="keyword">SUBPARTITION</span> asia <span class="keyword">VALUES</span> (<span class="string">'asia'</span>), </span><br><span class="line">    <span class="keyword">SUBPARTITION</span> europe <span class="keyword">VALUES</span> (<span class="string">'europe'</span>), </span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">SUBPARTITION</span> other_regions</span><br><span class="line">)(</span><br><span class="line">    <span class="keyword">START</span> (<span class="built_in">date</span> <span class="string">'2011-01-01'</span>) INCLUSIVE</span><br><span class="line">    <span class="keyword">END</span> (<span class="built_in">date</span> <span class="string">'2012-01-01'</span>) EXCLUSIVE</span><br><span class="line">    EVERY (<span class="built_in">INTERVAL</span> <span class="string">'1 month'</span>), </span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> outlying_dates </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 三级分区表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> p3_sales (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, <span class="keyword">month</span> <span class="built_in">int</span>, <span class="keyword">day</span> <span class="built_in">int</span>, region <span class="built_in">text</span>)</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">year</span>)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">month</span>)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">TEMPLATE</span> (</span><br><span class="line">    <span class="keyword">START</span> (<span class="number">1</span>)  <span class="keyword">END</span> (<span class="number">13</span>)  EVERY (<span class="number">1</span>),  <span class="keyword">DEFAULT</span> <span class="keyword">SUBPARTITION</span> other_months </span><br><span class="line">)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span> (region)</span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">TEMPLATE</span> (</span><br><span class="line">    <span class="keyword">SUBPARTITION</span> usa <span class="keyword">VALUES</span> (<span class="string">'usa'</span>),</span><br><span class="line">    <span class="keyword">SUBPARTITION</span> europe <span class="keyword">VALUES</span> (<span class="string">'europe'</span>),</span><br><span class="line">    <span class="keyword">SUBPARTITION</span> asia <span class="keyword">VALUES</span> (<span class="string">'asia'</span>),</span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">SUBPARTITION</span> other_regions </span><br><span class="line">)( </span><br><span class="line">    <span class="keyword">START</span> (<span class="number">2002</span>) <span class="keyword">END</span> (<span class="number">2012</span>) EVERY (<span class="number">1</span>), </span><br><span class="line">    <span class="keyword">DEFAULT</span> <span class="keyword">PARTITION</span> outlying_years </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://greenplum.cn/gp6/ddl/ddl-partition.html" target="_blank" rel="noopener">参考文档</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/23/Greenplum-TPCDS%E6%B5%8B%E8%AF%95/"/>
    <id>https://LinQing2017.github.io/2019/10/23/Greenplum-TPCDS测试/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.716Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h1><p>使用<a href="https://github.com/pivotalguru/TPC-DS/blob/master/rollout.sh" target="_blank" rel="noopener">pivotalguru/TPC-DS</a> 工具进行测试，该工具是一个包含：数据生成、执行SQL、输入报告等功能。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在master节点安装以下工具</span></span><br><span class="line">yum -y install git gcc bc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到gpadmin用户，<span class="built_in">clone</span>工具的执行脚本</span></span><br><span class="line">git clone https://github.com/pivotalguru/TPC-DS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑gpadmin用户的.bashrc文件，指定Greenplum的环境变量</span></span><br></pre></td></tr></table></figure><p>在gpadmin用户目录中，创建脚本测试脚本tpcds.sh，并执行即可以开始测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">REPO="TPC-DS"                         </span><br><span class="line">ADMIN_USER="gpadmin"</span><br><span class="line">INSTALL_DIR="/home/gpadmin/pivotalguru"  # 存放TPC-DS工程的目录</span><br><span class="line">EXPLAIN_ANALYZE="false"</span><br><span class="line">RANDOM_DISTRIBUTION="false"              </span><br><span class="line">MULTI_USER_COUNT="0"                    </span><br><span class="line">GEN_DATA_SCALE="10"                      # 1000 约等于生成1T原始数据</span><br><span class="line">SINGLE_USER_ITERATIONS="1"</span><br><span class="line">RUN_COMPILE_TPCDS="false"</span><br><span class="line">RUN_GEN_DATA="false"</span><br><span class="line">RUN_INIT="true"</span><br><span class="line">RUN_DDL="true"</span><br><span class="line">RUN_LOAD="true"</span><br><span class="line">RUN_SQL="true"</span><br><span class="line">RUN_SINGLE_USER_REPORT="true"</span><br><span class="line">RUN_MULTI_USER="true"</span><br><span class="line">RUN_MULTI_USER_REPORT="true"</span><br><span class="line">RUN_SCORE="true"</span><br><span class="line"></span><br><span class="line">su --session-command="cd \"$INSTALL_DIR/$REPO\"; ./rollout.sh $GEN_DATA_SCALE $EXPLAIN_ANALYZE $RANDOM_DISTRIBUTION $MULTI_USER_COUNT $RUN_COMPILE_TPCDS $RUN_GEN_DATA $RUN_INIT $RUN_DDL $RUN_LOAD $RUN_SQL $RUN_SINGLE_USER_REPORT $RUN_MULTI_USER $RUN_MULTI_USER_REPORT $RUN_SCORE $SINGLE_USER_ITERATIONS" $ADMIN_USER</span><br></pre></td></tr></table></figure><h2 id="pivotalguru-TPC-DS"><a href="#pivotalguru-TPC-DS" class="headerlink" title="pivotalguru/TPC-DS"></a>pivotalguru/TPC-DS</h2><p>测试工具的入口是rollout.sh，该脚本顺序调用每个子目录下的rollout.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 00_compile_tpcds: tpcds源码脚本会编译该目录的C语言源码，用于生成原始数据</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 01_gen_data：数据生成脚本、SQL生成脚本</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      - 工具会在每一个Segment实例安装目录（xxx/pivotalguru）中并行生成原始数据，原始数据的格式为" XXX_&#123;id&#125;_&#123;num_seg&#125;.dat "</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      - 由于SQL脚本中需要处理表的分区信息，因此每次生成数据都会生成相应SQL脚本，生成的SQL被保存到05_sql目录中（sql的模板时TPC-DS本身提供的，位于00_compile_tpcds\query_templates）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 02_init：测试开始前的一些准备工作，包括生成Seg信息、保存配置等</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 03_ddl：创建表</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      - 工具会创建schema：tpcds、ext_tpcds</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      - 默认根据03_ddl\distribution.txt文件进行分片，也可以指定RANDOM_DISTRIBUTION</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 04_load：将外部表导入到Greenplum中</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      - 工具会为每个SegmentHost启动gpfdist服务，并执行SQL直接将外部表导入</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 05_sql：执行单用户测试</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 06_single_user_reports：生成单用户测试报告</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      - 测试信息在schemaname是tpcds_reports的表中</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 07_multi_user：执行多用户测试</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 08_multi_user_reports：生成多用户测试报告</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - 09_score：生成测试评分</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - functions.sh：环境准备脚本，由rollout.sh调用</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># - rollout.sh：测试入口脚本</span></span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>Yarn磁盘管理</title>
    <link href="https://LinQing2017.github.io/2019/10/17/Yarn%E7%9A%84%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>https://LinQing2017.github.io/2019/10/17/Yarn的磁盘管理/</id>
    <published>2019-10-16T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.777Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Yarn磁盘管理"><a href="#Yarn磁盘管理" class="headerlink" title="Yarn磁盘管理"></a>Yarn磁盘管理</h1><p>Yarn中NodeManager使用的最重要的两个本地目录：</p><ul><li><p>yarn.nodemanager.local-dirs：Container的缓存目录</p></li><li><p>yarn.nodemanager.log-dirs：保存容器日志的本地目录，每个nodemanager都会有这样一个目录，目录格式为：application_${appid}/container_{$contid}，其中包含：</p><ul><li>stderr</li><li>stdout</li><li>prelaunch.err</li><li>prelaunch.out</li><li>container-localizer-syslog</li></ul></li></ul><p>通常情况下，Yarn会自动清理这两个目录的日志，涉及到下面的二个参数，日志保留时间为二个参数的时间之和：</p><ul><li>yarn.nodemanager.delete.debug-delay-sec：App完成后DeletionService会在指定时间后删除本地日志。默认值为0</li><li>yarn.nodemanager.log.retain-seconds：保留日志时间，只有当日志聚合关闭时有效。默认值为3小时</li></ul><p>Yarn支持HDFS上的日志聚合功能，逻辑为：Application任务运行时日志写在log-dirs，运行完成以后 DeletionService 服务，把日志移动到HDFS上，然后删除本地日志。</p><p>日志聚合涉及的配置包括：</p><ul><li>yarn.log-aggregation-enable：是否开启日志聚合</li><li>yarn.nodemanager.remote-app-log-dir：聚合根目录</li><li>yarn.nodemanager.remote-app-log-dir-suffix：聚合目录，hdfs上日志保存位置为{yarn.nodemanager.remote-app-log-dir}/${user}/{yarn.nodemanager.remote-app-log-dir-suffix}</li><li>yarn.log-aggregation.retain-seconds：聚合日志保留时间</li><li>yarn.log-aggregation.retain-check-interval-seconds：清理任务运行时间间隔</li></ul><p>Yarn支持对local-dirs和log-dirs进行健康检查，相关配置为yarn.nodemanager.disk-health-checker.XXXXXX：</p><ul><li>min-healthy-disks：log-dir/local-dirs健康目录的最小值，如果低于这个值，nn会被剔除</li><li>max-disk-utilization-per-disk-percentage：监控log-dir和local-dirs的使用空间阈值，高于这个值磁盘被标记成不健康。</li><li>disk-utilization-watermark-low-per-disk-percentage：bad状态目录恢复为可用的空间水线</li><li>min-free-space-per-disk-mb：健康目录的最小剩余空间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Yarn磁盘管理&quot;&gt;&lt;a href=&quot;#Yarn磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;Yarn磁盘管理&quot;&gt;&lt;/a&gt;Yarn磁盘管理&lt;/h1&gt;&lt;p&gt;Yarn中NodeManager使用的最重要的两个本地目
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://LinQing2017.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Yarn" scheme="https://LinQing2017.github.io/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/17/Greenplum-%E8%B5%84%E6%BA%90%E9%98%9F%E5%88%97/"/>
    <id>https://LinQing2017.github.io/2019/10/17/Greenplum-资源队列/</id>
    <published>2019-10-16T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.718Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="资源队列"><a href="#资源队列" class="headerlink" title="资源队列"></a>资源队列</h1><p><strong>资源队列</strong>是Greenplum的<strong>默认资源管理方式</strong>，包括以下特点：</p><ul><li>可以定义多个不同的资源队列，pg_default是默认队列；</li><li>Role需要和一个队列绑定，不明确绑定时和pg_default绑定；</li><li>队列定义了并发数、内存、CPU等资源，ROLE的SQL消耗队列中的资源；</li><li>拥有SUPERUSER属性的角色将会不受资源队列的限制，查询立即执行（经过测试：发现并发数限制对SUPERUSER不起作用）；</li><li>resource_select_only=on时，INSERT、UPDATE、DELETE不会受到资源队列影响；</li><li>在执行EXPLAIN ANALYZE命令期间的SQL不受资源队列影响；</li></ul><p>资源队列包含以下特性：</p><ul><li>MEMORY_LIMIT：每个Segment中所有查询所使用的的内存的量；</li><li>ACTIVE_STATEMENTS：该队列的并发查询限制；</li><li>PRIORITY：队列的CPU优先级，包括LOW、MEDIUM、HIGH、MAX级别，默认为MEDIUM，级别越高CPU使用越优先；</li><li>MAX_COST：优化器评估上限，当优化器对SQL的消耗评估大于这个值时，SQL被队列拒绝。</li></ul><p><strong>默认队列pg_default</strong>的配置为：ACTIVE_STATEMENTS=20、PRIORITY=MEDIUM、没有MEMORY_LIMIT和MAX_COST。</p><p>内存管理相关注意：</p><ul><li><p>MEMORY_LIMIT不设定时，一个资源队列的可用内存大小是statement_mem*ACTIVE_STATEMENTS（statement_mem指定当前会话分配到内存）</p></li><li><p>设定MEMORY_LIMIT时，并行度受到当前使用的内存影响；</p></li><li><p>设定MEMORY_LIMIT时，每个会话分配的内存为MEMORY_LIMIT/ACTIVE_STATEMENTS（不指定statement_mem时）；</p></li><li><p>statement_mem可以覆盖会话的内存分配，取值范围是min(MEMORY_LIMIT, max_statement_mem)，命令为为set statement_mem=’128MB’；</p></li><li><p>配置文件级别也有statement_mem配置，值为125MB（是否生效？？）；</p></li><li><p>队列一旦分配出内存，直到查询结束才回收这一部分配额；</p></li><li><p><strong>gp_vmem_protect_limit</strong>决定了，单个Segment中所有队列的可用总内存；</p></li></ul><p>PRIORITY管理相关注意：</p><ul><li>SQL按照其资源队列的优先权共享可用的CPU资源;</li><li>SQL的复杂度不影响CPU的分配;</li><li>有新的SQL开始运行时，CPU份额将会被重新计算；</li></ul><h2 id="配置资源队列"><a href="#配置资源队列" class="headerlink" title="配置资源队列"></a>配置资源队列</h2><p>相关配置参数，包括以下：</p><ul><li><p>用于资源队列的一般配置：</p><ul><li>max_resource_queues </li><li>max_resource_portals_per_transaction </li><li>resource_select_only </li><li>resource_cleanup_gangs_on_wait </li><li>stats_queue_level </li></ul></li><li><p>内存利用有关配置：</p><ul><li>gp_resqueue_memory_policy </li><li>statement_mem</li><li>max_statement_mem </li><li>gp_vmem_protect_limit </li><li>gp_vmem_idle_resource_timeout（大并发时调整）</li><li>gp_vmem_protect_segworker_cache_limit （大并发时调整）</li><li>shared_buffers: 共享内存缓冲区大小，至少为128MB并且至少为16MB以max_connections。</li></ul></li><li><p>CPU优先级配置：</p><ul><li>gp_resqueue_memory_policy </li><li>gp_resqueue_priority_sweeper_interval </li><li>gp_resqueue_priority_cpucores_per_segment：每个Segment实例分配的CPU核数。Master和Segment的默认值是4，一般需要将HOST的所有CPU都利用上。</li></ul></li></ul><h2 id="SQL命令"><a href="#SQL命令" class="headerlink" title="SQL命令"></a>SQL命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建资源队列</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">RESOURCE</span> QUEUE adhoc <span class="keyword">WITH</span> (ACTIVE_STATEMENTS=<span class="number">3</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">RESOURCE</span> QUEUE myqueue <span class="keyword">WITH</span> (ACTIVE_STATEMENTS=<span class="number">20</span>, </span><br><span class="line">MEMORY_LIMIT=<span class="string">'2000MB'</span>);</span><br><span class="line"><span class="comment">-- 设定优先级</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">RESOURCE</span> QUEUE adhoc <span class="keyword">WITH</span> (<span class="keyword">PRIORITY</span>=<span class="keyword">LOW</span>);</span><br><span class="line"><span class="comment">-- 设定并发数</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">RESOURCE</span> QUEUE reporting <span class="keyword">WITH</span> (ACTIVE_STATEMENTS=<span class="number">20</span>);</span><br><span class="line"><span class="comment">-- 关联队列和role</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLE</span> <span class="keyword">name</span> <span class="keyword">RESOURCE</span> QUEUE queue_name;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="keyword">name</span> <span class="keyword">WITH</span> LOGIN <span class="keyword">RESOURCE</span> QUEUE queue_name;</span><br><span class="line"><span class="comment">-- 移除资源队列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLE</span> role_name <span class="keyword">RESOURCE</span> QUEUE <span class="keyword">none</span>;</span><br><span class="line"><span class="comment">-- 删除资源队列</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">RESOURCE</span> QUEUE <span class="keyword">name</span>;</span><br><span class="line"><span class="comment">-- 查看ROLE绑定的资源队列</span></span><br><span class="line"><span class="keyword">SELECT</span> rolname, rsqname <span class="keyword">FROM</span> pg_roles, </span><br><span class="line">          gp_toolkit.gp_resqueue_status </span><br><span class="line">   <span class="keyword">WHERE</span> pg_roles.rolresqueue=gp_toolkit.gp_resqueue_status.queueid;</span><br></pre></td></tr></table></figure><h2 id="查看队列中的语句和资源队列状态"><a href="#查看队列中的语句和资源队列状态" class="headerlink" title="查看队列中的语句和资源队列状态"></a>查看队列中的语句和资源队列状态</h2><ul><li><p>gp_toolkit.gp_resqueue_status可以查看队列资源的使用情况；</p></li><li><p>stats_queue_level = on可以收集统计信息和性能，通过pg_stat_resqueues可以查看收集到的信息；</p></li><li><p>gp_toolkit.gp_locks_on_resqueue可以查看等待的SQL；</p></li><li><p>参看当前活跃或者等待的SQL，如果需要结束这些SQL执行pg_cancel_backend(31905)；</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_stat_activity.pid,rolname, rsqname,granted, datname,<span class="keyword">query</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">   pg_roles, gp_toolkit.gp_resqueue_status, pg_locks, pg_stat_activity </span><br><span class="line"><span class="keyword">WHERE</span> pg_roles.rolresqueue=pg_locks.objid </span><br><span class="line">   <span class="keyword">AND</span> pg_locks.objid=gp_toolkit.gp_resqueue_status.queueid</span><br><span class="line">   <span class="keyword">AND</span> pg_stat_activity.pid=pg_locks.pid</span><br><span class="line">   <span class="keyword">AND</span> pg_stat_activity.usename=pg_roles.rolname;</span><br></pre></td></tr></table></figure><ul><li>gp_toolkit.gp_resq_priority_statement可以查看SQL优先级，超级用户可以修改某个SQL的优先级（gp_adjust_priority函数）</li></ul><h2 id="内存配置对资源队列影响："><a href="#内存配置对资源队列影响：" class="headerlink" title="内存配置对资源队列影响："></a>内存配置对资源队列影响：</h2><p>主要关注：vm.overcommit_ratio、gp_vmem_protect_limit、shared_buffers</p><ul><li>主机内存，Segment主机的可用内存，主要由<strong>vm.overcommit_ratio</strong>配置控制（此处讨论的情况是Segment主机单独部署的情形）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通常配置95即可，若果是资源组模式可以配置50</span></span><br><span class="line">vm.overcommit_ratio = 95</span><br></pre></td></tr></table></figure><ul><li>Segment实例内存，每个Segment的可用内存由<strong>gp_vmem_protect_limit</strong>控制：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gp_vmem_rq是GP使用的内存，计算公式为（0.95*RAM - 7.5GB）/1.7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mirror不计入活跃内存</span></span><br><span class="line">gp_vmem_protect_limit = gp_vmem_rq / 最大活跃Segment数目</span><br></pre></td></tr></table></figure><ul><li>shared_buffers: 共享内存缓冲区大小，至少为128MB并且至少为16MB以max_connections。</li></ul><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="1-基线硬件性能"><a href="#1-基线硬件性能" class="headerlink" title="1. 基线硬件性能"></a>1. 基线硬件性能</h2><p>gpcheckperf 可以进行：</p><ul><li>磁盘I/O测试（dd测试）：默认情况下，在会在磁盘目录下读写2倍内存大小的文件</li><li>内存带宽测试（流) ：使用STREAM基准程序来测量可持续的内存带宽（以MB/s为单位），该测试不涉及CPU计算性能。</li><li>网络性能测试（gpnetbench*）：当前主机发送5秒钟的数据流到测试中包含的每台远程主机。数据被并行传输到每台远程主机，支持串行（一台一台通信）、并行、全矩阵测试。</li></ul><p>测试命令：<a href="https://gp-docs-cn.github.io/docs/utility_guide/admin_utilities/gpcheckperf.html" target="_blank" rel="noopener">参考</a></p><h2 id="2-CPU带宽与内存带宽的计算"><a href="#2-CPU带宽与内存带宽的计算" class="headerlink" title="2. CPU带宽与内存带宽的计算"></a>2. CPU带宽与内存带宽的计算</h2><p>内存带宽：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存带宽=内存（等效）频率（内存工作频率X倍频，DDR内存为2，DDR2内存为4，DDR3内存为8）X位宽/8。</span><br></pre></td></tr></table></figure><p>CPU的工作频率涉及<strong>主频、外频、倍频</strong>三个概念</p><pre><code>- 主频：CPU自身的工作频率- 外频：电脑主板提供的系统总线频率，外频是其他组件和CPU通信的基准（lscpu |grep &quot;CPU MHz&quot;，外频可能因为一些其他原因不断变化）- 倍频：主频/外频</code></pre><p>CPU的带宽一般指：CPU与北桥数据交换的速度，也叫作<strong>前端总线FSB</strong>。早期，FSB和外频一致的，使用QDR技术后，前端总线的频率成为外频的两倍或者是四倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intel处理器前端总线（FSB）= 处理器前端总线频率（MHz，处理器外频X4）X位宽（Bit）/8</span><br></pre></td></tr></table></figure><p>参考:<a href="https://www.cnblogs.com/l1pe1/archive/2012/02/02/2335557.html" target="_blank" rel="noopener">PC总线带宽与内存带宽的计算</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/11/Greenplum-%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>https://LinQing2017.github.io/2019/10/11/Greenplum-导入导出/</id>
    <published>2019-10-10T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.717Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="数据装载"><a href="#数据装载" class="headerlink" title="数据装载"></a>数据装载</h1><h2 id="1-INSERT语句"><a href="#1-INSERT语句" class="headerlink" title="1. INSERT语句"></a>1. INSERT语句</h2><p>INSERT语句只适合在小规模的堆表场景中使用，并且有以下特点：</p><ul><li>单个INSERT命令中插入多行，如：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (product_no, <span class="keyword">name</span>, price) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'Cheese'</span>, <span class="number">9.99</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'Bread'</span>, <span class="number">1.99</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'Milk'</span>, <span class="number">2.99</span>);</span><br></pre></td></tr></table></figure></li><li>对于追加优化表， Greenplum数据库支持最多127个并发INSERT 事务插入到一个追加优化表。</li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>通过pgbench和sysbench进行基于INSERT、UPDATE等简单SQL的性能测试，有以下发现：</p><ul><li>测试环境（32核CPU）中插入性能的瓶颈是CPU，50个线程时，单表TPS为15000~16000，单表单线程TPS为500。PS：单块SSD似乎最先到达瓶颈，但是对Greenplum进行扩容性能没有明显提升。</li><li><strong>关闭optimizer配置能够极大提升简单SQL的性能，测试中optimizer配置开启时性能只有原来20%，并且巨量消耗Master的CPU资源。PS：这个配置默认开启！</strong></li><li>Master节点上每个Client连接会产生多个Postgres进程（似乎和Segment数量有关）</li><li>测试中一条INSERT插入多行数据对TPS影响不大</li><li>gp_enable_global_deadlock_detector = on 时可以极大的提升UPDATE操作的性能（10倍以上）</li></ul><p>关于OLTP的性能测试，Greenplum官方给出了基于Greenplum 6的测试教程，测试在48核的 Master上得到了单表18000 TPS以上的性能。测试结果和实际基本符合。</p><p>参考：<a href="https://greenplum.org/oltp-workload-performance-improvement-in-greenplum-6/" target="_blank" rel="noopener">官方文档</a>、<a href="https://greenplum.cn/2019/05/14/greenplum-6-oltp-60x/" target="_blank" rel="noopener">中文社区翻译</a></p><h2 id="2-COPY语句"><a href="#2-COPY语句" class="headerlink" title="2. COPY语句"></a>2. COPY语句</h2><p> COPY命令是非并行操作，数据流需要通过Master实例。</p><ul><li>COPY只能用于表，不能用于视图。</li><li>，支持常用的文件格式，如：txt、sql、csv、压缩文件、二进制格式等</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- COPY 语句只能在master节点上运行</span></span><br><span class="line">COPY table_name FROM '/path/to/filename' <span class="keyword">WITH</span> (<span class="keyword">FORMAT</span> csv);</span><br><span class="line"><span class="comment">-- \copy 语句可以在client节点上运行，其基于COPY FROM STDIN语句从STDIN读取输入并发送给Master</span></span><br><span class="line">\copy table_name FROM '/path/to/filename';</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用COPY命令导出数据</span></span><br><span class="line">COPY (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pgbench_accounts <span class="keyword">limit</span> <span class="number">10</span>) <span class="keyword">TO</span> <span class="string">'/home/gpadmin/pgbench_accounts.csv'</span> <span class="keyword">WITH</span> csv;</span><br></pre></td></tr></table></figure><p>默认情况下，COPY会在第一个错误处停止操作：如果数据包含一个错误，该操作失败并且没有数据被装载(即没有一条数据被导入)。</p><p>用户可以使用单行错误隔离模式，Greenplum会跳过包含格式错误的行并且装载正确格式化的行。需要注意的是：这里的错误指数据格式的错误，不包含约束错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用单行错误隔离模式，每个segment容许10行错误</span></span><br><span class="line">COPY country FROM '/data/gpdb/country_data' </span><br><span class="line">   <span class="keyword">WITH</span> DELIMITER <span class="string">'|'</span> <span class="keyword">LOG</span> <span class="keyword">ERRORS</span></span><br><span class="line">   <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="number">10</span> <span class="keyword">ROWS</span>;</span><br></pre></td></tr></table></figure><h3 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h3><p>使用COPY命令<strong>单线程</strong>，导入<strong>1亿</strong>条数据，数据原始大小9.7GB，用时136692.713 ms，平均<strong>731567条/s</strong>。</p><p>测试过程中，磁盘性能优先达到瓶颈。</p><p>调优建议：</p><ul><li>在装载数据到新表中时，最后创建索引。</li><li>装载完成后执行VACUUM ANALYZE来为查询优化器更新表统计信息</li><li>在装载错误后运行VACUUM，清理缓存表。<h2 id="3-外部表并行读写"><a href="#3-外部表并行读写" class="headerlink" title="3. 外部表并行读写"></a>3. 外部表并行读写</h2></li></ul><p>通过外部表，可以使向Greenplum导入导出数据并行化，使Greenplum真正具备并行读写的能力。</p><p>导入数据：</p><pre><code>- 准备数据文件- 创建外部表（初次导入时还要创建数据表）- INSERT INTO tablename  SELECT * from tablename_ext_temp;- 删除外部表、外部数据文件</code></pre><h3 id="外部表"><a href="#外部表" class="headerlink" title="外部表"></a>外部表</h3><p>根据外部表允许的操作，包括：</p><ul><li>可读外部表：仅允许SELECT操作。</li><li>可写外部表：仅允许INSERT操作</li></ul><p>根据外部表数据源的状态，包括：</p><ul><li><p>普通（基于文件的）：访问静态平面文件</p></li><li><p>Web（基于Web的）：访问动态数据源</p><ul><li><p>基于命令的web表：建表时将table关联到可执行脚本，每次查询时基于脚本的返回结果，因此该表对应的返回值是动态的，用户可以指定master或者特定segments运行这个脚本。</p></li><li><p>基于URL的web表：定义表时LOCATION里定义基于http://协议的web服务文件路径，指定的http地址数目取决于GP集群中的Segment数目。</p></li></ul></li></ul><p>当前支持的外部表协议：</p><table><thead><tr><th>协议类型</th><th>表类型</th><th>数据存放位置</th><th>说明</th></tr></thead><tbody><tr><td>file</td><td>只能是可读表</td><td>Segment主机</td><td>每个Segment只能处理一个外部文件，所以单个Seg-Host上的文件数目，取决于运行Segment实例数目</td></tr><tr><td>gpfdist/gpfdists</td><td>可读/写表</td><td>gpfdist服务器（一个或者多个）</td><td>跨主机协议、支持数据压缩和数据转换</td></tr><tr><td>pxf、S3</td><td>自定义接口</td><td>Hadoop系统、对象存储等</td><td></td></tr></tbody></table><p>定义外部表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file 外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> ext_expenses (</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">text</span>, <span class="built_in">date</span> <span class="built_in">date</span>, amount float4, <span class="keyword">category</span> <span class="built_in">text</span>, desc1 <span class="built_in">text</span> ) </span><br><span class="line">LOCATION (<span class="string">'file://host1:5432/data/expense/*.csv'</span>, </span><br><span class="line">          <span class="string">'file://host2:5432/data/expense/*.csv'</span>, </span><br><span class="line">          <span class="string">'file://host3:5432/data/expense/*.csv'</span>) </span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'CSV'</span> (HEADER); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于命令的web外部表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> log_output </span><br><span class="line">    (linenum <span class="built_in">int</span>, message <span class="built_in">text</span>) </span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'/var/load_scripts/get_log_data.sh'</span> <span class="keyword">ON</span> HOST</span><br><span class="line">    <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">'|'</span>);</span><br></pre></td></tr></table></figure><h3 id="gpfdist"><a href="#gpfdist" class="headerlink" title="gpfdist"></a>gpfdist</h3><p>通常情况下，gpfdist作为一个第三方服务运行在Greenplum集群之外的服务器上（一般是ETL服务器）。Greenplum和gpfdist服务之间通过HTTP/HTTPS协议通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动gpfdist服务，配置数据目录和日志目（建议先安装Greenplum，否则启动可能缺依赖）</span></span><br><span class="line">gpfdist -d /data/data_ssd/gpfdist_files -p 18081 -l /var/log/gpfdist/gpfdist.log &amp;</span><br></pre></td></tr></table></figure><p>gpfdist的优势：</p><ul><li>外部文件支持压缩、CSV等格式</li><li>支持将外部XML（json）文件读入Greenplum数据库（通过配置YAML格式的文件）</li><li>外部表可以连接一个或多个gpfdist实例（无论一个还是多个，Segment连接外部表时均是并行的）</li><li>一台ETL服务器上可以运行多个gpfdist实例（不同的数据目录，以及端口）</li></ul><p>性能控制：</p><ul><li>gp_external_max_segs：数控制能同时访问单一gpfdist实例的Segment实例数量，默认64个；</li></ul><h3 id="gpload"><a href="#gpload" class="headerlink" title="gpload"></a>gpload</h3><p>gpload是Greenplum提供的并行导入工具，工作原理基于gpfdist，用户通过定义YAML文件来控制gpload导入的表结构。</p><ul><li>支持多种表导入模式<ul><li>INSERT</li><li>UPDATE</li><li>MERGE</li></ul></li><li>gpload会在外部文件上重新拉起gpfdist进程，知道导入完成</li><li>gpload会创建一张临时外部表，因此执行用户要有建外部表权限，以及写入数据权限</li></ul><p>gpload的导入命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpload -f insert.yaml -l gpload.log</span><br></pre></td></tr></table></figure><p>gpload使用的控制文件如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">VERSION:</span> <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">DATABASE:</span> <span class="string">pgbench</span></span><br><span class="line"><span class="attr">USER:</span> <span class="string">benchtest</span></span><br><span class="line"><span class="attr">HOST:</span> <span class="number">172.24</span><span class="number">.9</span><span class="number">.12</span></span><br><span class="line"><span class="attr">PORT:</span> <span class="number">5432</span></span><br><span class="line"><span class="attr">GPLOAD:</span></span><br><span class="line"><span class="attr">   INPUT:</span></span><br><span class="line"><span class="attr">    - SOURCE:</span></span><br><span class="line"><span class="attr">         LOCAL_HOSTNAME:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="number">172.24</span><span class="number">.33</span><span class="number">.35</span></span><br><span class="line"><span class="attr">         PORT:</span> <span class="number">19090</span></span><br><span class="line"><span class="attr">         FILE:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">/data/data_ssd/gpfdist_files/pgbench/pgbench_accounts/*</span></span><br><span class="line"><span class="attr">    - COLUMNS:</span></span><br><span class="line"><span class="attr">               - aid:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">               - bid:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">               - abalance:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">               - filler:</span> <span class="string">character(84)</span></span><br><span class="line"><span class="attr">    - FORMAT:</span> <span class="string">csv</span></span><br><span class="line"><span class="attr">    - DELIMITER:</span> <span class="string">','</span></span><br><span class="line"><span class="attr">    - QUOTE:</span> <span class="string">'"'</span></span><br><span class="line"><span class="attr">    - HEADER:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">   OUTPUT:</span></span><br><span class="line"><span class="attr">    - TABLE:</span> <span class="string">public.pgbench_accounts_gpload_ins</span></span><br><span class="line"><span class="attr">    - MODE:</span> <span class="string">INSERT</span></span><br></pre></td></tr></table></figure><p>详细参数说明参考<a href="https://gp-docs-cn.github.io/docs/utility_guide/admin_utilities/gpload.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="性能测试-2"><a href="#性能测试-2" class="headerlink" title="性能测试"></a>性能测试</h3><p>使用<strong>单点gpfdist服务</strong>将外部表导入为GP的系统，导入<strong>1亿</strong>条数据，数据原始大小9.7GB，用时35962.171 ms，平均<strong>2780699条/s</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建内部堆表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pgbench_accounts (</span><br><span class="line">    aid <span class="built_in">integer</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    bid <span class="built_in">integer</span>,</span><br><span class="line">    abalance <span class="built_in">integer</span>,</span><br><span class="line">    filler <span class="built_in">character</span>(<span class="number">84</span>)</span><br><span class="line">) <span class="keyword">WITH</span> (fillfactor=<span class="string">'100'</span>) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (aid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  创建外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> pgbench_accounts_ext_tmp ( </span><br><span class="line">    aid <span class="built_in">integer</span>, </span><br><span class="line">    bid <span class="built_in">integer</span>, </span><br><span class="line">    abalance <span class="built_in">integer</span>, </span><br><span class="line">    filler <span class="built_in">character</span>(<span class="number">84</span>) </span><br><span class="line">) LOCATION (<span class="string">'gpfdist://172.24.33.35:18081/pgbench/pgbench_accounts/*'</span>) <span class="keyword">FORMAT</span> <span class="string">'csv'</span>;</span><br><span class="line"><span class="comment">-- 导入堆表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pgbench_accounts  <span class="keyword">SELECT</span> * <span class="keyword">from</span> pgbench_accounts_ext_tmp;</span><br></pre></td></tr></table></figure><h1 id="使用gpfdist和gpload转换外部数据"><a href="#使用gpfdist和gpload转换外部数据" class="headerlink" title="使用gpfdist和gpload转换外部数据"></a>使用gpfdist和gpload转换外部数据</h1><p>Greenplum支持将任意格式的数据导入到数据中，或者将数据库中表以任意格式导出，以下说明导入XML到Greenplum的表中。</p><p>XML文件内容（文件名为pricerecord.xml）如下，包含：itemnumber和price两个字段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prices</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemnumber</span>&gt;</span>708421<span class="tag">&lt;/<span class="name">itemnumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>19.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemnumber</span>&gt;</span>708466<span class="tag">&lt;/<span class="name">itemnumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>59.25<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pricerecord</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemnumber</span>&gt;</span>711121<span class="tag">&lt;/<span class="name">itemnumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>24.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pricerecord</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">prices</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的表结构为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prices (</span><br><span class="line">itemnumber <span class="built_in">integer</span>,       </span><br><span class="line">price      <span class="built_in">decimal</span>        </span><br><span class="line">) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (itemnumber);</span><br></pre></td></tr></table></figure><p>进行导入前，用户需要准备一个脚本工具解析XML文档，该工具不限格式，应当有如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要注意的是：工具输出中不能带空行</span></span><br><span class="line">708421|19.99</span><br><span class="line">708466|59.25</span><br><span class="line">711121|24.99</span><br></pre></td></tr></table></figure><p>用户可以定义config.xml文件，将声明脚本解析工具，该文件中的参数<a href="https://greenplum.cn/gp6/load/topics/transforming-xml-data.html" target="_blank" rel="noopener">配置文件格式</a>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">VERSION:</span> <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">TRANSFORMATIONS:</span></span><br><span class="line"><span class="attr">    transformation_name1:</span>              <span class="comment"># 转换名称</span></span><br><span class="line"><span class="attr">        TYPE:</span>     <span class="string">input</span>               <span class="comment"># 转换类型，input或者output</span></span><br><span class="line"><span class="attr">        COMMAND:</span>  <span class="string">/bin/sh</span> <span class="string">trans_script.sh</span> <span class="string">%filename%</span>     <span class="comment"># 转换命令</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    transformation_name2:</span>         </span><br><span class="line"><span class="attr">        TYPE:</span>     <span class="string">output</span>              </span><br><span class="line"><span class="attr">        COMMAND:</span>  <span class="string">/bin/sh</span> <span class="string">trans_script.sh</span> <span class="string">%filename%</span> </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-</span> <span class="string">COMMAND中的</span> <span class="string">%filename%</span> <span class="string">在执行是被gpload配置文件中的定义替换</span></span><br></pre></td></tr></table></figure><p>创建gpload配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">VERSION:</span> <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">DATABASE:</span> <span class="string">pgbench</span></span><br><span class="line"><span class="attr">USER:</span> <span class="string">benchtest</span></span><br><span class="line"><span class="attr">HOST:</span> <span class="number">172.24</span><span class="number">.9</span><span class="number">.12</span></span><br><span class="line"><span class="attr">PORT:</span> <span class="number">5432</span></span><br><span class="line"><span class="attr">GPLOAD:</span></span><br><span class="line"><span class="attr">   INPUT:</span></span><br><span class="line"><span class="attr">     - TRANSFORM_CONFIG:</span> <span class="string">config.yaml</span>   <span class="comment"># 定义转换配置</span></span><br><span class="line"><span class="attr">     - TRANSFORM:</span> <span class="string">prices_input</span>         <span class="comment"># 定义要使用的转换</span></span><br><span class="line"><span class="attr">     - SOURCE:</span></span><br><span class="line"><span class="attr">         LOCAL_HOSTNAME:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="number">172.24</span><span class="number">.9</span><span class="number">.12</span></span><br><span class="line"><span class="attr">         PORT:</span> <span class="number">19090</span></span><br><span class="line"><span class="attr">         FILE:</span> </span><br><span class="line"><span class="bullet">           -</span> <span class="string">pricerecord.xml</span>           <span class="comment"># 待导入的xml文件（替换%filename% ）</span></span><br><span class="line"><span class="attr">     - COLUMNS:</span></span><br><span class="line"><span class="attr">         - itemnumber:</span> <span class="string">integer</span></span><br><span class="line"><span class="attr">         - price:</span> <span class="string">decimal</span></span><br><span class="line"><span class="attr">     - FORMAT:</span> <span class="string">TEXT</span></span><br><span class="line"><span class="attr">     - DELIMITER:</span> <span class="string">'|'</span></span><br><span class="line"><span class="attr">     - QUOTE:</span> <span class="string">'"'</span></span><br><span class="line"><span class="attr">     - HEADER:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">   OUTPUT:</span></span><br><span class="line"><span class="attr">     - TABLE:</span> <span class="string">public.prices</span></span><br><span class="line"><span class="attr">     - MODE:</span> <span class="string">INSERT</span></span><br></pre></td></tr></table></figure><p><strong>PS：用户也可以执行 gpfdist -c config.yaml 将装换加载到gpfdist中，创建外表直接读取xml文档</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> READABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> prices_readable (<span class="keyword">LIKE</span> prices)</span><br><span class="line">   LOCATION (<span class="string">'gpfdist://hostname:8080/prices.xml#transform=prices_input'</span>)</span><br><span class="line">   <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">'|'</span>)</span><br><span class="line">   <span class="keyword">LOG</span> <span class="keyword">ERRORS</span> <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h1><p>使用<strong>CREATE WRITABLE EXTERNAL TABLE</strong>命令定义外部表时，可以将数据导出到本地。</p><ul><li>Segment把数据发送到gpfdist，后者会把数据写到指定的文件中；</li><li>外部表定义中定义多个gpfdist URI时，输出数据划分到多个文件之间；</li><li>可写的外部Web表把输出行发送到一个脚本（或者应用）作为输入。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写入到gpfdist的外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> unload_expenses  ( <span class="keyword">LIKE</span> expenses ) </span><br><span class="line">   LOCATION (<span class="string">'gpfdist://etlhost-1:8081/expenses1.out'</span>, </span><br><span class="line">             <span class="string">'gpfdist://etlhost-2:8081/expenses2.out'</span>)</span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">','</span>) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (exp_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写入到HDFS的外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> unload_expenses  ( <span class="keyword">LIKE</span> expenses ) </span><br><span class="line">   LOCATION (<span class="string">'pxf://dir/path?PROFILE=hdfs:text'</span>) </span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> (DELIMITER <span class="string">','</span>) <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (exp_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可写外部web表，EXECUTE程序处理insert到这个表的每一行</span></span><br><span class="line"><span class="comment">-- 参考https://greenplum.cn/gp6/load/topics/g-defining-a-command-based-writable-external-web-table.html</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> <span class="keyword">output</span> (<span class="keyword">output</span> <span class="built_in">text</span>) </span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'export PATH=$PATH:/home/gpadmin/programs; myprogram.sh'</span> </span><br><span class="line"><span class="keyword">FORMAT</span> <span class="string">'TEXT'</span> <span class="keyword">DISTRIBUTED</span> RANDOMLY</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向外部表写入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> writable_ext_table <span class="keyword">TO</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> writable_ext_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> regular_table;</span><br></pre></td></tr></table></figure><p>直接用COPY命令也可以导出，但是此时性能瓶颈受限于Master服务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> country <span class="keyword">WHERE</span> country_name <span class="keyword">LIKE</span> <span class="string">'A%'</span>) </span><br><span class="line"><span class="keyword">TO</span> <span class="string">'/home/gpadmin/a_list_countries.out'</span>;</span><br></pre></td></tr></table></figure><h1 id="PGBench测试工具"><a href="#PGBench测试工具" class="headerlink" title="PGBench测试工具"></a>PGBench测试工具</h1><p>pgbench是 PostgreSQL 上自带一个基准测试工具，能够让用户并发执行多次SQL语句，并且统计测试的TPS。</p><p>默认情况下，如果用户不提供自定义的测试SQL，那么测试时使用TPC-B方式进行OLTP测试，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 初始化测试数据库，比例因子-s（系数是10万），执行后pgbench中包括以下几张表：</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  table                   # of rows</span></span><br><span class="line"><span class="comment">--  ---------------------------------</span></span><br><span class="line"><span class="comment">--  pgbench_branches        1 * 1000</span></span><br><span class="line"><span class="comment">--  pgbench_tellers         10 * 1000</span></span><br><span class="line"><span class="comment">--  pgbench_accounts        100000 * 1000</span></span><br><span class="line"><span class="comment">--  pgbench_history         0 * 1000</span></span><br><span class="line"></span><br><span class="line">pgbench -i -s 1000 pgbench</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重要的测试选项包括-c（客户端数量）、 -t（事务数量）、-T（时间限制）以及-f（指定一个自定义脚本文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- pgbench 默认有三个内建脚本，分别是：tpcb-like、simple-update、select-only</span></span><br><span class="line">pgbench -c 100 -j 100 -r -T 60 -P 1 -s 1000 -b tpcb-like pgbench</span><br><span class="line">pgbench -c 100 -j 100 -r -T 60 -P 1 -s 1000 -b simple-<span class="keyword">update</span> pgbench</span><br><span class="line">pgbench -c <span class="number">100</span> -j <span class="number">100</span> -r -T <span class="number">60</span> -P <span class="number">1</span> -s <span class="number">1000</span> -b <span class="keyword">select</span>-<span class="keyword">only</span> pgbench</span><br></pre></td></tr></table></figure><p>以下是自定义测试脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\set scale 10000</span><br><span class="line">\set nbranches 1 * :scale</span><br><span class="line">\set ntellers 10 * :scale</span><br><span class="line">\set naccounts 100000 * :scale</span><br><span class="line">\set aid random(1,:naccounts)</span><br><span class="line">\set bid random(1,:nbranches)</span><br><span class="line">\set tid random(1,:ntellers)</span><br><span class="line">\set delta random(-5000,5000)</span><br><span class="line"></span><br><span class="line">INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="附：测试环境"><a href="#附：测试环境" class="headerlink" title="附：测试环境"></a>附：测试环境</h2><p>服务器：6 * 3 Segment（Master和Segment混合部署，并且共用一块SSD，并且配置mirror）<br>CPU：Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz 32核<br>内存：  125G<br>网络：10GB光纤</p><h2 id="附：创建外部表"><a href="#附：创建外部表" class="headerlink" title="附：创建外部表"></a>附：创建外部表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通可读外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> [READABLE] <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> table_name    </span><br><span class="line">    ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">      LOCATION (<span class="string">'file://seghost[:port]/path/file'</span> [, ...])</span><br><span class="line">        | (<span class="string">'gpfdist://filehost[:port]/file_pattern[#transform]'</span></span><br><span class="line">        | (<span class="string">'gpfdists://filehost[:port]/file_pattern[#transform]'</span></span><br><span class="line">            [, ...])</span><br><span class="line">        | (<span class="string">'gphdfs://hdfs_host[:port]/path/file'</span>)</span><br><span class="line">      <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'CSV'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">column</span> [, ...]]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'AVRO'</span></span><br><span class="line">           | <span class="string">'PARQUET'</span></span><br><span class="line"> </span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">     [ <span class="keyword">ENCODING</span> <span class="string">'encoding'</span> ]</span><br><span class="line">     [ [<span class="keyword">LOG</span> <span class="keyword">ERRORS</span> [<span class="keyword">INTO</span> error_table]] <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="keyword">count</span></span><br><span class="line">       [<span class="keyword">ROWS</span> | <span class="keyword">PERCENT</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- web可读外部表，每次读的数据动态变化</span></span><br><span class="line"><span class="keyword">CREATE</span> [READABLE] <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> table_name    </span><br><span class="line">   ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">      LOCATION (<span class="string">'http://webhost[:port]/path/file'</span> [, ...])</span><br><span class="line">    | <span class="keyword">EXECUTE</span> <span class="string">'command'</span> [<span class="keyword">ON</span> <span class="keyword">ALL</span></span><br><span class="line">                          | <span class="keyword">MASTER</span></span><br><span class="line">                          | number_of_segments</span><br><span class="line">                          | HOST [<span class="string">'segment_hostname'</span>]</span><br><span class="line">                          | <span class="keyword">SEGMENT</span> segment_id ]</span><br><span class="line">      <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'CSV'</span></span><br><span class="line">            [( [HEADER]</span><br><span class="line">               [QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">column</span> [, ...]]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>]</span><br><span class="line">               [<span class="keyword">NEWLINE</span> [ <span class="keyword">AS</span> ] <span class="string">'LF'</span> | <span class="string">'CR'</span> | <span class="string">'CRLF'</span>]</span><br><span class="line">               [FILL <span class="keyword">MISSING</span> <span class="keyword">FIELDS</span>] )]</span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">     [ <span class="keyword">ENCODING</span> <span class="string">'encoding'</span> ]</span><br><span class="line">     [ [<span class="keyword">LOG</span> <span class="keyword">ERRORS</span> [<span class="keyword">INTO</span> error_table]] <span class="keyword">SEGMENT</span> <span class="keyword">REJECT</span> <span class="keyword">LIMIT</span> <span class="keyword">count</span></span><br><span class="line">       [<span class="keyword">ROWS</span> | <span class="keyword">PERCENT</span>] ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 普通可写外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">    ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">     LOCATION(<span class="string">'gpfdist://outputhost[:port]/filename[#transform]'</span></span><br><span class="line">      | (<span class="string">'gpfdists://outputhost[:port]/file_pattern[#transform]'</span></span><br><span class="line">          [, ...])</span><br><span class="line">      | (<span class="string">'gphdfs://hdfs_host[:port]/path'</span>)</span><br><span class="line">      <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">               [( [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>] )]</span><br><span class="line">          | <span class="string">'CSV'</span></span><br><span class="line">               [([QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> QUOTE <span class="keyword">column</span> [, ...]] ]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>] )]</span><br><span class="line">           | <span class="string">'AVRO'</span></span><br><span class="line">           | <span class="string">'PARQUET'</span></span><br><span class="line"> </span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">    [ <span class="keyword">ENCODING</span> <span class="string">'write_encoding'</span> ]</span><br><span class="line">    [ <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">column</span>, [ ... ] ) | <span class="keyword">DISTRIBUTED</span> RANDOMLY ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- web可写外部表</span></span><br><span class="line"><span class="keyword">CREATE</span> WRITABLE <span class="keyword">EXTERNAL</span> WEB <span class="keyword">TABLE</span> table_name</span><br><span class="line">    ( column_name data_type [, ...] | <span class="keyword">LIKE</span> other_table )</span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'command'</span> [<span class="keyword">ON</span> <span class="keyword">ALL</span>]</span><br><span class="line">    <span class="keyword">FORMAT</span> <span class="string">'TEXT'</span></span><br><span class="line">               [( [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span> | <span class="string">'OFF'</span>] )]</span><br><span class="line">          | <span class="string">'CSV'</span></span><br><span class="line">               [([QUOTE [<span class="keyword">AS</span>] <span class="string">'quote'</span>]</span><br><span class="line">               [DELIMITER [<span class="keyword">AS</span>] <span class="string">'delimiter'</span>]</span><br><span class="line">               [<span class="literal">NULL</span> [<span class="keyword">AS</span>] <span class="string">'null string'</span>]</span><br><span class="line">               [<span class="keyword">FORCE</span> QUOTE <span class="keyword">column</span> [, ...]] ]</span><br><span class="line">               [ESCAPE [<span class="keyword">AS</span>] <span class="string">'escape'</span>] )]</span><br><span class="line">           | <span class="string">'CUSTOM'</span> (Formatter=&lt;formatter specifications&gt;)</span><br><span class="line">    [ <span class="keyword">ENCODING</span> <span class="string">'write_encoding'</span> ]</span><br><span class="line">    [ <span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> (<span class="keyword">column</span>, [ ... ] ) | <span class="keyword">DISTRIBUTED</span> RANDOMLY ]</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cloud.tencent.com/developer/article/1447227" target="_blank" rel="noopener">GP系统配置参数</a></p><p><a href="https://greenplum.cn/gp6/load/topics/transforming-xml-data.html" target="_blank" rel="noopener">XML转换示例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- GreenPlum</title>
    <link href="https://LinQing2017.github.io/2019/10/08/Greenplum-%E4%BB%8B%E7%BB%8D&amp;%E9%83%A8%E7%BD%B2/"/>
    <id>https://LinQing2017.github.io/2019/10/08/Greenplum-介绍&amp;部署/</id>
    <published>2019-10-07T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.716Z</updated>
    
    <content type="html"><![CDATA[<p>GreenPlum 调研笔记</p><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>GreenPlum中文社区的<a href="https://greenplum.cn/intro/" target="_blank" rel="noopener">介绍</a>中，将Greenplum定位成<strong>开源大数据平台</strong>，而不仅仅是一个MPP数据查询引擎。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gp.stage.vonbros.com/wp-content/themes/twentyseventeen/assets/images/architecture.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Greenplum的优势：</p><ul><li>处理和分析各种数据源的数据的平台：包括hadoop、Hive、HBase、S3等等，支持结构化、半结构化、非结构化数据</li><li>数据水平分布、并行查询执行、专业优化器、线性扩展能力、多态存储、资源管理、高可用、高速数据加载</li><li>接口可扩展，支持SQL、JDBC和ODBC等行业标准</li><li>集成数据分析平台：MADlib (Github 245个Star，半死不活)</li><li>在金融、保险、证券等领域有众多应用案例，具备较为完善的生态</li><li>采用 ** Apache 2 协议 **</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://greenplum.cn/gp6/graphics/highlevel_arch.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Greenplum基本架构包括：Master、SegmentHost。</p><ul><li>Master：Greenplum数据系统的入口，Client连接Master提供SQL。Master管理了全局系统目录，包含了有关Greenplum数据库本身的元数据（系统表）。Master的主备基于WAL预写式日志来实现主/备镜像。</li><li>SegmentHosts：基于Postgresql 8.3的定制数据库，负责存储和处理用户数据。 一台Segment主机通常运行2至8个Greenplum的Segment。</li><li>Interconect：Interconect是Greenplum数据库架构中的网络层，默认协议UDPIFC，如果使用TCP协议，那么Greenplum限制1000个Segment。</li></ul><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><p>Greenplum支持事务控制，当并发更新时Greenplum通过MVCC模型来保证事务数据一致性。</p><p><strong>MVCC模型</strong>基于<strong>快照</strong>机制是Postgresql中的一个特性，能够管理数据行的多个版本。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>数据库ACID特性的描述：</p><ul><li><p>Atomicity：事务的操作结果要么全部执行要么全部不执行</p></li><li><p>Consistency：总是从一个一致的状态转换到另一个一致的状态</p></li><li><p>Durability：事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p></li><li><p>Isolation：事务的修改结果在什么时间能够被其他事务看到（SQL1992规范），隔离级别包括以下四个：</p><ul><li>未提交读：事务能够看到其他事务没有提交的修改，当另一个事务又回滚了修改后导致读取到脏数据，这种情况又称为 <strong>脏读</strong></li><li>已提交读：事务能够看到其他事务提交后的修改，这时会出现<strong>一个事务内两次读取数据</strong>不一致，这种模式下事务是<strong>不可重复读</strong>的。</li><li>可重复读:在两次读取时读取到的同一行数据是一致的，但是两次查询可能查到行数不一致（其他事务出现新的插入），这种情况称为<strong>幻读</strong>。</li><li>序列化级别：不允许出现幻读、脏读、不可重复读。</li></ul></li></ul><p><strong>Greenplum中未提交读、已提交读隔离模式的效果和标准SQL一致；可重复读模式避免了不可重复读和幻读；Greenplum数据库并不完全支持可串行化模式（该模式时自动退化到可重复读模式），并且数据操作并非真正串行化的。</strong></p><p>上述特性中，Isolation是关键，不同数据库实现了不同级别的隔离性，并且通常情况下使用<strong>锁</strong>来解决这些问题。<br>传统方案采用<strong>读写锁</strong>（读锁和读锁之间不互斥，写锁互斥其他所有锁），MVCC是一种完全使读写操作并发的方案（完全抛弃锁）。</p><p>用户执行事务时可以在SQL中指定，事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>MVCC的实现：</p><ul><li><p>在PostgreSQL中，每一个事务(包括单条SQL)都会得到一个被称作为 XID 的事务ID。Session请求事务操作时，PostgreSQL递增XID并赋给这个事务。</p></li><li><p>每一行记录都存储了事务相关信息，这些信息用于判断当前事务是否可见。</p><ul><li>xmin：在创建记录时，记录此时的事务id，后面每次update也会更新。</li><li>xmax：在更新或删除或lock时，记录此时的事务id；如果记录没有被删除，那么此时为0。</li><li>cmin：多语句事务存储创建这个元组的Command ID</li><li>cmax：多语句事务删除这个元组的Command ID</li></ul></li><li><p>一个事务会看到 xid &lt; xmin 的行（这些行已经commit），并且这些行 xid &gt; xmax （这些行已经被删除）。</p></li><li><p>cmin/cmax：用于多语句事务中，只在事务期间有意义，事务开始时该序列被重置为0。</p></li><li><p>每一个Segment数据库都有其自己的XID序列，Master会使用一个分布式事务ID，称为gp_session_id，Segment会会维护一个分布式事务ID到其本地XID的映射。</p></li><li><p>当一个Segment上的事务失败，会回滚所有Segment的修改。</p></li><li><p>一行支持二十亿个事务，这之后这一行将成为一个新行，通过一次VACUUM操作可以避免这样的情况。可以配置xid_warn_limit和 xid_stop_limit控制事务上限告警。</p></li></ul><p>MVCC的实现存储了多个数据版本，非常容易造成<strong>表膨胀</strong>。VACUUM命令会标记过期行所使用的空间可以被重用。通常可以使用以下策略运行VACUUM命令：</p><ul><li>重度更新的表，可能每天需要运行几次VACUUM。</li><li>运行了一个更新或者删除大量行的事务之后运行VACUUM。</li><li>VACUUM FULL命令会把表重写为没有过期行，并且将表减小到其最小尺寸，同时该操作会锁表。</li><li>运行<strong>VACUUM VERBOSE tablename</strong>来得到一份Segment上已移除的死亡行数量、受影响页面数以及有可用空闲空间页面数的报告。</li></ul><p>用户可以使用<strong>LOCK LOCK</strong>命令显示加锁（[参考]（<a href="https://gp-docs-cn.github.io/docs/ref_guide/sql_commands/LOCK.html））。" target="_blank" rel="noopener">https://gp-docs-cn.github.io/docs/ref_guide/sql_commands/LOCK.html））。</a></p><h2 id="数据冗余和故障切换"><a href="#数据冗余和故障切换" class="headerlink" title="数据冗余和故障切换"></a>数据冗余和故障切换</h2><p>部署Greenplum数据库系统时，Segment可以配置Mirror实例，当Primary节点宕机时，Mirror节点提供服务，如果系统中存在Segment没有配置Mirror，那么Segment会成为整个系统的单点故障。</p><p>Greenplum数据库中Segment镜像拓扑：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://greenplum.cn/gp6/graphics/spread-mirroring.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>用户可以选择一台不同于Master节点的主机上部署一个Master实例的备份或者镜像。 </p><p>后备Master利用事务日志复制进程保持与主Master同步，复制进程运行在后备Master上并且负责在主备Master主机之间同步数据。如果主Master失效，日志复制进程会停止，并且后备Master会被激活以替代它的位置。<strong>Master失效时，主备切换不会自动发生，需要外部激励触发。</strong></p><h1 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2. 安装部署"></a>2. 安装部署</h1><p>官方Github上提供了从源码编译gpdb和gporca的完整步骤，同时也提供了预编译好的RPM和DEB包，以下安装不步骤参考网络上的一些文档，并非官方推荐的安装步骤（我没找到！！）。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>所有节点配置NTP服务</p></li><li><p>更新以下系统配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c &apos;cat &gt;&gt; /etc/sysctl.conf &lt;&lt;-EOF</span><br><span class="line">kernel.shmmax = 500000000</span><br><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.shmall = 4000000000</span><br><span class="line">kernel.sem = 500 1024000 200 4096</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.msgmni = 2048</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line">net.ipv4.conf.all.arp_filter = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1025 65535</span><br><span class="line">net.core.netdev_max_backlog = 10000</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.core.wmem_max = 2097152</span><br><span class="line">vm.overcommit_memory = 2</span><br><span class="line"></span><br><span class="line">EOF&apos;</span><br><span class="line"></span><br><span class="line">sudo bash -c &apos;cat &gt;&gt; /etc/security/limits.conf &lt;&lt;-EOF</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br><span class="line"></span><br><span class="line">EOF&apos;</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><p>在每个节点中创建gpadmin用户用于管理Greenplum，并且打通该节点的集群免密</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 530 gpadmin</span><br><span class="line">useradd -g 530 -u 530 -m -d /home/gpadmin -s /bin/bash gpadmin</span><br><span class="line">echo "ruijie" | passwd --stdin gpadmin</span><br><span class="line"></span><br><span class="line">su - gpadmin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只需要打通第一个节点到其他节点的ssh，之后执行 gpssh-exkeys -f hostlists 打通所有节点之间的互信</span></span><br><span class="line">ssh-copy-id gpadmin@node11 &amp;&amp; ssh-copy-id gpadmin@node12 &amp;&amp; ssh-copy-id gpadmin@node13</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装Greenplum-DB"><a href="#安装Greenplum-DB" class="headerlink" title="安装Greenplum DB"></a>安装Greenplum DB</h2><p>下载RPM包，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall -y greenplum-db-6.0.0-rhel7-x86_64.rpm</span><br></pre></td></tr></table></figure><p>安装完成后，安装目录为/usr/local/greenplum-db，同时还要将greenplum-db中的lib添加到ld.so.conf中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c 'cat &gt;&gt; /etc/ld.so.conf.d/greenplum.conf &lt;&lt;-EOF</span><br><span class="line">/usr/local/greenplum-db/lib</span><br><span class="line">EOF'</span><br><span class="line"></span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p>在/home/gpadmin目录下配置环境变量、修改目录权限、创建配置目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># /usr/local/greenplum-db/greenplum_path.sh 添加以下内容</span></span></span><br><span class="line"></span><br><span class="line">source /usr/local/greenplum-db/greenplum_path.sh</span><br><span class="line">export MASTER_DATA_DIRECTORY=/data/data_ssd/greenplum/data/master/gpseg-1</span><br><span class="line">export PGPORT=5432</span><br><span class="line">export PGDATABASE=gp_sydb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改bin文件和数据目录权限：</span></span><br><span class="line">chown -R  gpadmin:gpadmin  /usr/local/greenplum-db/</span><br><span class="line">mkdir -p /data/data_ssd/greenplum # 数据目录</span><br><span class="line">chown -R gpadmin:gpadmin /data/data_ssd/greenplum</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建配置目录</span></span><br><span class="line">su - gpadmin</span><br><span class="line">mkdir -p /home/gpadmin/conf</span><br><span class="line">touch /home/gpadmin/conf/all_hosts #集群all_hosts文件,包含所有节点</span><br><span class="line">touch /home/gpadmin/conf/seg_hosts #集群seg_hosts文件,包含所有segment节点</span><br></pre></td></tr></table></figure><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>登录master的gpadmin用户，验证免密是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 验证免密是否可用</span></span><br><span class="line">gpssh-exkeys -f /home/gpadmin/conf/all_hosts </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gpssh命令提供类似ansible的公众</span></span><br><span class="line">gpssh -f /home/gpadmin/conf/all_hosts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有节点创建数据目录</span></span><br><span class="line">mkdir -p /data/data_ssd/greenplum/data/master </span><br><span class="line">mkdir -p /data/data_ssd/greenplum/data/primary</span><br><span class="line">mkdir -p /data/data_ssd/greenplum/data/mirror</span><br></pre></td></tr></table></figure><p>配置文件模板位于/usr/local/greenplum-db/docs/cli_help/gpconfigs目录中，参考gpinitsystem_config创建配置文件/home/gpadmin/conf/gpinitsystem_config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RRAY_NAME=&quot;Greenplum Data Platform&quot;</span><br><span class="line">SEG_PREFIX=gpseg</span><br><span class="line">PORT_BASE=6000</span><br><span class="line">declare -a DATA_DIRECTORY=(/data/data_ssd/greenplum/data/primary /data/data_ssd/greenplum/data/primary /data/data_ssd/greenplum/data/primary)</span><br><span class="line">MASTER_HOSTNAME=node11</span><br><span class="line">MASTER_DIRECTORY=/data/data_ssd/greenplum/data/master </span><br><span class="line">MASTER_PORT=5432</span><br><span class="line">TRUSTED_SHELL=ssh</span><br><span class="line">CHECK_POINT_SEGMENTS=8</span><br><span class="line">ENCODING=UNICODE</span><br><span class="line">DATABASE_NAME=gp_sydb</span><br><span class="line">MACHINE_LIST_FILE=/home/gpadmin/conf/seg_hosts</span><br><span class="line"></span><br><span class="line"># 需要配置冗余时</span><br><span class="line"># MIRROR_PORT_BASE=7000</span><br><span class="line"># declare -a MIRROR_DATA_DIRECTORY=(/data/data_ssd/greenplum/data/mirror /data/data_ssd/greenplum/data/mirror /data/data_ssd/greenplum/data/mirror)</span><br></pre></td></tr></table></figure><p>执行gpinitsystem -c /home/gpadmin/conf/gpinitsystem_config 初始化数据库。</p><p>如果需要使用冗余配置，则执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpinitsystem -c gpinitsystem_config  -h hostfile_exkeys -s &#123;master备份节点&#125; -S &#123;master备份目录&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>初始化完成后，master节点的 <strong>MASTER_DIRECTORY</strong> 目录下会自动生成<strong>gpseg-1</strong>目录，该目录中的文件类似pg的配置文件，包含：postgresql.conf、pg_hba.conf等内容。</p><p>初始化成功后，Greenplum会自动创建管理员用户（默认情况下为执行初始化化程序的用户）。</p><p>初次启动时，用户需要使用管理员用户登录，并创建Client使用的账号以及修改账号登录方式（pg_hba.conf）。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面的所有操作在Master节点上运行，且使用gpadmin用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">gpstart -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭，-M fast表示关闭所有事务，并且回滚</span></span><br><span class="line">gpstop -M fast</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">gpstop -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载 pg_hba.conf 和 postgresql.conf，部分参数需要通过完全重启才能生效</span></span><br><span class="line">gpstop -u</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 部分情况下，客户端进程会出现卡死，gp集群无法关闭，此时需要具有SUPERUSER权限的Greenplum用户登录postgres，杀死客户端进程。操作过程，参考：https://greenplum.cn/gp6/managing/startstop.html</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SELECT usename, pid, waiting, query, datname FROM pg_stat_activity;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的sql可以查出当前GP的活跃client，使用pg_cancel_backend(pid)、pg_terminate_backend(pid)可以强制退出这些线程。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务的状态</span></span><br><span class="line">gpstate -s</span><br></pre></td></tr></table></figure><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>Greenplum集群中包括：master参数和本地参数，这些参数存储每个实例的postgresql.conf、pg_hba.conf文件中。</p><ul><li><p>master参数：</p><ul><li>系统范围参数：编辑$MASTER_DATA_DIRECTORY/postgresql.conf文件</li><li>数据库级别参数：使用<strong>ALTER DATABASE xxx SET xxx TO xxx</strong>修改</li><li>Role级别参数：使用<strong>ALTER ROLE xxx SET xxx TO xxx;</strong>修改</li><li>会话基本参数：在会话中使用<strong>SET XXX TO XXX</strong>修改</li></ul></li><li><p>本地参数：本地参数保存在每一个postgresql.conf文件（包括：primary和mirror）中，要更新参数，可以使用 gpconfig 命令（如，<strong>gpconfig -c xxx -v xxx</strong>），也可以使用这个命令查看Seg的参数（如，<strong>gpconfig –show xxx</strong>）。</p></li></ul><p>关于参数配置说明，可以参考<a href="https://gp-docs-cn.github.io/docs/ref_guide/config_params/guc_config.html" target="_blank" rel="noopener">服务器配置参数</a>。</p><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>以下方式可以查看GP集群的日志文件：</p><ul><li>每个Master和Segment实例都在其数据目录的 pg_log中有它们自己的日志文件。</li><li>Master的日志文件包含了大部分信息，应该总是首先检查它。</li><li>gplogfilter工具可以用来检查Greenplum数据库日志文件。 如果要检查segment日志文件，使用gpssh在segment主机上执行gplogfilter工具。默认查找$MASTER_DATA_DIRECTORY 目录下的日志文件，用户也可以手工指定。</li></ul><h1 id="3-高可用"><a href="#3-高可用" class="headerlink" title="3. 高可用"></a>3. 高可用</h1><h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><ul><li>硬件级别RAID：在磁盘级别实现数据冗余</li><li>数据存储总和校验：该机制是默认开启的，数据被写入磁盘时会计算校验和，下一次读取时检查校验和，从而达到防止磁盘上数据损坏的目的（涉及的配置项包括：<strong>ignore_checksum_failure</strong>和<strong>HEAP_CHECKSUM</strong>）。</li><li>Segment镜像</li><li>Master镜像</li><li>双集群：双ETL方案、”备份/恢复”方案</li><li>备份和恢复：gpbackup/gprestore工具备份/恢复Greenplum数据库，<a href="https://greenplum.cn/gp6/managing/backup-gpbackup.html" target="_blank" rel="noopener">参考</a></li></ul><h3 id="配置Segment镜像"><a href="#配置Segment镜像" class="headerlink" title="配置Segment镜像"></a>配置Segment镜像</h3><p>默认情况下，在GP集群运行时执行gpaddmirrors -p 10000，就能在本集群内创建Segment镜像，执行期间会提示输入mirror数据的存储位置。10000表示mirror服务的端口号在原primary基础上加上10000。</p><p>上述命令，以group方式创建mirror，如果用户需要mirror分散部分或者分布在另外的HOST上，那么需要定义文件指定mirror到primary的映射（<a href="https://gp-docs-cn.github.io/docs/admin_guide/highavail/topics/g-enabling-segment-mirroring.html" target="_blank" rel="noopener">参考</a>）。</p><p><strong>gp_segment_configuration</strong>表记录了所有primary和mirror的状态，以及连接信息，这张表常用用于判断mirror的状态。这张表中mode字段描述了Seg的三种状态：</p><ul><li>Change Tracking Mode ：没有找到mirror实例</li><li>resync：重新同步</li><li>in-sync：同步完成</li></ul><p>当mirror因为一些原因同步失败时，可以使用 <strong>gprecoverseg</strong> 进行一次增量同步，或者使用 <strong>gprecoverseg -F</strong> 进行全量同步。</p><p><strong>gp_segment_configuration</strong>表的role和preferred_role表示 Segment 表示当前的状态，以及偏好状态。当它们不匹配时，就可能有每台硬件主机上活动主Segment数量造成的倾斜。为了重新平衡该集群并且让所有的Segment回到它们的首选角色，可以用-r选项运行gprecoverseg命令。</p><p>当Segment故障时，有以下恢复手段：</p><ul><li>在Master节点执行<strong>gprecoverseg</strong>，将下线Segment重新上线。gprecoverseg会恢复数据文件，此时数据库的写活动被禁止。</li><li>当所有Segment状态为<strong>Synchronized</strong>时，可以运行<strong>gprecoverseg -r</strong>使Segment回到它们的首选角色。</li><li><strong>gprecoverseg -F</strong>是全量恢复手段：从活动segment实例（当前主实例）复制数据前， 删除离线segment实例的数据目录。</li><li><strong>gprecoverseg -i recover_config_file</strong>将失效Segment恢复到其他主机，<a href="https://greenplum.cn/gp6/highavail/topics/g-when-a-segment-host-is-not-recoverable.html" target="_blank" rel="noopener">参考</a></li></ul><h3 id="配置Master镜像"><a href="#配置Master镜像" class="headerlink" title="配置Master镜像"></a>配置Master镜像</h3><p>当GP集群正在运行时，通过<strong>gpinitstandby -s {standby_host}</strong>能够快速启动一个Master的镜像。</p><p>通过<strong>gpstate -f</strong>，可以检查Master Mirror的运行状态，正常情况下：standby master的状态应该是passive，WAL sender状态应该是streaming。</p><p><strong>需要注意：StandbyMaster不能提供任何服务！</strong></p><p>主master故障时，需要手工执行<strong>gpactivatestandby</strong>（如，gpactivatestandby -d /data/master/gpseg-1）来激活后备Master。激活Master主机后，可以执行<strong>psql dbname -c ‘ANALYZE;’</strong>。</p><p>关于Master恢复的一些问题：</p><ul><li><p>激活后备Master后，官方建议一直将该Master作为主Master使用，并且初始化一个新的后备Master</p></li><li><p>要恢复原来的主Master遵循下面的步骤（下面将原Master主机成为MHost，当前Master主机称为SMHost）：</p><ul><li>备份 MHost 上的gpseg-1</li><li>在 SMHost 上运行：gpinitstandby -s MHost</li><li>检查 MHost 上后备Master的状态：gpstate -f（standby master 状态应该是passive，WAL sender状态应该是streaming）</li><li>停止 SMHost 上的Master：gpstop -m （即把当前的主master停掉）</li><li>在MHost上运行：gpactivatestandby -d $MASTER_DATA_DIRECTORY（即将当前备升级为主Master）</li><li>移除 SMHost 上的gpinitstandby，并在MHost上执行：gpinitstandby -s SMHOST</li></ul></li></ul><h1 id="4-数据备份和恢复"><a href="#4-数据备份和恢复" class="headerlink" title="4. 数据备份和恢复"></a>4. 数据备份和恢复</h1><p>数据备份和恢复有以下两种方式：</p><ul><li>并行：每台Segment主机都同时把其数据写入到本地的磁盘存储上</li><li>非并行：数据必须通过网络从Segment被发送到Master，后者把所有的数据写入它的存储中。 </li></ul><p>推荐使用并行方式，非并行方式时间上是将GP集群当做一个pg来执行任务。</p><h2 id="gpbackup和gprestore"><a href="#gpbackup和gprestore" class="headerlink" title="gpbackup和gprestore"></a>gpbackup和gprestore</h2><p>gpbackup和gprestore在github上是一个<a href="https://github.com/greenplum-db/gpbackup/releases" target="_blank" rel="noopener">独立项目</a>，不属于gpdb工程，其release是两个可执行文件，下载后放到gpadmin用户目录下就可以使用。</p><p>gpbackup 和 gprestore 支持以下功能：</p><ul><li>并行备份恢复</li><li>全量备份、增量备份</li><li>备份整个数据库，或者 数据库特定scheme和表</li><li>gpbackup将元数据和数据分开成不同文件可读文件，这些文件放在各个节点上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基本备份操作</span></span><br><span class="line">./gpbackup --dbname  benchtest --backup-dir /home/gpadmin/backups</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基本恢复操作</span></span><br><span class="line">./gprestore  --backup-dir /home/gpadmin/backups/ --timestamp 20191010111727 --create-db --jobs 8</span><br></pre></td></tr></table></figure><p>其他关于GP集群备份的内容：</p><ul><li><a href="https://greenplum.cn/gp6/managing/backup-gpbackup-incremental.html" target="_blank" rel="noopener">增量备份</a></li><li><a href="https://greenplum.cn/gp6/managing/backup-boostfs.html" target="_blank" rel="noopener">在特定存储设备上备份</a></li><li><a href="https://greenplum.cn/gp6/managing/backup-plugin-api.html" target="_blank" rel="noopener">自定义存储插件</a></li></ul><h1 id="5-扩容"><a href="#5-扩容" class="headerlink" title="5. 扩容"></a>5. 扩容</h1><p>对GP集群进行扩容需要注意的几点：</p><ul><li><p>当Segment使用Mirror时，一次扩容最少需要两台机器（如果不使用Mirror则没有这种要求）；</p></li><li><p>括容之后Segment需要对表进行重平衡：</p><ul><li>重平操作是一次数据重写，会极大消耗磁盘IO，以及占用磁盘空间</li><li><strong>表在重平衡期间不可用</strong></li><li>用户可以控制表的重平衡顺序</li><li>重平衡不影响新创建的表</li></ul></li><li><p>扩容之前的数据备份文件不可用，需要重新备份</p></li></ul><p>扩容步骤：</p><ul><li><p>准备节点：</p><ul><li>配置系统变量，必要时候进行性能测试</li><li>安装Greenplum软件</li><li>创建gpadmin用户</li><li>配置SSH免密</li></ul></li><li><p>初始化新节点：这个步骤将新的节点添加到GP集群中</p><ul><li>创建扩容文件，这个文件可以手工编辑，也可以通过 <strong>gpexpand</strong> 命令生成（如何生成该文件<a href="https://greenplum.cn/gp6/expand/expand-initialize.html" target="_blank" rel="noopener">参考</a>）。</li><li>运行<strong>gpexpand -i input_file</strong>，将扩容实例上线，如果上述过程失败可以执行<strong>gpexpand –rollback</strong>回滚。</li></ul></li><li><p>重分布表：此步骤一旦开始，那么需要重平衡的表变得不再可读写</p><ul><li>执行<strong>gpexpand -d 60:00:00</strong>可以开始表扩容操作，-d表示重分布的最大时间限制</li><li>进行重分布时，通过gpexpand.status、gpexpand.expansion_progress、gpexpand.status_detail表可以查看重分布表的状态，调整gpexpand.status_detail的rank值还可以控制重分布表的顺序。</li></ul></li><li><p>移除扩容操作</p><ul><li>gpexpand -c</li></ul></li></ul><h1 id="6-数据对象"><a href="#6-数据对象" class="headerlink" title="6.数据对象"></a>6.数据对象</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Greenplum中数据库有<strong>模板</strong>的概念，用户可以从模板创建数据库，新的数据库会拥有模板的所有表和数据。</p><ul><li>默认模板包括：template1所有新建库的默认模板、template0系统数据库（如postgres）的模板</li><li>从模板克隆数据库：<strong>CREATE DATABASE new_dbname TEMPLATE old_dbname;</strong></li><li>本质上模板和数据库等价，任何数据库都能当做模板</li><li>查看当前数据库：<strong>\l</strong>、<strong>查看pg_database表</strong></li></ul><h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>表空间用于<strong>将数据库中的对象(如表、索引等)到不同的存储介质上</strong>，不同表空间的区别在于<strong>存储介质不同</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个表空间，其存放目录要事先创建，并且所有Seg都能访问</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> fastspace LOCATION <span class="string">'/fastdisk/gpdb'</span>;</span><br><span class="line"><span class="comment">-- 为Role赋权，使他能够在表空间上创建对象</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">ON</span> <span class="keyword">TABLESPACE</span> fastspace <span class="keyword">TO</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="comment">-- 创建表时指定表空间</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> foo(i <span class="built_in">int</span>) <span class="keyword">TABLESPACE</span> fastspace;</span><br><span class="line"><span class="comment">-- 指定默认表空间</span></span><br><span class="line"><span class="keyword">SET</span> default_tablespace = fastspace;</span><br></pre></td></tr></table></figure><p>查询<strong>pg_tablespace</strong>可以得到当前环境的所有表空间，Greenplum创建之后包含默认表空间：</p><ul><li>pg_default ：默认表空间。由template1和template0数据库使用，存储位置为$PADATA/base/。</li><li>pg_global  ：用于共享系统的catalogs，存储位置为$PADATA/global/。</li></ul><p>Greenplum中的表空间和PG是一致的，可以参考这个<a href="https://www.cnblogs.com/lottu/p/9239535.html" target="_blank" rel="noopener">文章</a>。</p><h2 id="SCHEMA"><a href="#SCHEMA" class="headerlink" title="SCHEMA"></a>SCHEMA</h2><p>Schema从<strong>逻辑上组织一个数据库中的对象和数据</strong>。 Schema<strong>允许用户在同一个数据库中拥有多于一个对象（例如表）具有相同的名称而不发生冲突</strong>，只要把它们放在不同的Schema中就好，<strong>Public</strong>是默认SCHEMA。</p><p>用户可以设置search_path配置参数来指定在其中搜索对象的可用schema的顺序。 在该搜索路径中第一个列出的方案会成为默认schema。 如果没有指定方案，对象会被创建在默认schema中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 指定查找特定schema下的表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myschema.mytable;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设定数据库的搜索顺序</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> mydatabase <span class="keyword">SET</span> search_path <span class="keyword">TO</span> myschema, </span><br><span class="line"><span class="keyword">public</span>, pg_catalog;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看搜索路径、以及schema</span></span><br><span class="line"><span class="keyword">SHOW</span> search_path;</span><br><span class="line"><span class="keyword">SELECT</span> current_schema();</span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="表分布策略"><a href="#表分布策略" class="headerlink" title="表分布策略"></a>表分布策略</h3><p>支持三种分布策略：</p><ul><li>DISTRIBUTED BY（哈希分布）</li><li>DISTRIBUTED RANDOMLY（随机分布）</li><li>DISTRIBUTED REPLICATED（全分布）</li></ul><p>关于分布策略有以下几点需要注意：</p><ul><li><p>不显示指定分布策略时，表如何分布取决于<a href="https://gp-docs-cn.github.io/docs/ref_guide/config_params/guc-list.html#gp_create_table_random_default_distribution" target="_blank" rel="noopener">gp_create_table_random_default_distribution</a></p></li><li><p>使用随机分布时，不能在表中指定PRIMARY KEY 或者 UNIQUE 列</p></li><li><p>对于DISTRIBUTED BY可以自定义操作符</p></li></ul><h3 id="表存储模型"><a href="#表存储模型" class="headerlink" title="表存储模型"></a>表存储模型</h3><ul><li><p>堆存储：</p><ul><li>默认配置，模型和PostgreSQL相同</li><li>堆表存储在OLTP类型负载下表现最好，适合频繁修改的的小表</li><li>行级存储方式</li></ul></li><li><p>追加优化存储：指定appendoptimized=true</p><ul><li>成批地被载入并且被只读查询访问的事实表；</li><li>不推荐单行的INSERT语句</li><li>更新表时有功能限制（如事务中不支持UPDATE和DELETE等）</li></ul></li><li><p>选择面向行或者面向列的存储：列表(appendoptimized=true, orientation=column)</p><ul><li>支持行，列或两者的组合</li><li>面向列的表存储只能用于追加优化表</li><li>频繁的插入时，行表优于列表</li></ul></li><li><p>压缩表： 指定(appendoptimized=true, compresstype=zlib, compresslevel=5);</p><ul><li>只适用于追加优化表</li><li>可以进行整个表的压缩、或者指定列的压缩</li></ul></li></ul><p>参考介绍：<a href="https://greenplum.cn/gp6/ddl/ddl-storage.html" target="_blank" rel="noopener">选择表存储模型</a></p><h2 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h2><ul><li>序列：Greenplum数据库序列对象是一个特殊的单行表，用作数字生成器。 <a href="https://greenplum.cn/gp6/ddl/ddl-sequence.html" target="_blank" rel="noopener">参考</a></li><li>索引：<a href="https://greenplum.cn/gp6/ddl/ddl-index.html" target="_blank" rel="noopener">参考</a></li><li>视图:<a href="https://greenplum.cn/gp6/ddl/ddl-view.html" target="_blank" rel="noopener">参考</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://greenplum.cn/" target="_blank" rel="noopener">GreenPlum中文社区</a></p><p><a href="http://mysql.taobao.org/monthly/2017/10/01/" target="_blank" rel="noopener">PGSQL MVCC机制</a></p><p><a href="https://greenplum.cn/gp6/intro/about_statistics.html" target="_blank" rel="noopener">Greenplum 表统计信息</a></p><p><a href="https://greenplum.cn/gp6/access_db/topics/pgbouncer.html" target="_blank" rel="noopener">PgBouncer客户端配置</a></p><p><a href="https://gp-docs-cn.github.io/docs/ref_guide/ref_guide.html" target="_blank" rel="noopener">Greenplum数据库参考指南</a></p><p><a href="https://gpdb.docs.pivotal.io/6-0/ref_guide/system_catalogs/gp_segment_configuration.html" target="_blank" rel="noopener">Greenplum系统表表结构</a></p><p><a href="https://greenplum.cn/gp6/managing/backup-gpbackup.html" target="_blank" rel="noopener">gprestore和gpbackup介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GreenPlum 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GreenPlum" scheme="https://LinQing2017.github.io/tags/GreenPlum/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- Sysbench</title>
    <link href="https://LinQing2017.github.io/2019/09/30/sysbench/"/>
    <id>https://LinQing2017.github.io/2019/09/30/sysbench/</id>
    <published>2019-09-29T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.776Z</updated>
    
    <content type="html"><![CDATA[<p>Sysbench 性能测试工具</p><a id="more"></a><h1 id="Sysbench"><a href="#Sysbench" class="headerlink" title="Sysbench"></a>Sysbench</h1><p>Sysbench是基于LuaJIT的可编写脚本的多线程基准测试工具，提供系统软硬件层面的性能基准测试，包括;</p><ul><li>数据库基准测试</li><li>文件系统基准测试</li><li>CPU性能基准测试</li><li>内存性能基准测试</li><li>线程调度基准测试</li><li>POSIX信号量基准测试</li></ul><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash</span><br><span class="line">sudo yum -y install sysbench</span><br></pre></td></tr></table></figure><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><h2 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h2><p>测试命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sysbench oltp_insert.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=10000000 --db-driver=pgsql --tables=20 prepare</span><br><span class="line"></span><br><span class="line">sysbench oltp_insert.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=6000000 --db-driver=pgsql --tables=20 run</span><br><span class="line"></span><br><span class="line">sysbench oltp_read_only.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=6000000 --db-driver=pgsql --tables=20 run</span><br><span class="line"></span><br><span class="line">sysbench oltp_read_write.lua --time=60 --percentile=99 --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20 --table-size=100000 --db-driver=pgsql --tables=20 run</span><br><span class="line"></span><br><span class="line">sysbench oltp_insert.lua --pgsql-host=172.24.9.11 --pgsql-port=9999 --pgsql-user=root --pgsql-password=rjbigdata --pgsql-db=sysbench --threads=20  --db-driver=pgsql --tables=20 cleanup</span><br></pre></td></tr></table></figure><p>硬件配置： 128GB + 32CPU + SSD + 万兆网络</p><p>pg配置： shared_buffers = 32GB（huge_pages = on ），其他默认</p><p>测试条件：</p><pre><code>- 预写20张表，每张1000w记录</code></pre><table><thead><tr><th>Case</th><th>insert</th><th>read</th><th>混合</th><th>配置</th></tr></thead><tbody><tr><td>1</td><td>20线程：24885</br>32线程：36893</br>64线程：58137</br>96线程：66747</td><td>20线程：105781</br>96线程：230311</td><td>20线程：54485</br>96线程：58404</td><td>单机PG</td></tr><tr><td>2</td><td>20线程：7249</br>32线程：8752</br>64线程：9991</br>96线程：10545</td><td>20线程：35531</br>96线程：72351</td><td>略：</td><td>2PG+pgpool</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/akopytov/sysbench" target="_blank" rel="noopener">官方GitHub</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sysbench 性能测试工具&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Sysbench - 数据库" scheme="https://LinQing2017.github.io/tags/Sysbench-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库调研笔记 -- PostgreSQL</title>
    <link href="https://LinQing2017.github.io/2019/09/24/Postgresql-%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D/"/>
    <id>https://LinQing2017.github.io/2019/09/24/Postgresql-安装介绍/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.730Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 调研笔记</p><a id="more"></a><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick-Start"></a>Quick-Start</h1><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line">yum -y install postgresql11 postgresql11-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装完成后，安装目录为/usr/pgsql-11，postgresql-11-setup脚本用来进行环境初始化和升级操作。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要注意的是：安装完RPM包后，如果想要修改默认的数据目录（/var/lib/pgsql/11/data），需要修改/usr/lib/systemd/system/postgresql-11.service中的环境变量PGDATA，并执行systemctl daemon-reload。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> postgresql-11-setup会创建postgres和postgres，并且设定用户的home目录为/var/lib/pgsql</span></span><br><span class="line"></span><br><span class="line">/usr/pgsql-11/bin/postgresql-11-setup initdb</span><br><span class="line">systemctl enable postgresql-11</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 pg_hba.conf文件，放开用户远程登录权限，注意同时要放开listen_addresses配置为*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> host    all             root            all                     md5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> host    all             postgres        172.24.9.1/24           md5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">systemctl start postgresql-11</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改postgres用户登录密码，创建root用户</span></span><br><span class="line">sudo -u postgres psql -d postgres -c "ALTER USER postgres WITH PASSWORD 'rjbigdata_admin';"</span><br><span class="line">sudo -u postgres psql -d postgres -c "CREATE ROLE root LOGIN REPLICATION CREATEDB PASSWORD 'rjbigdata'"</span><br></pre></td></tr></table></figure><p>关于系统配置的最佳实践：</p><ul><li><p>建议将硬盘挂载点的Owner设置为PostgreSQL用户，数据目录直接放置在该目录之下（有利于避免升级、clean时的权限问题）。</p></li><li><p>使用NAS文件系统时可以会导致数据损坏（官方建议 synchronously 方式挂载，并且关闭caching），参考<a href="https://www.postgresql.org/docs/11/creating-cluster.html" target="_blank" rel="noopener">NFS的可能的问题</a>。</p></li><li><p>关于型号量和共享内存的配置（<a href="http://www.postgres.cn/docs/10/kernel-resources.html" target="_blank" rel="noopener">参考</a>）,Linux涉及到的配置需要关注的有kernel.shmmax（最大段尺寸）和kernel.shmall（最大共享内存页面）</p></li><li><p>使用systemd必须注意IPC资源（共享内存和信号量） 不会被操作系统过早删除，默认情况下要避免这种情况需要将启动pg的用户设定为系统用户（id小于1000）以及修改/etc/systemd/logind.conf 中RemoveIPC=no。（参考<a href="https://www.postgresql.org/docs/11/kernel-resources.html" target="_blank" rel="noopener">18.4.2. systemd RemoveIPC</a>）</p></li><li><p>资源限制：maxproc、openfiles、datasize</p></li><li><p>防止PG在内存过渡调拨时Killer</p><ul><li>设定systemd文件中的PG_OOM_ADJUST_VALUE=-1000，这样保证子进程不被Killer ；</li><li>设定systemd文件中的PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj 的值为-1000（echo -1000 &gt; /proc/self/oom_score_adj），保证postmaster不被kill</li><li>降低PG内存相关配置，如shared_buffers 和work_mem）</li></ul></li><li><p>shared_buffers配置较大时，可以开启大页配置。评估页面数vm.nr_hugepages，可以参考 postmaster VmPeak / Hugepagesize </p></li><li><p>关闭数据库时，发送不同的信号量，PG关闭的方式不同（kill -INT <code>head -1 /usr/local/pgsql/data/postmaster.pid</code>），<strong>不要用-9关闭PG，危！！</strong></p><ul><li>SIGTERM：智能关闭模式，不在接收新连接、会让现有的会话正常结束它们的工作。仅当所有的会话终止后它才关闭。 </li><li>SIGINT：服务器不再允许新的连接，并向所有现有服务器进程发送SIGTERM，让它们中断当前事务并立刻退出。然后服务器等待所有服务器进程退出并最终关闭。 如果服务处于在线备份模式，备份模式将被终止并致使备份无用。</li><li>SIGQUIT：服务器将给所有子进程发送 SIGQUIT并且等待它们终止。如果有任何进程没有在 5 秒内终止，它们将被发送 SIGKILL。主服务器进程将在所有子进程退出之后立刻退出，而无需做普通的数据库关闭处理。这将导致在下一次启动时（通过重放 WAL 日志）恢复。</li></ul></li></ul><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><ul><li>PostgreSQL 基于 roles 对数据库用户进行权限管理。</li><li>根据roles的创建方式不同，可以指特定用户或者某一组用户，即包含user和groups两个概念）。</li><li>Roles 基于可以和数据库的Objects绑定，或者将名下objects的权限赋予其他roles。</li><li>Roles 与操作系统的用户是完全分开的，不会相互影响。</li><li>系统预创建的超级用户为 postgres ，可以 su - postgres 切换到该用户后登录pg。</li><li>用户也可以在执行psql命令时，使用-U指定登录的用户。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="keyword">name</span>;<span class="comment">-- 创建ROLE，等价于使用createuser name</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">ROLE</span> <span class="keyword">name</span>;<span class="comment">-- 删除ROLE，等价于使用dropuser  name</span></span><br><span class="line"><span class="keyword">SELECT</span> rolname <span class="keyword">FROM</span> pg_roles; <span class="comment">-- 查询已有roles</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="keyword">name</span>;<span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLE</span> XXX <span class="comment">-- 修改用户权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> root LOGIN <span class="keyword">REPLICATION</span> CREATEDB CREATEEXTTABLE <span class="keyword">PASSWORD</span> <span class="string">'rjbigdata'</span>    <span class="comment">-- 创建一个roles，并赋予各种权限</span></span><br><span class="line"><span class="keyword">GRANT</span> group_role <span class="keyword">TO</span> role1, ... ;<span class="comment">-- role赋权</span></span><br><span class="line"><span class="keyword">REVOKE</span> group_role <span class="keyword">FROM</span> role1, ... ;<span class="comment">-- role回收权限</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">ROLE</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="comment">-- 关于Roles权限继承的实例，其中joe被设计成user，admin、wheel被设计成Role Group：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> joe LOGIN INHERIT;<span class="comment">-- joe可以重其他roles中继承权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="keyword">admin</span> NOINHERIT;<span class="comment">-- 不允许从其他roles中继承权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> wheel NOINHERIT;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">admin</span> <span class="keyword">TO</span> joe;</span><br><span class="line"><span class="keyword">GRANT</span> wheel <span class="keyword">TO</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">ROLE</span> <span class="keyword">admin</span> / <span class="keyword">SET</span> <span class="keyword">ROLE</span> wheel; <span class="comment">-- 获取admin和wheel的权限</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">ROLE</span> joe / <span class="keyword">SET</span> <span class="keyword">ROLE</span> <span class="keyword">NONE</span> / <span class="keyword">RESET</span> <span class="keyword">ROLE</span>;  <span class="comment">-- 恢复权限</span></span><br></pre></td></tr></table></figure><h3 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h3><p>PostgreSQL中的权限（pg_roles中有roles的权限明细）：</p><ul><li>login privilege：roles有该权限时，可以作为一个普通用户登录</li><li>superuser status：除了login privilege以外所有权限</li><li>database creation</li><li>role creation</li><li>initiating replication：流复制的角色权限？？ 用来副本同步？</li><li>password</li><li>INHERIT：具有INHERIT属性的成员角色会自动使用其所属成员角色的特权，通常用来在pg中区别roles和users</li></ul><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><p>删除账号时有以下注意点：</p><ul><li>需要将roles名下所有objects收回（ALTER TABLE bobs_table OWNER TO alice;）</li><li>REASSIGN OWNED 可以将一个role名下所有object转义给另一个object</li><li>DROP OWNED 删除role名下所有的object</li></ul><h3 id="默认Roles"><a href="#默认Roles" class="headerlink" title="默认Roles"></a>默认Roles</h3><p>PG提供的一些默认Role，<a href="https://www.postgresql.org/docs/11/default-roles.html" target="_blank" rel="noopener">参考</a>，这些Role名下关联了许多系统表。</p><h2 id="Client-认证"><a href="#Client-认证" class="headerlink" title="Client 认证"></a>Client 认证</h2><ul><li>用户认证相关的配置文件为：pg_hba.conf，如何配置可以<a href="https://www.postgresql.org/docs/11/auth-pg-hba-conf.html" target="_blank" rel="noopener">参考</a></li><li>PG支持password、ldap、gss等方式的认证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 配置pg允许远程连接，pg_hba.conf中追加下面一行</span><br><span class="line">host    all             root            all                     md5</span><br></pre></td></tr></table></figure><h2 id="SQL-Language"><a href="#SQL-Language" class="headerlink" title="SQL Language"></a>SQL Language</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 建表,支持的类型包括：int，smallint，实数，双精度，char（N），varchar（N），date, time, timestamp, interval，以及自定义类型</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> weather (</span><br><span class="line">    city            <span class="built_in">varchar</span>(<span class="number">80</span>),</span><br><span class="line">    temp_lo         <span class="built_in">int</span>,           <span class="comment">-- low temperature</span></span><br><span class="line">    temp_hi         <span class="built_in">int</span>,           <span class="comment">-- high temperature</span></span><br><span class="line">    prcp            <span class="built_in">real</span>,          <span class="comment">-- precipitation</span></span><br><span class="line">    <span class="built_in">date</span>            <span class="built_in">date</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> weather <span class="keyword">VALUES</span> (<span class="string">'San Francisco'</span>, <span class="number">46</span>, <span class="number">50</span>, <span class="number">0.25</span>, <span class="string">'1994-11-27'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> weather (<span class="built_in">date</span>, city, temp_hi, temp_lo) <span class="keyword">VALUES</span> (<span class="string">'1994-11-29'</span>, <span class="string">'Hayward'</span>, <span class="number">54</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 文件批量导入，后端进程直接导入</span></span><br><span class="line">COPY weather FROM '/home/user/weather.txt';</span><br></pre></td></tr></table></figure><h2 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h2><ul><li><p>postgresql.conf文件可以通过pg_ctl reload命令，或者 pg_reload_conf() 函数重载（部分配置可能要重启生效）</p><ul><li>postgresql.conf文件可以包含 include ‘filename’ 配置、include_dir ‘directory’配置</li><li></li></ul></li><li><p>postgresql.auto.conf不应该手工编辑，这个文件保存了通过ALTER SYSTEM命令提供的设置，并且会覆盖postgresql.conf中的配置</p></li><li><p>通过SQL进行配置：ALTER SYSTEM（全局配置，等效于配置文件）、ALTER DATABASE、ALTER ROLE</p></li><li><p>show/set 命令可以查看当前会话的配置，以及针对会话更新配置。</p></li><li><p>服务端启动时可以使用-c 指定配置，这些配置覆盖ALTER SYSTEM和配置文件配置</p></li><li><p>启动Client时可以使用环境变量指定，如（env PGOPTIONS=”-c geqo=off -c statement_timeout=5min” psql）</p></li></ul><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><ul><li><p>文件位置：<a href="http://www.postgres.cn/docs/10/runtime-config-file-locations.html" target="_blank" rel="noopener">参考</a></p></li><li><p>连接和认证：<a href="http://www.postgres.cn/docs/10/runtime-config-connection.html" target="_blank" rel="noopener">参考</a></p><ul><li>max_connections：最大连接数配置，默认是100，实际user的最大连接数为max_connections - superuser_reserved_connections </li></ul></li><li><p>资源消耗：<a href="http://www.postgres.cn/docs/10/runtime-config-resource.html" target="_blank" rel="noopener">参考</a></p><ul><li>内存配置：<ul><li>shared_buffers : 一个合理的shared_buffers开始值是系统内存的 25%。默认是128mb</li><li>work_mem ：内部排序操作和哈希表使用的内存量，默认4mb。一个查询可能有好几个排序或者hash操作，每个操作会使用work_mem大小的内存。</li><li>maintenance_work_mem ：维护性操作（例如VACUUM、CREATE INDEX和ALTER TABLE ADD FOREIGN KEY）中使用的 最大的内存量，默认64mb。</li><li>autovacuum_work_mem : 指定每个自动清理工作者进程能使用的最大内存量。</li><li>temp_buffers ：每个数据库会话使用的临时缓冲区的最大数目，是会话的本地缓冲区，只用于访问临时表，默认是 8 兆字节（8MB）。</li></ul></li><li>工作线程配置：max_worker_processes 、 max_parallel_workers 、max_parallel_workers_per_gather （<a href="http://www.postgres.cn/docs/10/runtime-config-resource.html" target="_blank" rel="noopener">并行查询参考</a>）</li><li>强制刷盘配置：backend_flush_after（默认不强制刷盘）</li></ul></li><li><p>日志相关配置，<a href="http://www.postgres.cn/docs/10/runtime-config-wal.html" target="_blank" rel="noopener">参考</a></p></li><li><p>流复制配置,<a href="http://www.postgres.cn/docs/10/runtime-config-replication.html" target="_blank" rel="noopener">参考</a></p></li><li><p>其他配置，<a href="http://www.postgres.cn/docs/10/runtime-config.html" target="_blank" rel="noopener">参考</a></p></li></ul><h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><p>各种方案<a href="http://www.postgres.cn/docs/10/different-replication-solutions.html#HIGH-AVAILABILITY-MATRIX" target="_blank" rel="noopener">一览表</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.postgresql.org/download/" target="_blank" rel="noopener">安装部署</a></p><p><a href="https://www.pgpool.net/mediawiki/index.php/Main_Page" target="_blank" rel="noopener">Pgpool-II</a></p><p><a href="https://www.postgresql.org/docs/11/biblio.html" target="_blank" rel="noopener">官方参考资料 &amp; 论文集</a></p><p><a href="https://www.postgresql.org/docs/11/charset.html" target="_blank" rel="noopener">PG的编码集配置</a></p><p><a href="http://www.postgres.cn/docs/10/" target="_blank" rel="noopener">PostgreSQL 10.1 手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PostgreSQL 调研笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://LinQing2017.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://LinQing2017.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="https://LinQing2017.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 学习笔记</title>
    <link href="https://LinQing2017.github.io/2019/09/04/0-OpenCV-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://LinQing2017.github.io/2019/09/04/0-OpenCV-学习/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.661Z</updated>
    
    <content type="html"><![CDATA[<p>关于<a href="https://docs.opencv.org/4.1.1/d6/d00/tutorial_py_root.html" target="_blank" rel="noopener">OpenCV-Python Tutorials</a>、ROS By Example的学习笔记</p><a id="more"></a><h1 id="ROS和OpenCV"><a href="#ROS和OpenCV" class="headerlink" title="ROS和OpenCV"></a>ROS和OpenCV</h1><p>在ROS中使用OpenCV进行图像处理是开发ROS程序的常见需要，以下是在Ros中使用OpenCV开发的一些随笔。</p><h2 id="摄像头的驱动"><a href="#摄像头的驱动" class="headerlink" title="摄像头的驱动"></a>摄像头的驱动</h2><p>ROS中使用摄像机包括下面的情景：</p><h3 id="1-Kinect"><a href="#1-Kinect" class="headerlink" title="1.Kinect"></a>1.Kinect</h3><p>在ROS上安装Kinect驱动有以下几种方案：</p><ul><li><p>freenect_stack：底层基于libfreenect，需要额外安装<a href="https://github.com/OpenKinect/libfreenect" target="_blank" rel="noopener">libfreenect</a>或者<a href="https://github.com/OpenKinect/libfreenect2" target="_blank" rel="noopener">libfreenect2</a></p></li><li><p>openni_camera：同样基于openni需要分别安装依赖OpenNI和SensorKinect，安装过程可以参考<a href="https://www.20papercups.net/programming/kinect-on-ubuntu-with-openni/" target="_blank" rel="noopener">博客</a></p></li><li><p>openni_kinect：基于openni是PrimeSense官方负责维护项目，包含：openni_camera、openni_launch、openni_tracker等多个模块。<strong>但是PrimeSense被收购之后，该项目的源码已经无法访问。</strong></p></li><li><p>kinect_aux: Kinect上accelerometer/tilt/led相关功能的独立驱动。</p></li></ul><h3 id="2-IntelRealSense-Xtion"><a href="#2-IntelRealSense-Xtion" class="headerlink" title="2. IntelRealSense/Xtion"></a>2. IntelRealSense/Xtion</h3><p>IntelRealSense官方提供了ROS上的相关驱动，官方<a href="https://github.com/IntelRealSense/realsense-ros" target="_blank" rel="noopener">github</a>。</p><p>Xtion使用<a href="http://wiki.ros.org/openni2_camera" target="_blank" rel="noopener">openni2_camera</a>驱动，使用相机是可以参考<a href="http://docs.ros.org/api/openni2_launch/html/" target="_blank" rel="noopener">openni2_launch</a>。</p><h3 id="3-webcam"><a href="#3-webcam" class="headerlink" title="3. webcam"></a>3. webcam</h3><p> webcam是指通过USB接入的“即插即用”相机，此类相机没有专门的驱动程序，通过系统工具工作。</p><ul><li><a href="http://wiki.ros.org/libuvc_camera" target="_blank" rel="noopener">libuvc_camera</a></li><li><a href="https://wiki.ros.org/usb_cam" target="_blank" rel="noopener">usb_cam</a></li><li><a href="http://wiki.ros.org/gscam" target="_blank" rel="noopener">gscam</a></li></ul><h2 id="ROS处理图像"><a href="#ROS处理图像" class="headerlink" title="ROS处理图像"></a>ROS处理图像</h2><p>ROS中相机信息通过Topic进行发布，其中关键Topic包括：</p><ul><li>image_raw：摄像头拍摄的原始数据，格式为<a href="http://docs.ros.org/api/sensor_msgs/html/msg/Image.html" target="_blank" rel="noopener"><strong>sensor_msgs/Image.msg</strong></a></li><li>camera_info：摄像头元数据信息，包括内参矩阵、对准系数等等，通常这个Topic中数据需要用户进行对准之后，进行人为设定。</li></ul><p>ROS图像处理方面涉及到下面这些工具：</p><h3 id="1-cv-bridge"><a href="#1-cv-bridge" class="headerlink" title="1. cv_bridge"></a>1. <strong>cv_bridge</strong></h3><p><a href="http://wiki.ros.org/cv_bridge/Tutorials" target="_blank" rel="noopener">cv_bridge</a>用来在sensor_msgs/Image和numpy两种格式之间进行转换，使OpenCV能够处理Topic中的图像数据。</p><p>目前cv_bridge提供C++/Python/JAVA 的接口。</p><h3 id="2-image-transport"><a href="#2-image-transport" class="headerlink" title="2. image_transport"></a>2. <strong>image_transport</strong></h3><p>image_transport 可以将Image数据重新转发到新的topic中，其输入可以是Topic、图片、视频。</p><h3 id="3-image-pipeline"><a href="#3-image-pipeline" class="headerlink" title="3. image_pipeline"></a>3. <strong>image_pipeline</strong></h3><p><a href="http://wiki.ros.org/image_pipeline" target="_blank" rel="noopener">image_pipeline</a>是ROS的图像处理工具包，包括以下几个部分：</p><ul><li><a href="http://wiki.ros.org/camera_calibration" target="_blank" rel="noopener">camera_calibration</a>：摄像头标定包</li><li><a href="http://wiki.ros.org/image_proc" target="_blank" rel="noopener">image_proc</a>：图像校正包</li><li><a href="http://wiki.ros.org/stereo_image_proc" target="_blank" rel="noopener">stereo_image_proc</a>：处理双目相机</li><li><a href="http://wiki.ros.org/depth_image_proc" target="_blank" rel="noopener">depth_image_proc</a>：处理深度相机</li><li>image_view、stereo_view：可视化</li></ul><p>简单介绍一下image_pipeline的各个组件：</p><p><strong>image_proc</strong></p><p>image_proc主要用来处理rgb图片，提供node、nodelet两种运行方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node方式运行</span></span><br><span class="line">ROS_NAMESPACE=my_camera rosrun image_proc image_proc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上述node会寻找/my_camera/image_raw和/my_camera/camera_info，并根据后者的参数去校正前者中的图像。最终输出以下（未）校正图像：灰度（去）畸变、彩色（去）畸变。</span></span><br></pre></td></tr></table></figure><p>image_proc 还提供了四个nodelet：</p><ul><li>debayer：将image转换成灰度、彩色两个版本并输出</li><li>rectify：校正图像</li><li>crop_decimate：图像抽样，即将图像的像素减小</li><li>resize：调整图像大小</li></ul><p><strong>depth_image_proc</strong></p><p>depth_image_proc主要用来处理深度图像，其所有的功能通过nodelet来提供：</p><ul><li>convert_metric：量测值变换，将深度信息的单位从mm变为m</li><li>disparity：将深度图重变为disparity格式（disparity是一种视差图，可以通过双目相机生成）</li><li>point_cloud_xyz：将深度图转换成点云图像，输出格式为sensor_msgs/PointCloud2</li><li>point_cloud_xyzrgb：将深度图和RGB合成，并转换成点云图像，输出格式为sensor_msgs/PointCloud2</li><li>register：将深度相机的frame-id变换到另一个坐标系中。</li></ul><h3 id="4-nodelet"><a href="#4-nodelet" class="headerlink" title="4. nodelet"></a>4. <strong>nodelet</strong></h3><p>由于ROS使用Topic方式传输数据存在一定的延时和阻塞。在数据量小、频率低的情况下，传输耗费的时间可以忽略不计。但当传输图像流，点云等数据量较大的消息，或者执行有一定的实时性要求的任务时，因传输而耗费的时间就不得不考虑。nodelet的作用是让多个node在一个进程中用实现零拷贝通信。</p><p>用户需要manager节点，该节点管理多个nodelet节点，并为它们提供高性能数据通信。用户需要根据实际需要开发nodelet（nodelet基于pluginlib插件机制），并将nodelet加载到nodelet manager中（<a href="https://www.cnblogs.com/21207-iHome/p/8213411.html" target="_blank" rel="noopener">blog关于nodelet的介绍</a>）。</p><p>当前图像相关的包多数提供了node和nodelet两种运行模式，使用以下命令可以查看当前系统中所有可运行nodelet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun nodelet declared_nodelets</span><br></pre></td></tr></table></figure><p>以下是调用了image_proc和depth_image_proc中的nodelet实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">"camera"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find rgbd_launch)/launch/includes/manager.launch.xml"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"camera_nodelet_manager"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"debug"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span> <span class="comment">&lt;!-- Run manager in GDB? --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"num_worker_threads"</span>  <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- decimated to 160x120，将像素变为原来1/4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"nodelet"</span> <span class="attr">type</span>=<span class="string">"nodelet"</span> <span class="attr">name</span>=<span class="string">"crop_decimate"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">args</span>=<span class="string">"load image_proc/crop_decimate /camera/camera_nodelet_manager"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera/image_raw"</span> <span class="attr">to</span>=<span class="string">"rgb/image_raw"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera/camera_info"</span> <span class="attr">to</span>=<span class="string">"rgb/camera_info"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera_out"</span> <span class="attr">to</span>=<span class="string">"depth_downsample"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"decimation_x"</span> <span class="attr">value</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"decimation_y"</span> <span class="attr">value</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"queue_size"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&amp;lt;!&amp;ndash; downsampled XYZ point cloud  &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"nodelet"</span> <span class="attr">type</span>=<span class="string">"nodelet"</span> <span class="attr">name</span>=<span class="string">"points_downsample"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">args</span>=<span class="string">"load depth_image_proc/point_cloud_xyz /camera/camera_nodelet_manager"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">ns</span>=<span class="string">"depth_cloud"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"image_rect"</span> <span class="attr">to</span>=<span class="string">"/camera/depth/image_raw"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"camera_info"</span> <span class="attr">to</span>=<span class="string">"/camera/depth/camera_info"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ROS-By-Example的教程"><a href="#ROS-By-Example的教程" class="headerlink" title="ROS By Example的教程"></a>ROS By Example的教程</h1><p>ROS By Example第十章介绍了以下内容：</p><ol><li>如何ROS中安装摄像头驱动。</li><li>在ROS框架之中使用Python-OpenCV，并通过Topic实现数据交互。</li><li>基于普通相机，使用OpenCV实现一个人脸追踪程序。</li><li>基于OpenNI的Skeleton Tracking程序。</li><li>PCL库的介绍</li></ol><p>上述内容的源码在Github的<a href="https://github.com/pirobot/rbx1/tree/indigo-devel/rbx1_vision" target="_blank" rel="noopener">pirobot/rbx1</a>项目中，使用官网这份代码有以下几点值得注意：</p><ol><li><p>rbx1中不少例子基于OpenCV1编写，由于OpenCV2以上版本和OpenCV1接口并非完全兼容，因此需要修改后才能正常使用。</p><ul><li>OpenCV2中完全整合numpy，如cv.CreateImage、cv.GetSize等接口已经完全取消，使用numpy的接口替代。</li><li>cv2中不少常量的名称也和cv中不同</li></ul></li><li><p><a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/nodes/video2ros.py" target="_blank" rel="noopener">video2ros.py</a>能够将avi格式的视频输出到ROS的指定topic中，使用这个脚本可以替代RGB摄像机，该脚本支持视频暂停、循环播放。</p></li><li><p><a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/src/rbx1_vision/ros2opencv2.py" target="_blank" rel="noopener">ros2opencv2.py</a>订阅指定Topic的图像输出，并在process_image函数中进行数据处理。编写视频处理程序时，可以继承该脚本中ROS2OpenCV2类，并复写process_image实现处理逻辑。</p></li><li><p>在catkin中如何编写python项目的makefile可以参考<a href="http://wiki.ros.org/cn/rospy_tutorials/Tutorials/Makefile" target="_blank" rel="noopener">catkin_python_setup</a></p></li></ol><h2 id="人脸追踪Demo"><a href="#人脸追踪Demo" class="headerlink" title="人脸追踪Demo"></a>人脸追踪Demo</h2><p>ROS By Example 10.8 详细介绍了如何利用一个OpenCV的现成算法实现一个人脸追踪程序，该Demo<strong>识别/最终</strong>流程如下：</p><ol><li>通过 Haar分类器，在一帧图像中识别人脸（<a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/src/rbx1_vision/face_detector.py" target="_blank" rel="noopener">face_detector.py</a>）；</li><li>通过 goodFeaturesToTrack方法在人脸区域提取KeyPoint（<a href="https://github.com/pirobot/rbx1/blob/kinetic-devel-beta/rbx1_vision/src/rbx1_vision/good_features.py" target="_blank" rel="noopener">good_features.py</a>）；</li><li>通过 OpenCV’s Lucas-Kanade optical flow 的实现跟踪上述KeyPoint；</li><li>验证当前追踪角点的有效性，添加新KeyPoint或移除失效KeyPoint；</li></ol><p>PS：上述方案基于灰度图像进行人脸追踪，教程中还提供了了一种基于图像色彩进行追踪的方案（基于CamShift算法）。</p><h3 id="Haar分类器"><a href="#Haar分类器" class="headerlink" title="Haar分类器"></a>Haar分类器</h3><p>在图片中识别人脸是一个分类过程，OpenCV提供基于haar特征和lbp特征的分类器。</p><p>使用Haar分类器，需要注意下面几点：</p><ul><li>需要提供训练好的xml格式的模型文件，每个模型文件可以初始化一个分类器（CascadeClassifier）</li><li>对分类器调用detectMultiScale可以返回frame中的匹配结果，可以将多个分类器并联（串联）提高识别准确率</li></ul><p>OpenCV的Haar分类器实现：Haar-like特征 + AdaBoost + 积分图（用来加速计算特征）</p><h3 id="角点检测"><a href="#角点检测" class="headerlink" title="角点检测"></a>角点检测</h3><p>OpenCV中的角点检测：</p><ul><li><p>cornerHarris：Harris角点检测，其检测原理、以及特征可以<a href="https://www.cnblogs.com/ronny/p/4009425.html" target="_blank" rel="noopener">参考blog</a></p><ul><li>参数α对角点检测的灵敏度成反比</li><li>Harris角点检测算子对<strong>亮度</strong>和<strong>对比度</strong>的变化不敏感</li><li>旋转不变性、尺度不变性、不具备仿射不变性(但是可以通过Harris-Affine实现)</li></ul></li><li><p>goodFeaturesToTrack：Shi-Tomasijiao</p></li><li><p>FAST：SUSAN算法</p></li></ul><p><a href="https://www.cnblogs.com/ronny/p/4260167.html" target="_blank" rel="noopener">参考: 图像局部特征点检测算法综述</a></p><h3 id="特征点追踪"><a href="#特征点追踪" class="headerlink" title="特征点追踪"></a>特征点追踪</h3><p>ROS by Example 中使用calcOpticalFlowPyrLK追踪，人脸上的角点运动，从而实现人脸跟踪的目的。</p><p>calcOpticalFlowPyrLK 是OpenCV提供的Lucas Kanade光流算法的实现，能够计算两帧图像之间特征点的位移。</p><p>光流定义为：空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。</p><p>个人理解，光流可以认为是素点的瞬时位移向量，是世界中可以感觉到的明显的视觉运动。</p><p>参考：<a href="https://blog.csdn.net/zouxy09/article/details/8683859" target="_blank" rel="noopener">对OpenCV中光流函数的介绍</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ROS by Example 中人脸跟踪的Demo全都是基于传统CV算法的。由于我没有摄像头，输入使用的是一个清晰度很差的视频图像，最终导致识别和追踪效果全都差强任意。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u011722133/article/details/53337818" target="_blank" rel="noopener">ROS图像相关包</a></p><p><a href="https://www.cnblogs.com/ello/archive/2012/04/28/2475419.html" target="_blank" rel="noopener">Haar分类器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;a href=&quot;https://docs.opencv.org/4.1.1/d6/d00/tutorial_py_root.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenCV-Python Tutorials&lt;/a&gt;、ROS By Example的学习笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="OpenCV" scheme="https://LinQing2017.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>摄像头标定</title>
    <link href="https://LinQing2017.github.io/2019/09/02/%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%87%E5%AE%9A/"/>
    <id>https://LinQing2017.github.io/2019/09/02/摄像头标定/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.778Z</updated>
    
    <content type="html"><![CDATA[<p>简述张氏标定法，以及深度相机标定原理。</p><a id="more"></a><h1 id="RGB相机标定"><a href="#RGB相机标定" class="headerlink" title="RGB相机标定"></a>RGB相机标定</h1><h2 id="矩阵变换关系"><a href="#矩阵变换关系" class="headerlink" title="矩阵变换关系"></a>矩阵变换关系</h2><p>相机标定涉及到以下坐标系，其最终目的是建立<strong>世界坐标系</strong>和<strong>像素坐标系</strong>之间的关系</p><ul><li><strong>世界坐标系</strong>$$(x_w,y_w,z_w)$$：用户定义的三维世界坐标系</li><li><strong>相机坐标系</strong>$$(x_c,y_c,z_c)$$：相机坐标系z轴和光轴重合，且垂直于图像坐标系</li><li><strong>图像坐标系</strong>$$(x,y,z)$$：成像平面坐标</li><li><strong>像素坐标系</strong>$$(u,v)$$：和图像坐标系同平面，但是原点在左上角，单位为像素</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述坐标系有如下变换：</p><p><strong>1. 世界坐标系到相机坐标系</strong></p><p>将三维坐标中的点使用其次坐标表示，且刚体坐标系的变换可以通过旋转和平移得到：<br>$$<br>\left[\begin{matrix}x_c \y_c \z_c \ 1\end{matrix}\right]=<br>\left[\begin{matrix} R &amp; t \ 0 &amp; 1 \end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \z_w \ 1\end{matrix}\right]=<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; r_3 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \0 \ 1\end{matrix}\right]=<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \1\end{matrix}\right] \tag{1}<br>$$<br>上面的公式假定，物体的$$z_w=0$$，即可以认为标定时棋盘平面和$$X_wOY_w$$重合。</p><p><strong>2. 相机坐标到图像坐标系</strong></p><p>这一过程进行了从三维坐标到二维坐标的转换，即寻找相机坐标系中点（三维坐标）在图像坐标系中的成像点（二维坐标）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LinQing2017/notes/blob/master/pictures/%E7%9B%B8%E6%9C%BA%E5%9D%90%E6%A0%87%E7%B3%BB%E5%88%B0%E5%9B%BE%E5%83%8F%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>根据上述图中的变换关系，即可推到出以下公式（$$f$$为相机焦距）。</p><p>$$<br>z_c\left[\begin{matrix}x \y \ 1\end{matrix}\right]=<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix}x_c \y_c \z_c\end{matrix}\right]=<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix} 1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0 \end{matrix}\right]<br>\left[\begin{matrix}x_c \y_c \z_c \1\end{matrix}\right]<br>\tag{2}<br>$$</p><p>*<em>3. *</em>图像坐标系考虑畸变</p><p>畸变是相机内部的固有性质，主要包括：径向畸变、切向畸变、薄透镜畸变。</p><p>$$[x，y，1]^T$$如何矫正畸变转换为实际图像坐标系暂时不介绍。</p><p><strong>4. （实际）图像坐标系到像素坐标系</strong></p><p>由于定义的像素坐标系原点与图像坐标系原点不重合，假设像素坐标系原点在图像坐标系下的坐标为$$(u0，v0)$$，每个像素点在图像坐标系x轴、y轴方向的尺寸为：dx、dy（每个像素点代表的实际尺寸），且像点在实际图像坐标系下的坐标为$$(x，y)$$，于是可得到像点在像素坐标系下的坐标为：</p><p>$$u=x/d_x+u_0, v=v/d_y+v_0$$，矩阵形式为：<br>$$<br>\left[\begin{matrix}u \v \1\end{matrix}\right] =<br>\left[\begin{matrix} 1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix}x \y \1\end{matrix}\right] \tag3<br>$$</p><p>将上面的三个公式合并，得到世界坐标系——相机坐标系——图像坐标系——像素坐标系的转换公式：<br>$$<br>\left[\begin{matrix}u \v \1\end{matrix}\right] =<br>\left[\begin{matrix} 1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]1/z_c<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix} 1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0 \end{matrix}\right]<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; r_3 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \y_w \0 \ 1\end{matrix}\right]<br>$$<br>根据上面的公式化简，得到：<br>$$<br>M=\left[\begin{matrix} 1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix} f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1 \end{matrix}\right]=<br>\left[\begin{matrix} f/d_x=f_x&amp;0&amp;u_0\0&amp;f/d_y=f_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>$$</p><p>$$<br>\left[\begin{matrix} R &amp; t \ 0 &amp; 1 \end{matrix}\right]=<br>\left[\begin{matrix} 1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0 \end{matrix}\right]<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; r_3 &amp; t\end{matrix}\right]<br>$$</p><p>上面两矩阵即是标定时的相机<strong>内参矩阵</strong>和<strong>外参矩阵</strong>，根据两者的含义可以知道：</p><ul><li><p>内参矩阵是固定不变的</p></li><li><p>外参矩阵由于相机相对于世界坐标系的位置不同，会发生变化。</p></li></ul><p>  PS：外参矩阵通常表示成棋盘格到相机坐标系的变换，相机到棋盘格有多少个视角，就有多少个外参矩阵。此处实际上是假设：<strong>棋盘平面和$$X_wOY_w$$重合，即$$Z_w=0$$</strong>。</p><p>  如果按照以下方式标定：</p><ul><li><p>将机械臂基座作为世界坐标系</p></li><li><p>相机位置固定</p></li><li><p>棋盘格固定在TCP上，通过移动TCP点获取相机到棋盘格的不同视角，然后进行标定</p><p>按上述方式，世界坐标系到相机的变换是固定的，外参实际上是机械器末端执行器的一个坐标系到相机坐标系的变换。</p></li></ul><h2 id="张氏相机标定"><a href="#张氏相机标定" class="headerlink" title="张氏相机标定"></a>张氏相机标定</h2><p>由像素坐标系到世界坐标系的成像关系如下：<br>$$<br>\left[\begin{matrix}u \ v \ 1\end{matrix}\right]=<br>s\left[\begin{matrix} f_x&amp;\gamma&amp;u_0\0&amp;f_y&amp;v_0\0&amp;0&amp;1 \end{matrix}\right]<br>\left[\begin{matrix}r_1 &amp; r_2 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \ y_w \ 1\end{matrix}\right]=<br>sM\left[\begin{matrix}r_1 &amp; r_2 &amp; t\end{matrix}\right]<br>\left[\begin{matrix}x_w \ y_w \ 1\end{matrix}\right]<br>$$<br>上面公式中s是<strong>尺度因子</strong>，$$fx、fy、u0、v0、γ$$（由于制造误差产生的两个坐标轴偏斜参数，通常很小）表示5个相机内参，$$R,t$$表示相机外参。</p><p>上述变换实际上是一个单应性变换，对应变换矩阵为<strong>单应性矩阵</strong>，它<strong>同时包含了相机内参和外参</strong>。</p><p>所以相机标定的目标即根据标定图得到单应矩阵，具体的过程如下：</p><ul><li>打印一张棋盘格标定图纸，将其贴在平面物体的表面</li><li>拍摄一组不同方向棋盘格的图片，可以通过移动相机来实现，也可以移动标定图片来实现</li><li>对于每张拍摄的棋盘图片，检测图片中所有棋盘格的特征点（角点，也就是下图中黑白棋盘交叉点）。可以定义打印的棋盘图纸位于世界坐标系Zw=0的平面上，世界坐标系的原点位于棋盘图纸的固定一角，像素坐标系原点位于图片左上角。</li><li><strong>棋盘标定图纸中所有角点的空间坐标是已知的</strong>，<strong>角点对应在拍摄的标定图片中的角点的像素坐标也是已知的</strong></li><li>使用OpenCV中的现成函数求解单应矩阵</li></ul><h1 id="深度相机标定"><a href="#深度相机标定" class="headerlink" title="深度相机标定"></a>深度相机标定</h1><p>深度相机同样需要标定相机内参和外参，并且当深度相机和RGB相机的安装位置有区别时，还需将深度相机的信息转换到RGB相机中，这个过程称为<strong>配准</strong>。</p><ul><li>深度相机标定：求解深度相机的内参和外参</li><li>深度相机配准：求解深度相机到RGB相机的变换矩阵</li></ul><p>不同于RGB相机，深度相机的标定有很多方法，这里不介绍原理。</p><h1 id="相机标定工具"><a href="#相机标定工具" class="headerlink" title="相机标定工具"></a>相机标定工具</h1><h2 id="1-GML"><a href="#1-GML" class="headerlink" title="1. GML"></a>1. GML</h2><p><a href="http://graphics.cs.msu.ru/en/node/909" target="_blank" rel="noopener">GML C++ Camera Calibration Toolbox</a>是基于OpenCV的一款开源相机标定工具，具有图形界面，能够对RGB相机进行标定，并返回相机<strong>内参矩阵</strong>、<strong>畸变函数</strong>。</p><h2 id="2-camera-calibration"><a href="#2-camera-calibration" class="headerlink" title="2. camera_calibration"></a>2. camera_calibration</h2><p><a href="http://wiki.ros.org/camera_calibration" target="_blank" rel="noopener">Camera Calibration</a>是ROS上的一个标定工具，该工具使用棋盘格的方式可以标定深度和彩色相机。</p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="1-齐次坐标"><a href="#1-齐次坐标" class="headerlink" title="1. 齐次坐标"></a>1. 齐次坐标</h2><p>齐次坐标表示是计算机图形学的重要手段之一，它既能够用来<strong>明确区分向量和点</strong>，同时也更易用于进行仿射（线性）几何变换。</p><p>基本内容：</p><ul><li><p>对于向量$$\vec v$$及其基$$( \boldsymbol a, \boldsymbol b, \boldsymbol c)$$存在一组坐标$$(v_1,v_2,v_3)$$，使得$$\vec v=v_1<em>a+v_2</em>b+v_3*c$$</p></li><li><p>对于空间中的点$$p$$则存在坐标$$(p_1,p_2,p_3)$$，使得$$p-p_0=p_1<em>a+p_2</em>b+p_3*c$$，其中$$p_0$$是坐标系的原点</p></li></ul><p>考虑以上两个公式，在三维坐标系中，统一表示向量和点可以使用四维向量$$(v_1,v_2,v_3,w)$$，当$$w=0$$时该四维向量表示三维空间的一个向量，当$$w=1$$时该四维向量表示三维空间的一个点。</p><h2 id="2-单应性变换"><a href="#2-单应性变换" class="headerlink" title="2. 单应性变换"></a>2. 单应性变换</h2><p><strong>单应性变换</strong>是一种图像变换方式，常见图像变换包括以下几种。</p><ul><li><p>线性变换：旋转、镜像、缩放、推移</p></li><li><p>仿射变换：线性变换 + <strong>平移</strong></p></li><li><p>透视变换：图片投影到一个新的视平面</p></li><li><p>单应性变换：一个平面到另外一个平面的投影映射。如，二维平面上的点映射到摄像机成像仪上的映射。</p></li></ul><p>单应性变换会涉及到<strong>单应性矩阵</strong>，有以下公式：</p><p>$$b = Ha^T$$，其中$$a=[x,y,1]^T$$，$$a=[x_1,y_1,1]^T$$为同一个点在原图像和映射图像上的坐标，$$H$$为$$3*3$$的单应性矩阵。</p><p>要求解上述公式中的H，只需获得四个点对即可，在OpenCV等视觉算法库中通常都有相应函数。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/csyisong/archive/2008/12/09/1351372.html" target="_blank" rel="noopener">齐次坐标</a></p><p><a href="https://www.cnblogs.com/ml-cv/p/5871052.html?utm_source=itdadao&utm_medium=referral" target="_blank" rel="noopener">单应性变换求解</a></p><p><a href="http://www.sohu.com/a/220313594_100007727" target="_blank" rel="noopener">张氏相机标定1</a></p><p><a href="http://www.sohu.com/a/223594989_100007727" target="_blank" rel="noopener">张氏相机标定2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简述张氏标定法，以及深度相机标定原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="OpenCV" scheme="https://LinQing2017.github.io/tags/OpenCV/"/>
    
      <category term="标定" scheme="https://LinQing2017.github.io/tags/%E6%A0%87%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（六）</title>
    <link href="https://LinQing2017.github.io/2019/08/21/6-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/21/6-ROS学习笔记/</id>
    <published>2019-08-20T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.695Z</updated>
    
    <content type="html"><![CDATA[<p>tf包的介绍，以及基本使用。</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>示例程序展示了二维平面内：通过TF实现的坐标跟随（turtle仿真中两只小乌龟相互跟随，<a href="http://wiki.ros.org/tf/Tutorials/Introduction%20to%20tf" target="_blank" rel="noopener">参考</a>）。</p><p>整个示例程序包括以下node：</p><ul><li>turtle1_tf_broadcaster：广播turtle1的绝对坐标</li><li>turtle2_tf_broadcaster: 广播turtle2的绝对坐标</li><li>turtle_tf_listener: 从/tf获取turtle2到turtle1的相对变换，并控制turtle2向turtle1移动</li><li>turtlesim_node、turtle_teleop_key：turtle套件</li></ul><h2 id="广播Node"><a href="#广播Node" class="headerlink" title="广播Node"></a>广播Node</h2><p>广播node监听/turtle/pose中的位置数据，并计算其绝对坐标系。</p><p>针对其接收到的每一条消息，调用回调函数将其广播到/tf中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_turtle_pose</span><span class="params">(msg, turtlename)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        回调函数，负责广播turtle的相对坐标系</span></span><br><span class="line"><span class="string">    :param msg:</span></span><br><span class="line"><span class="string">    :param turtlename:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    br = tf.TransformBroadcaster()</span><br><span class="line">    br.sendTransform((msg.x, msg.y, <span class="number">0</span>),</span><br><span class="line">                     tf.transformations.quaternion_from_euler(<span class="number">0</span>, <span class="number">0</span>, msg.theta), <span class="comment"># 将欧拉角，转换为四元数</span></span><br><span class="line">                     rospy.Time.now(),</span><br><span class="line">                     turtlename,</span><br><span class="line">                     <span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        turtle_tf_broadcaster节点负责发布某个turtle的绝对坐标系（即相对于World坐标系的变换）。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        进程启动后完成以下工作：</span></span><br><span class="line"><span class="string">            1. 获取传入的参数turtle；</span></span><br><span class="line"><span class="string">            2. 监听/~turtle/pose的消息，并对每个消息调用回调函数handle_turtle_pose</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    rospy.init_node(<span class="string">'turtle_tf_broadcaster'</span>)</span><br><span class="line">    turtlename = rospy.get_param(<span class="string">'~turtle'</span>)</span><br><span class="line">    rospy.Subscriber(<span class="string">'/%s/pose'</span> % turtlename,</span><br><span class="line">                     turtlesim.msg.Pose,</span><br><span class="line">                     handle_turtle_pose,        <span class="comment"># 回调函数</span></span><br><span class="line">                     turtlename)                <span class="comment"># 回调函数的参数</span></span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p><a href="http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28Python%29" target="_blank" rel="noopener">完整代码</a></p><h2 id="监听变换"><a href="#监听变换" class="headerlink" title="监听变换"></a>监听变换</h2><p>接收并缓冲系统中广播的所有坐标系，查询特定坐标系之间的变换关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    rospy.init_node(<span class="string">'turtle_tf_listener'</span>)</span><br><span class="line">    listener = tf.TransformListener()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        在turtlesim_node中在模拟出第二个turtle，并指定其初始位置和位置控制topiccmd_vel</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">    rate = rospy.Rate(<span class="number">10.0</span>) <span class="comment"># 指定以下循环的频率</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取/turtle2到/turtle1的坐标系变换，rospy.Time(0)表示最新的变换</span></span><br><span class="line">            (trans,rot) = listener.lookupTransform(<span class="string">'/turtle2'</span>, <span class="string">'/turtle1'</span>, rospy.Time(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">except</span> (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以下内容控制turtle2向turtle1移动，即将turtle2坐标系向turtle1移动</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><p><a href="http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20listener%20%28Python%29" target="_blank" rel="noopener">完整代码</a></p><h2 id="TF和时间的关系"><a href="#TF和时间的关系" class="headerlink" title="TF和时间的关系"></a>TF和时间的关系</h2><p>计算frame-A在Ta相对于frame-B在Tb的时间坐标系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    now = rospy.Time.now()</span><br><span class="line">    past = now - rospy.Duration(<span class="number">5.0</span>)</span><br><span class="line">    listener.waitForTransformFull(<span class="string">"/turtle2"</span>, now,<span class="string">"/turtle1"</span>, past,<span class="string">"/world"</span>, rospy.Duration(<span class="number">1.0</span>))</span><br><span class="line">    (trans, rot) = listener.lookupTransformFull(<span class="string">"/turtle2"</span>, now,<span class="string">"/turtle1"</span>, past,<span class="string">"/world"</span>)</span><br></pre></td></tr></table></figure><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打印当前tf的拓扑到pdf文件中</span><br><span class="line">rosrun tf view_frames</span><br><span class="line"></span><br><span class="line"># 打印tf拓扑</span><br><span class="line">rosrun rqt_tf_tree rqt_tf_tree</span><br><span class="line"></span><br><span class="line"># 打印坐标系的变换关系，输出为 Translation（原点平移关系）、Rotation（转动角度，包括：四元数和欧拉角）</span><br><span class="line">rosrun tf tf_echo [frame_id_1] [frame_id_2]</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/tf" target="_blank" rel="noopener">tf</a></p><p><a href="http://wiki.ros.org/tf/Tutorials/Debugging%20tf%20problems" target="_blank" rel="noopener">Debugging tf problems</a></p><p><a href="http://wiki.ros.org/tf2" target="_blank" rel="noopener">tf2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tf包的介绍，以及基本使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="tf" scheme="https://LinQing2017.github.io/tags/tf/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（四）</title>
    <link href="https://LinQing2017.github.io/2019/08/13/4-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/13/4-ROS学习笔记/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.694Z</updated>
    
    <content type="html"><![CDATA[<p>理解URDF、XACRO文件的内容</p><a id="more"></a><h1 id="URDF"><a href="#URDF" class="headerlink" title="URDF"></a>URDF</h1><p>URDF(Unified Robot Description Format), 是一种特殊的xml文件格式，绝大多数机器人应当提供xxx_description安装包，可以通过apt-get直接安装。</p><p>xacro文件是一种提供了一些更为高级编辑方式的宏文件，通过下面的命令可以将xacro解析出urdf。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成urdf，一个xacro中可能include了多个子文件，但是最终只会生成一个urdf文件</span></span><br><span class="line">rosrun xacro xacro.py /opt/ros/melodic/share/franka_description/robots/panda_arm_hand.urdf.xacro &gt; panda_arm_hand.urdf</span><br></pre></td></tr></table></figure><h2 id="URDF文件格式"><a href="#URDF文件格式" class="headerlink" title="URDF文件格式"></a>URDF文件格式</h2><p>URDF文件主要包括：</p><ul><li>link：表示Robot的一个关节<ul><li>visual：描述形状，可以是简单形状，或者一个stl格式的文件</li><li>collision：描述link的碰撞体积</li></ul></li><li>joint：表示link之间的相对位置关系，包括：<ul><li>parent</li><li>child</li><li>xyz：原点的平移向量(父链 ——&gt; 子链)，单位为米</li><li>rpy: child和parent坐标系的旋转矢量（转动顺序为：x -&gt; y -&gt; z）</li></ul></li></ul><h2 id="Joint-类型"><a href="#Joint-类型" class="headerlink" title="Joint 类型"></a>Joint 类型</h2><p>参考URDF中<a href="http://wiki.ros.org/urdf/XML/joint" target="_blank" rel="noopener">joint标签</a>的定义，Joint有六种类型：</p><ul><li>revolute ：绕固定轴旋转有角度上下限</li><li>continuous ：绕固定轴旋转没有角度限制</li><li>prismatic ：滑动接头，沿轴线滑动，并具有由上限和下限指定的有限范围</li><li>fixed ：固定连接</li><li>floating ：该关节允许所有6个自由度的运动。</li><li>planar ：该关节允许在垂直于轴的平面中运动。</li></ul><p>上述六种类型中，除fixed和floating以外，其余四种类型的运动轴均通过axis标签（默认情况下是(1,0,0)）定义。</p><p><strong><a href="http://docs.ros.org/melodic/api/sensor_msgs/html/msg/JointState.html" target="_blank" rel="noopener">sensor_msgs/JointState</a></strong>描述revolute和prismatic描述机器人的姿态，格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Header header</span><br><span class="line"></span><br><span class="line">string[] name           # 所有joint名称序列</span><br><span class="line">float64[] position      # joint的运动幅度，是角度或者位移</span><br><span class="line">float64[] velocity      # 当前的速度</span><br><span class="line">float64[] effort        # 关节上施加的力</span><br></pre></td></tr></table></figure><h2 id="XACRO"><a href="#XACRO" class="headerlink" title="XACRO"></a>XACRO</h2><p>XACRO文件和URDF实质上是等价的， 但是提供了一些更高级的方式来组织编辑机器人描述，包括：</p><ul><li>复用URDF段落</li><li>嵌入简单的计算</li><li>include多个xacro文件</li></ul><h2 id="可视化化URDF"><a href="#可视化化URDF" class="headerlink" title="可视化化URDF"></a>可视化化URDF</h2><p>查看urdf文件, 可以使用urdf_tutorial包:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">roslaunch urdf_tutorial display.launch model:=/home/ruijie/Desktop/panda_arm_hand.urdf</span><br><span class="line"></span><br><span class="line">roslaunch urdf_tutorial display.launch model:=/home/ruijie/Desktop/panda_arm_hand.urdf gui:=true</span><br><span class="line"></span><br><span class="line">roslaunch urdf_tutorial xacrodisplay.launch model:=/opt/ros/melodic/share/franka_description/robots/panda_arm_hand.urdf.xacro</span><br></pre></td></tr></table></figure><p>上述命令中display.launch包含以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 输入参数包括模型文件、是否使用GUI、rvizconfig配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"model"</span> <span class="attr">default</span>=<span class="string">"$(find urdf_tutorial)/urdf/01-myfirst.urdf"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"gui"</span> <span class="attr">default</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"rvizconfig"</span> <span class="attr">default</span>=<span class="string">"$(find urdf_tutorial)/rviz/urdf.rviz"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将urdf上传到robot_description中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro.py $(arg model)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"use_gui"</span> <span class="attr">value</span>=<span class="string">"$(arg gui)"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"joint_state_publisher"</span> <span class="attr">type</span>=<span class="string">"joint_state_publisher"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">type</span>=<span class="string">"state_publisher"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"rviz"</span> <span class="attr">pkg</span>=<span class="string">"rviz"</span> <span class="attr">type</span>=<span class="string">"rviz"</span> <span class="attr">args</span>=<span class="string">"-d $(arg rvizconfig)"</span> <span class="attr">required</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述launch启动三个node：</p><ul><li>joint_state_publisher： 一个发布JointState数据的工具。joint_state_publisher读取robot_description参数，查找所有非固定关节并发布一个JointState消息，其中定义了所有这些关节。joint_state_publisher的输出是/<code>joint_states</code> ,输入可以是GUI、其他Topic等。</li><li>robot_state_publisher：订阅/joint_states，根据其中的JointState数据以及Robot的关节参数，更新/tf和/tf_static树中的坐标变换关系。</li><li>rviz：可视化显示</li></ul><h2 id="组合机器人"><a href="#组合机器人" class="headerlink" title="组合机器人"></a>组合机器人</h2><p>UR + Barrett：<a href="https://www.2cto.com/kf/201608/541696.html" target="_blank" rel="noopener">参考文章</a>中的xacro，没有成功。</p><p>Git上有不少UR + Barrett的例子，如<a href="https://github.com/jontromanab/ur5_barrett_moveit" target="_blank" rel="noopener">ur5_barrett_moveit</a>、<a href="https://github.com/jontromanab/ur5_barrett_description" target="_blank" rel="noopener">ur5_barrett_description</a></p><h1 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h1><p>SDF格式是一种从世界级到机器人级的所有内容的完整描述，能够描述Gazebo环境中的Robot以及其他内容。</p><p>SDF可以认为是URDF格式的扩展，提供了以下能力：</p><ul><li>在URDF基础上描述了物体的质量、惯性等更丰富的力学性质；</li><li>通过插件的方式可以描述摄像机、IMU等Gazebo支持的传感器；</li></ul><p>Gazebo提供了一些开源SDF格式的模型，用户可以在线下载或者<a href="https://bitbucket.org/osrf/gazebo_models/downloads/" target="_blank" rel="noopener">离线下载</a>后解压到.gazebo/models目录下。</p><p>Gazebo同时还支持一种.world格式的模型文件，这个文件同样支持SDF格式的语法，同SDF文件本质上没有差异。</p><p>一个空白的world文件，只定义了灯光、背景、视角等信息等信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sdf</span> <span class="attr">version</span>=<span class="string">"1.4"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- We use a custom world for the rrbot so that the camera angle is launched correctly --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">world</span> <span class="attr">name</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uri</span>&gt;</span>model://ground_plane<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Global light source --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uri</span>&gt;</span>model://sun<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Focus camera on tall pendulum --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gui</span> <span class="attr">fullscreen</span>=<span class="string">'0'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">camera</span> <span class="attr">name</span>=<span class="string">'user_camera'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pose</span>&gt;</span>4.927360 -4.376610 3.740080 0.000000 0.275643 2.356190<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view_controller</span>&gt;</span>orbit<span class="tag">&lt;/<span class="name">view_controller</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gui</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">world</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sdf</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SDF格式和URDF格式的差异"><a href="#SDF格式和URDF格式的差异" class="headerlink" title="SDF格式和URDF格式的差异"></a>SDF格式和URDF格式的差异</h2><p>SDF比URDF多出了inertial标签和gazebo标签：</p><ul><li>inertial标签：定义在link标签中，用来描述物体物理属性（如，质心位置、质量、惯性矩阵）</li><li>gazebo标签：gazebo标签可能定义在robot、link、joint等各种地方，其内容一般是Gazebo的扩展属性，通常一般使用.gazebo文件额外定义gazebo标签中的内容。</li></ul><p>通过下面的launch文件，可以将World和URDF文件加载到Gazebo中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Gazebo的启动参数，通常是paused、use_sim_time、gui、headless、debug --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 运行empty_world.launch可以加载，world_name指定的world文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find gazebo_ros)/launch/empty_world.launch"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"world_name"</span> <span class="attr">value</span>=<span class="string">"$(find rrbot_gazebo)/worlds/rrbot.world"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Gazebo的启动参数</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将URDF文件加载到robot_description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro --inorder '$(find rrbot_description)/urdf/rrbot.xacro'"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    spawn_model是gazebo_ros中提供的Python脚本可以解析URDF格式的文件，并在软件中展示。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    参考：rosrun gazebo_ros spawn_model -h 会打印该命令的详细用法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"urdf_spawner"</span> <span class="attr">pkg</span>=<span class="string">"gazebo_ros"</span> <span class="attr">type</span>=<span class="string">"spawn_model"</span> <span class="attr">respawn</span>=<span class="string">"false"</span> <span class="attr">output</span>=<span class="string">"screen"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">args</span>=<span class="string">"-urdf -model rrbot -param robot_description"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- ros_control rrbot launch file --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--include file="$(find rrbot_control)/launch/rrbot_control.launch" /--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Gazebo插件"><a href="#Gazebo插件" class="headerlink" title="Gazebo插件"></a>Gazebo插件</h2><p>Gazebo包括三种类型的插件：</p><ul><li>ModelPlugins</li><li>SensorPlugins</li><li>VisualPlugins</li></ul><p>需要注意SensorPlugins需要附加到link标签中进行定义，而不能单独定义。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... robot description ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"sensor_link"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... link description ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">"sensor_link"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">"camera"</span> <span class="attr">name</span>=<span class="string">"camera1"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 传感器参数 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">"camera_controller"</span> <span class="attr">filename</span>=<span class="string">"libgazebo_ros_camera.so"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 插件参数 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ncnynl.com/archives/201610/947.html" target="_blank" rel="noopener">moveit！中文参考资料</a></p><p><a href="http://gazebosim.org/tutorials?tut=ros_roslaunch" target="_blank" rel="noopener">Tutorial: Using roslaunch to start Gazebo, world files and URDF models</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解URDF、XACRO文件的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="URDF" scheme="https://LinQing2017.github.io/tags/URDF/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记（三）</title>
    <link href="https://LinQing2017.github.io/2019/08/13/3-ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://LinQing2017.github.io/2019/08/13/3-ROS学习笔记/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2020-06-06T10:43:09.694Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Moveit"><a href="#Moveit" class="headerlink" title="Moveit"></a>Moveit</h1><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><p><img src="https://moveit.ros.org/assets/images/diagrams/move_group.png" alt=""></p><p>Moveit！中最重要的模块是move_group节点，该节点起到接口整合，以及提供Action、Service的作用。</p><p>关于move_group有以下几点：</p><ol><li><p>整合C++（move_group_interface）、Python（moveit_commander）、GUI接口（Rviz），提供Action、Service功能</p></li><li><p>从ROS Param Server加载URDF、SRDF、Moveit！以及其他配置</p></li><li><p>move_group节点通过ROS的topic和actions控制robot，告知其位置信息、点云信息、以及其他传感器数据</p></li></ol><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>下面的问题是阅读<a href="https://moveit.ros.org/documentation/concepts/" target="_blank" rel="noopener">Concepts</a>后提炼出来的：</p><ol><li>URDF文件如何定义？如何展示(gazebo、Rviz)？</li><li>SRDF文件包含哪些信息？详细了解SRDF文件文件内容？movit-setup-assistant 生成了哪些文件？这些文件有啥用途？</li></ol><p><del>3. /joint_states 中的数据含义是啥？如何通过他控制机械臂动作？</del></p><p><del>4. robot_state_publisher 如何从/joint_states以及robot_description的URDF中计算TF？TF详细场景如何？</del></p><ol start="3"><li><p>ros_control 如何工作？对hardwareInterface、actuator如何理解？</p></li><li><p>如何使用control？如何定义control？control如何工作？control中涉及的数据有哪些含义？怎么生成的？</p></li><li><p>move_group 和 robot_state_publisher、joint_state_publisher如何交互？</p></li><li><p>FollowJointTrajectoryAction 是啥？如何通过他控制机器人？</p></li><li><p>PlanRequestAdapters和montion_planner如何工作？如何发送Request？Response是什么样的？规划路径时如何添加限制条件？</p></li><li><p>PlanningScene中包含哪些东西？都有什么作用？</p></li><li><p>了解正/逆运动学原理？</p></li><li><p>了解如何进行碰撞检测？如何应用ACM矩阵？</p></li></ol><h1 id="运行UR5的movit-Demo"><a href="#运行UR5的movit-Demo" class="headerlink" title="运行UR5的movit! Demo"></a>运行UR5的movit! Demo</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><pre><code>- jontromanab/ur5_barrett_description- jontromanab/ur5_barrett_bringup- jontromanab/ur5_barrett_moveit</code></pre><h2 id="仿真过程"><a href="#仿真过程" class="headerlink" title="仿真过程"></a>仿真过程</h2><p>Step 1： roslaunch ur5_barrett_bringup ur5_barrett_table_world.launch limited:=true</p><p>Step 2： roslaunch ur5_barrett_moveit ur5_barrett_moveit_planning_execution.launch limited:=true</p><p>Step 3： 运行下面的代码控制末端执行器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> PyKDL</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> moveit_commander</span><br><span class="line"><span class="keyword">import</span> moveit_msgs.msg</span><br><span class="line"><span class="keyword">import</span> geometry_msgs.msg</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="keyword">from</span> moveit_commander.conversions <span class="keyword">import</span> pose_to_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    moveit_commander.roscpp_initialize(sys.argv)</span><br><span class="line">    rospy.init_node(<span class="string">'control_ur5'</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    robot = moveit_commander.RobotCommander()</span><br><span class="line">    scene = moveit_commander.PlanningSceneInterface()</span><br><span class="line"></span><br><span class="line">    group_name = <span class="string">"manipulator"</span>  <span class="comment"># endeffector #manipulator</span></span><br><span class="line">    move_group = moveit_commander.MoveGroupCommander(group_name)</span><br><span class="line"></span><br><span class="line">    display_trajectory_publisher = rospy.Publisher(<span class="string">'/move_group/display_planned_path'</span>,</span><br><span class="line">                                                   moveit_msgs.msg.DisplayTrajectory, queue_size=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    current_pose = move_group.get_current_pose()</span><br><span class="line">    print(<span class="string">"================= Before Pos ================= "</span>)</span><br><span class="line">    print(current_pose)</span><br><span class="line"></span><br><span class="line">    pose_goal = geometry_msgs.msg.Pose()  <span class="comment"># Goal position</span></span><br><span class="line">    rot = PyKDL.Rotation.Quaternion(current_pose.pose.orientation.x, current_pose.pose.orientation.y,</span><br><span class="line">                              current_pose.pose.orientation.z, current_pose.pose.orientation.w)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set goal rot</span></span><br><span class="line">    print(rot.GetQuaternion())</span><br><span class="line">    rot.DoRotY(-pi/<span class="number">2</span>)</span><br><span class="line">    pose_goal.orientation = geometry_msgs.msg.Quaternion(*list(rot.GetQuaternion()))</span><br><span class="line">    print(rot.GetQuaternion())</span><br><span class="line">    <span class="comment"># set goal position</span></span><br><span class="line">    pose_goal.position.x = current_pose.pose.position.x</span><br><span class="line">    pose_goal.position.y = current_pose.pose.position.y</span><br><span class="line">    pose_goal.position.z = current_pose.pose.position.z</span><br><span class="line">    <span class="comment"># pose_goal.position.x = 0.7</span></span><br><span class="line">    <span class="comment"># pose_goal.position.y = 0</span></span><br><span class="line">    <span class="comment"># pose_goal.position.z = 0.4</span></span><br><span class="line"></span><br><span class="line">    move_group.set_pose_target(pose_goal)</span><br><span class="line">    move_group.go(wait=<span class="literal">True</span>)</span><br><span class="line">    move_group.stop()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"================= Current Pos ================= "</span>)</span><br><span class="line">    print(current_pose)</span><br></pre></td></tr></table></figure><p>需要注意：</p><p>手臂长度有限，臂长大概是0.8m，离地高度大概是0.36m。如果输入的目标位置，不在这个范围内将会规划失败。指定目标点时，使用的是geometry_msgs/Pose参数，包含：</p><ul><li>geometry_msgs/Point position：世界坐标系下(x,y,z)</li><li>geometry_msgs/Quaternion orientation：执行器转过的角度(绕x轴转动为手掌转动朝向不变，绕y，x轴转动为手掌不动，朝向变动)。</li></ul><p>关于Geometry_Msgs.msg.Pose参考这个<a href="https://answers.ros.org/question/265988/can-someone-explain-geometry_msgs-as-used-for-robot-arm-poses-eg/" target="_blank" rel="noopener">帖子</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ncnynl.com/archives/201610/947.html" target="_blank" rel="noopener">moveit！中文参考资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;Moveit&quot;&gt;&lt;a href=&quot;#Moveit&quot; class=&quot;headerlink&quot; title=&quot;Moveit&quot;&gt;&lt;/a&gt;Moveit&lt;/h1&gt;&lt;h2 id=&quot;系统结构&quot;&gt;&lt;a href=&quot;#系统结构&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="机器人" scheme="https://LinQing2017.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
      <category term="ROS" scheme="https://LinQing2017.github.io/tags/ROS/"/>
    
      <category term="Moveit！" scheme="https://LinQing2017.github.io/tags/Moveit%EF%BC%81/"/>
    
  </entry>
  
</feed>
